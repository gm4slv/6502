ca65 V2.18 - Debian 2.19-1
Main file   : shed.s
Current file: shed.s

000000r 1               
000000r 1               .zeropage
000000r 1               
000000r 1  xx xx        DUMP_POINTER:     .res 2
000002r 1  xx           FLAGS:            .res 1
000003r 1  xx           TOGGLE_TIME:      .res 1
000004r 1  xx           CLOCK_LAST:       .res 1
000005r 1  xx xx        MESSAGE_POINTER:  .res 2
000007r 1  xx xx xx xx  TICKS:            .res 4
00000Br 1  xx           CENTISEC:         .res 1
00000Cr 1  xx           HUNDRED_HRS:      .res 1
00000Dr 1  xx           TEN_HRS:          .res 1
00000Er 1  xx           HRS:              .res 1
00000Fr 1  xx           TEN_MINUTES:      .res 1
000010r 1  xx           MINUTES:          .res 1
000011r 1  xx           TEN_SECONDS:      .res 1
000012r 1  xx           SECONDS:          .res 1
000013r 1  xx xx        MEM_POINTER:      .res 2
000015r 1               
000015r 1               .bss
000000r 1               
000000r 1  xx           INKEY:            .res 1
000001r 1  xx xx xx xx  KEY_PRESS:        .res 4
000005r 1  xx xx        BYTE:             .res 2
000007r 1  xx           TENS:             .res 1
000008r 1  xx           HUNDREDS:         .res 1
000009r 1  xx xx        HEX:              .res 2
00000Br 1  xx xx        HEXB:             .res 2
00000Dr 1  xx           TEMP:             .res 1
00000Er 1  xx           TEMP2:            .res 1
00000Fr 1  xx           HI_DIGIT:         .res 1
000010r 1  xx           LO_DIGIT:         .res 1
000011r 1               
000011r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000011r 1               ;;
000011r 1               ;;        INCLUDES
000011r 1               ;;
000011r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000011r 1               
000011r 1               .include "../includes/ioports.inc"
000011r 2               
000011r 2                 .code
000000r 2               
000000r 2               ; VIA_1 Port addresses
000000r 2               VIA_1     = $6000
000000r 2               PORTB_1   = VIA_1
000000r 2               PORTA_1   = VIA_1 + 1
000000r 2               DDRB_1    = VIA_1 + 2
000000r 2               DDRA_1    = VIA_1 + 3
000000r 2               T1CL_1    = VIA_1 + 4
000000r 2               T1CH_1    = VIA_1 + 5
000000r 2               T1LL_1    = VIA_1 + 6
000000r 2               T1LH_1    = VIA_1 + 7
000000r 2               T2CL_1    = VIA_1 + 8
000000r 2               T2CH_1    = VIA_1 + 9
000000r 2               SR_1      = VIA_1 + 10
000000r 2               ACR_1     = VIA_1 + 11
000000r 2               PCR_1     = VIA_1 + 12
000000r 2               IFR_1     = VIA_1 + 13
000000r 2               IER_1     = VIA_1 + 14
000000r 2               PORTA_NO_HS_1 = VIA_1 + 15
000000r 2               
000000r 2               ; VIA_2 Port addresses
000000r 2               VIA_2     = $5000
000000r 2               PORTB_2   = VIA_2
000000r 2               PORTA_2   = VIA_2 + 1
000000r 2               DDRB_2    = VIA_2 + 2
000000r 2               DDRA_2    = VIA_2 + 3
000000r 2               T1CL_2    = VIA_2 + 4
000000r 2               T1CH_2    = VIA_2 + 5
000000r 2               T1LL_2    = VIA_2 + 6
000000r 2               T1LH_2    = VIA_2 + 7
000000r 2               T2CL_2    = VIA_2 + 8
000000r 2               T2CH_2    = VIA_2 + 9
000000r 2               SR_2      = VIA_2 + 10
000000r 2               ACR_2     = VIA_2 + 11
000000r 2               PCR_2     = VIA_2 + 12
000000r 2               IFR_2     = VIA_2 + 13
000000r 2               IER_2     = VIA_2 + 14
000000r 2               PORTA_NO_HS_2 = VIA_2 + 15
000000r 2               
000000r 2               ; VIA_3 Port addresses
000000r 2               VIA_3     = $4800
000000r 2               PORTB_3   = VIA_3
000000r 2               PORTA_3   = VIA_3 + 1
000000r 2               DDRB_3    = VIA_3 + 2
000000r 2               DDRA_3    = VIA_3 + 3
000000r 2               T1CL_3    = VIA_3 + 4
000000r 2               T1CH_3    = VIA_3 + 5
000000r 2               T1LL_3    = VIA_3 + 6
000000r 2               T1LH_3    = VIA_3 + 7
000000r 2               T2CL_3    = VIA_3 + 8
000000r 2               T2CH_3    = VIA_3 + 9
000000r 2               SR_3      = VIA_3 + 10
000000r 2               ACR_3     = VIA_3 + 11
000000r 2               PCR_3     = VIA_3 + 12
000000r 2               IFR_3     = VIA_3 + 13
000000r 2               IER_3     = VIA_3 + 14
000000r 2               PORTA_NO_HS_3 = VIA_3 + 15
000000r 2               
000000r 2               ; ACIA_1 Port Addresses
000000r 2               ACIA_1    = $4400
000000r 2               S_TXRX_1  = ACIA_1      ; TXD / RXD
000000r 2               S_STA_1   = ACIA_1 + 1  ; Status
000000r 2               S_COM_1   = ACIA_1 + 2  ; Command
000000r 2               S_CON_1   = ACIA_1 + 3  ; Control
000000r 2               
000000r 2               
000000r 2               via_1_init:
000000r 2               
000000r 2  A9 40          lda #%01000000
000002r 2  8D 0B 60       sta ACR_1
000005r 2  A9 0E          lda #$0E
000007r 2  8D 04 60       sta T1CL_1
00000Ar 2  A9 27          lda #$27
00000Cr 2  8D 05 60       sta T1CH_1
00000Fr 2               
00000Fr 2  A9 DA          lda #%11011010  ; T1, CA1 active
000011r 2  8D 0E 60       sta IER_1
000014r 2               
000014r 2  A9 01          lda #$01  ;  CA1 active high-transition
000016r 2  8D 0C 60       sta PCR_1
000019r 2               
000019r 2  A9 7F          lda #%01111111 ; Set all pins on port B to output except BIT 7 which is used for "SHIFT/INSTRUCTION"  button
00001Br 2  8D 02 60       sta DDRB_1
00001Er 2  A9 F0          lda #%11110000 ; Set low-nibble pins on port A to input and high-nibble pins to output, for keypad
000020r 2  8D 03 60       sta DDRA_1
000023r 2               
000023r 2  60             rts
000024r 2               
000024r 2               
000024r 1               .include "../includes/lcd.inc"
000024r 2               
000024r 2               
000024r 2                 .code
000024r 2               
000024r 2               ; LCD Command masks
000024r 2               E  = %01000000
000024r 2               RW = %00100000
000024r 2               RS = %00010000
000024r 2               
000024r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000024r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000024r 2               ;;
000024r 2               ;;
000024r 2               ;;                              LCD Functions
000024r 2               ;;
000024r 2               ;;
000024r 2               ;;
000024r 2               
000024r 2               lcd_start:
000024r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000026r 2  20 rr rr       jsr lcd_instruction
000029r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00002Br 2  20 rr rr       jsr lcd_instruction
00002Er 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000030r 2  20 rr rr       jsr lcd_instruction
000033r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000035r 2  20 rr rr       jsr lcd_instruction
000038r 2  20 rr rr       jsr lcd_entry_mode
00003Br 2  20 rr rr       jsr lcd_cursor_off
00003Er 2  20 rr rr       jsr lcd_clear
000041r 2                 ;jsr lcd_add0
000041r 2  60             rts
000042r 2               
000042r 2               lcd_entry_mode:
000042r 2  A9 06          lda #%00000110 ; Increment and shift cursor; don't shift display
000044r 2  20 rr rr       jsr lcd_instruction
000047r 2  60             rts
000048r 2               
000048r 2               lcd_home:
000048r 2  A9 02          lda #%00000010 ; cursor HOME
00004Ar 2  20 rr rr       jsr lcd_instruction
00004Dr 2  60             rts
00004Er 2               
00004Er 2               lcd_add0:
00004Er 2  A9 80          lda #%10000000 ; back to zero position
000050r 2  20 rr rr       jsr lcd_instruction
000053r 2  60             rts
000054r 2               
000054r 2               lcd_clear:
000054r 2  A9 01          lda #%00000001 ; Clear display
000056r 2  20 rr rr       jsr lcd_instruction
000059r 2  60             rts
00005Ar 2               
00005Ar 2               lcd_cursor_off:
00005Ar 2  A9 0C          lda #%00001100 ; Display on; cursor off; blink off
00005Cr 2  20 rr rr       jsr lcd_instruction
00005Fr 2  60             rts
000060r 2               
000060r 2               lcd_cursor_on:
000060r 2  A9 0F          lda #%00001111 ; Display on; cursor on; blink on
000062r 2  20 rr rr       jsr lcd_instruction
000065r 2  60             rts
000066r 2               
000066r 2               lcd_line_1:
000066r 2  A9 80          lda #($80)
000068r 2  20 rr rr       jsr lcd_instruction
00006Br 2  60             rts
00006Cr 2               
00006Cr 2               lcd_line_2:
00006Cr 2  A9 C0          lda #($80 + $40)
00006Er 2  20 rr rr       jsr lcd_instruction
000071r 2  60             rts
000072r 2               
000072r 2               lcd_line_3:
000072r 2  A9 94          lda #($80 + $14)
000074r 2  20 rr rr       jsr lcd_instruction
000077r 2  60             rts
000078r 2               
000078r 2               lcd_line_4:
000078r 2  A9 D4          lda #($80 + $54)
00007Ar 2  20 rr rr       jsr lcd_instruction
00007Dr 2  60             rts
00007Er 2               
00007Er 2               lcd_wait:
00007Er 2  48             pha
00007Fr 2  A9 70          lda #%01110000  ; LCD data is input (don't change MSB BIT7, it has to stay ZERO for SHIFT Button input)
000081r 2  8D 02 60       sta DDRB_1
000084r 2               lcdbusy:
000084r 2  A9 20          lda #RW
000086r 2  8D 00 60       sta PORTB_1
000089r 2  A9 60          lda #(RW | E)
00008Br 2  8D 00 60       sta PORTB_1
00008Er 2  AD 00 60       lda PORTB_1     ; Read high nibble
000091r 2  48             pha             ; and put on stack since it has the busy flag
000092r 2  A9 20          lda #RW
000094r 2  8D 00 60       sta PORTB_1
000097r 2  A9 60          lda #(RW | E)
000099r 2  8D 00 60       sta PORTB_1
00009Cr 2  AD 00 60       lda PORTB_1       ; Read low nibble
00009Fr 2  68             pla             ; Get high nibble off stack
0000A0r 2  29 08          and #%00001000
0000A2r 2  D0 E0          bne lcdbusy
0000A4r 2               
0000A4r 2  A9 20          lda #RW
0000A6r 2  8D 00 60       sta PORTB_1
0000A9r 2  A9 7F          lda #%01111111  ; LCD data is output (don't change MSB BIT7, it has to stay ZERO for SHIFT Buttion input)
0000ABr 2  8D 02 60       sta DDRB_1
0000AEr 2  68             pla
0000AFr 2  60             rts
0000B0r 2               
0000B0r 2               lcd_init:
0000B0r 2  A9 02          lda #%00000010 ; Set 4-bit mode : DO ONCE AT POWER UP
0000B2r 2  8D 00 60       sta PORTB_1
0000B5r 2  09 40          ora #E
0000B7r 2  8D 00 60       sta PORTB_1
0000BAr 2  29 0F          and #%00001111
0000BCr 2  8D 00 60       sta PORTB_1
0000BFr 2  60             rts
0000C0r 2               
0000C0r 2               lcd_instruction:
0000C0r 2  20 rr rr       jsr lcd_wait
0000C3r 2  48             pha
0000C4r 2  4A             lsr
0000C5r 2  4A             lsr
0000C6r 2  4A             lsr
0000C7r 2  4A             lsr            ; Send high 4 bits
0000C8r 2  8D 00 60       sta PORTB_1
0000CBr 2  09 40          ora #E         ; Set E bit to send instruction
0000CDr 2  8D 00 60       sta PORTB_1
0000D0r 2  49 40          eor #E         ; Clear E bit
0000D2r 2  8D 00 60       sta PORTB_1
0000D5r 2  68             pla
0000D6r 2  29 0F          and #%00001111 ; Send low 4 bits
0000D8r 2  8D 00 60       sta PORTB_1
0000DBr 2  09 40          ora #E         ; Set E bit to send instruction
0000DDr 2  8D 00 60       sta PORTB_1
0000E0r 2  49 40          eor #E         ; Clear E bit
0000E2r 2  8D 00 60       sta PORTB_1
0000E5r 2  60             rts
0000E6r 2               
0000E6r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000E6r 2               ;;
0000E6r 2               ;;        PRINT Characters on LCD - an ASCII value in Accumulator
0000E6r 2               ;;        is printed on the display
0000E6r 2               ;;
0000E6r 2               
0000E6r 2               print_char:
0000E6r 2  20 rr rr       jsr lcd_wait
0000E9r 2  48             pha
0000EAr 2  4A             lsr
0000EBr 2  4A             lsr
0000ECr 2  4A             lsr
0000EDr 2  4A             lsr             ; Send high 4 bits
0000EEr 2  09 10          ora #RS         ; Set RS
0000F0r 2  8D 00 60       sta PORTB_1
0000F3r 2  09 40          ora #E          ; Set E bit to send instruction
0000F5r 2  8D 00 60       sta PORTB_1
0000F8r 2  49 40          eor #E          ; Clear E bit
0000FAr 2  8D 00 60       sta PORTB_1
0000FDr 2  68             pla
0000FEr 2  29 0F          and #%00001111  ; Send low 4 bits
000100r 2  09 10          ora #RS         ; Set RS
000102r 2  8D 00 60       sta PORTB_1
000105r 2  09 40          ora #E          ; Set E bit to send instruction
000107r 2  8D 00 60       sta PORTB_1
00010Ar 2  49 40          eor #E          ; Clear E bit
00010Cr 2  8D 00 60       sta PORTB_1
00010Fr 2  60             rts
000110r 2               
000110r 2               
000110r 1               .include "../includes/getkey.inc"
000110r 2               
000110r 2                 .code
000110r 2               
000110r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000110r 2               ;;
000110r 2               ;;
000110r 2               ;;      READ THE 4x4 keypad using  VIA_1 PORTA
000110r 2               ;;
000110r 2               ;;      Accumulator holds the ASCII value of the pressed key when it returns
000110r 2               ;;
000110r 2               
000110r 2               get_key:
000110r 2               readKeypad:
000110r 2  A2 04          ldx #$04        ; Row 4 - counting down
000112r 2  A0 80          ldy #%10000000  ;
000114r 2               ScanRow:
000114r 2  8C 01 60       sty PORTA_1
000117r 2  AD 01 60       lda PORTA_1
00011Ar 2  29 0F          and #%00001111  ; mask off keypad input - only low 4 (keypad column) bits are read
00011Cr 2  C9 00          cmp #$00
00011Er 2  D0 0B          bne Row_Found   ; non-zero means a row output has been connected via a switch to a column input
000120r 2  CA             dex             ; zero means it hasn't been found, so check next row down
000121r 2  98             tya
000122r 2  4A             lsr
000123r 2  A8             tay
000124r 2  C9 08          cmp #%00001000
000126r 2  D0 EC          bne ScanRow
000128r 2  A9 FF          lda #$ff
00012Ar 2  60             rts
00012Br 2               Row_Found:
00012Br 2  8E rr rr       stx TEMP ; store row
00012Er 2  A0 FF          ldy #$ff
000130r 2               FindCol:
000130r 2  C8             iny
000131r 2  4A             lsr
000132r 2  90 FC          bcc FindCol
000134r 2  98             tya
000135r 2  0A             asl
000136r 2  0A             asl  ; col * 4
000137r 2  18             clc
000138r 2  6D rr rr       adc TEMP ; add row
00013Br 2  AA             tax
00013Cr 2  BD rr rr       lda keypad_array,x
00013Fr 2  60             rts
000140r 2               
000140r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000140r 2               ;;
000140r 2               ;;       key = <INDEX> ; pressing a key returns a 4-bit number
000140r 2               ;;       calculated as (Column * 4 ) + Row, in the range
000140r 2               ;;       1 - 16 which acts as an index to a lookup-table.
000140r 2               ;;       The lookup table returns a byte value equal to the key's
000140r 2               ;;       numerical value
000140r 2               ;;       e.g.
000140r 2               ;;       button 1 returns byte $01 / 00000001
000140r 2               ;;       button F returns byte $0f / 00001111
000140r 2               ;;    ____________________________________________________
000140r 2               ;;   |     1 = <16> | 2 = <12> |    3 = <8> | A(10) = <4> |
000140r 2               ;;   |______________|__________|____________|_____________|
000140r 2               ;;   |     4 = <15> | 5 = <11> |    6 = <7> | B(11) = <3> |
000140r 2               ;;   |______________|__________|____________|_____________|
000140r 2               ;;   |     7 = <14> | 8 = <10> |    9 = <6> | C(12) = <2> |
000140r 2               ;;   |______________|__________|____________|_____________|
000140r 2               ;;   | E(14) = <13> | 0 = <9>  | F(15)= <5> | D(13) = <1> |
000140r 2               ;;   |______________|__________|____________|_____________|
000140r 2               ;;
000140r 2               ;;            Button  ..   D    C    B    A    F    9    6    3    0    8    5    2    E    7    4    1
000140r 2               ;;            <INDEX> 0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16
000140r 2  00 0D 0C 0B  keypad_array: .byte $00, $0D, $0C, $0B, $0A, $0F, $09, $06, $03, $00, $08, $05, $02, $0E, $07, $04, $01
000144r 2  0A 0F 09 06  
000148r 2  03 00 08 05  
000151r 2               
000151r 2               
000151r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000151r 2               ;;
000151r 2               ;;  set ROW keypad outputs high as a source for triggering interrupt when a key is pressed
000151r 2               ;;
000151r 2               ;;
000151r 2               scan:
000151r 2  A0 F0          ldy #%11110000
000153r 2  8C 01 60       sty PORTA_1
000156r 2  60             rts
000157r 2               
000157r 2               
000157r 1               .include "../includes/functions.inc"
000157r 2               
000157r 2               
000157r 2                 .code
000157r 2               
000157r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000157r 2               ;;
000157r 2               ;;          convert an 8-bit binary number from Accumulator, in range 00000000 -> 11111111 ($00 to $FF)
000157r 2               ;;          to its HEX number encode as ASCII -  using a simple lookup table. Store each digit in RAM. Accumulator
000157r 2               ;;          holds the last/low digit on return.
000157r 2               ;;
000157r 2               
000157r 2               
000157r 2               bintohex:
000157r 2  48             pha
000158r 2  4A             lsr
000159r 2  4A             lsr
00015Ar 2  4A             lsr
00015Br 2  4A             lsr
00015Cr 2  AA             tax
00015Dr 2  BD rr rr       lda hexascii,x
000160r 2  8D rr rr       sta HI_DIGIT
000163r 2  68             pla
000164r 2  29 0F          and #$0f
000166r 2  AA             tax
000167r 2  BD rr rr       lda hexascii,x
00016Ar 2  8D rr rr       sta LO_DIGIT
00016Dr 2  60             rts
00016Er 2               
00016Er 2  30 31 32 33  hexascii: .byte "0123456789ABCDEF"
000172r 2  34 35 36 37  
000176r 2  38 39 41 42  
00017Er 2               
00017Er 2               
00017Er 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00017Er 2               ;;
00017Er 2               ;;    convert a binary (hex) value in Accumulator into
00017Er 2               ;;    its ASCII equivalent character in decimal 0-99 and print it
00017Er 2               ;;    this converts hex/binary numbers from the RTC into human readable
00017Er 2               ;;    decimal for display on clock
00017Er 2               
00017Er 2               
00017Er 2               bintoascii:
00017Er 2               
00017Er 2  C9 0A          cmp #10
000180r 2  30 10          bmi single_figure
000182r 2  0A             asl
000183r 2  AA             tax
000184r 2  BD rr rr       lda binascii,x
000187r 2  20 rr rr       jsr print_char
00018Ar 2               
00018Ar 2  E8             inx
00018Br 2               
00018Br 2  BD rr rr       lda binascii,x
00018Er 2  20 rr rr       jsr print_char
000191r 2  60             rts
000192r 2               
000192r 2               single_figure:
000192r 2  0A             asl
000193r 2  AA             tax
000194r 2  E8             inx
000195r 2  BD rr rr       lda binascii,x
000198r 2  20 rr rr       jsr print_char
00019Br 2  60             rts
00019Cr 2               
00019Cr 2               
00019Cr 2  30 30 30 31  binascii: .byte "00010203040506070809"
0001A0r 2  30 32 30 33  
0001A4r 2  30 34 30 35  
0001B0r 2  31 30 31 31            .byte "10111213141516171819"
0001B4r 2  31 32 31 33  
0001B8r 2  31 34 31 35  
0001C4r 2  32 30 32 31            .byte "20212223242526272829"
0001C8r 2  32 32 32 33  
0001CCr 2  32 34 32 35  
0001D8r 2  33 30 33 31            .byte "30313233343536373839"
0001DCr 2  33 32 33 33  
0001E0r 2  33 34 33 35  
0001ECr 2  34 30 34 31            .byte "40414243444546474849"
0001F0r 2  34 32 34 33  
0001F4r 2  34 34 34 35  
000200r 2  35 30 35 31            .byte "50515253545556575859"
000204r 2  35 32 35 33  
000208r 2  35 34 35 35  
000214r 2  36 30 36 31            .byte "60616263646566676869"
000218r 2  36 32 36 33  
00021Cr 2  36 34 36 35  
000228r 2  37 30 37 31            .byte "70717273747576777879"
00022Cr 2  37 32 37 33  
000230r 2  37 34 37 35  
00023Cr 2  38 30 38 31            .byte "80818283848586878889"
000240r 2  38 32 38 33  
000244r 2  38 34 38 35  
000250r 2  39 30 39 31            .byte "90919293949596979899"
000254r 2  39 32 39 33  
000258r 2  39 34 39 35  
000264r 2               
000264r 2               
000264r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000264r 2               ;;
000264r 2               ;;      Convert a decimal number entered at keypad into its
000264r 2               ;;      HEX equivalent and display
000264r 2               ;;
000264r 2               
000264r 2               byte_to_hex:
000264r 2               
000264r 2  20 rr rr       jsr lcd_clear
000267r 2  AD rr rr       lda HEXB + 1
00026Ar 2  29 0F          and #$0f
00026Cr 2  20 rr rr       jsr bintohex
00026Fr 2  AD rr rr       lda HI_DIGIT
000272r 2  20 rr rr       jsr print_char
000275r 2  AD rr rr       lda LO_DIGIT
000278r 2  20 rr rr       jsr print_char
00027Br 2  AD rr rr       lda HEXB
00027Er 2  20 rr rr       jsr bintohex
000281r 2  AD rr rr       lda HI_DIGIT
000284r 2  20 rr rr       jsr print_char
000287r 2  AD rr rr       lda LO_DIGIT
00028Ar 2  20 rr rr       jsr print_char
00028Dr 2  A9 64          lda #'d'
00028Fr 2  20 rr rr       jsr print_char
000292r 2  A9 3D          lda #'='
000294r 2  20 rr rr       jsr print_char
000297r 2  A9 24          lda #'$'
000299r 2  20 rr rr       jsr print_char
00029Cr 2               
00029Cr 2  AD rr rr       lda HEXB ; lo byte
00029Fr 2  48             pha
0002A0r 2  4A             lsr
0002A1r 2  4A             lsr
0002A2r 2  4A             lsr
0002A3r 2  4A             lsr
0002A4r 2  C9 0A          cmp #10
0002A6r 2  10 38          bpl error
0002A8r 2  20 rr rr       jsr mult10
0002ABr 2  8D rr rr       sta TENS
0002AEr 2  68             pla
0002AFr 2  29 0F          and #%00001111 ; UNITS
0002B1r 2  C9 0A          cmp #10
0002B3r 2  10 2C          bpl print_error
0002B5r 2               ;  jsr mult10
0002B5r 2  18             clc
0002B6r 2  6D rr rr       adc TENS
0002B9r 2  8D rr rr       sta HEX
0002BCr 2               
0002BCr 2  AD rr rr       lda HEXB + 1 ; hi byte
0002BFr 2  29 0F          and #%00001111
0002C1r 2  C9 0A          cmp #10
0002C3r 2  10 1C          bpl print_error
0002C5r 2  20 rr rr       jsr mult10
0002C8r 2  20 rr rr       jsr mult10 ; hundreds
0002CBr 2  6D rr rr       adc HEX
0002CEr 2               
0002CEr 2  20 rr rr       jsr bintohex
0002D1r 2  AD rr rr       lda HI_DIGIT
0002D4r 2  20 rr rr       jsr print_char
0002D7r 2  AD rr rr       lda LO_DIGIT
0002DAr 2  20 rr rr       jsr print_char
0002DDr 2  4C rr rr       jmp exit_byte_to_hex
0002E0r 2               
0002E0r 2               error:
0002E0r 2  68             pla
0002E1r 2               print_error:
0002E1r 2  A9 rr          lda #<error_message
0002E3r 2  85 rr          sta MESSAGE_POINTER
0002E5r 2  A9 rr          lda #>error_message
0002E7r 2  85 rr          sta MESSAGE_POINTER + 1
0002E9r 2  20 rr rr       jsr print3
0002ECr 2                 ;jsr lcd_cursor_off
0002ECr 2  60             rts
0002EDr 2               
0002EDr 2               exit_byte_to_hex:
0002EDr 2  20 rr rr       jsr lcd_line_2
0002F0r 2               
0002F0r 2  60             rts
0002F1r 2               
0002F1r 2               
0002F1r 2               
0002F1r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002F1r 2               ;;
0002F1r 2               ;;  (A * 8) + (A * 2) = A * 10
0002F1r 2               
0002F1r 2               mult10:
0002F1r 2  48             pha
0002F2r 2  0A             asl
0002F3r 2  0A             asl
0002F4r 2  0A             asl
0002F5r 2  8D rr rr       sta TEMP2 ; A*8
0002F8r 2  68             pla
0002F9r 2  0A             asl      ; A*2
0002FAr 2  6D rr rr       adc TEMP2 ; A*10
0002FDr 2  60             rts
0002FEr 2               
0002FEr 2               
0002FEr 2               
0002FEr 2               
0002FEr 2               
0002FEr 1               .include "../includes/rtc.inc"
0002FEr 2               
0002FEr 2               
0002FEr 2               
0002FEr 2               
0002FEr 2                 .code
0002FEr 2               
0002FEr 2               
0002FEr 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002FEr 2               ;;
0002FEr 2               ;;                          RTC / Jiffy Tick
0002FEr 2               ;;
0002FEr 2               
0002FEr 2               
0002FEr 2               
0002FEr 2               rtc:
0002FEr 2               
0002FEr 2               
0002FEr 2               ;;  RTC stores ticks at 10ms intervals into a 4-byte (32 bit) value
0002FEr 2               ;;
0002FEr 2               ;;  as each byte rolls over the next one is incremented
0002FEr 2               ;;  on a tick that doesn't roll over the TIME OF DAY
0002FEr 2               ;;  is updated
0002FEr 2               
0002FEr 2  E6 rr          inc TICKS
000300r 2  D0 0A          bne inc_MET
000302r 2  E6 rr          inc TICKS + 1
000304r 2  D0 06          bne inc_MET
000306r 2  E6 rr          inc TICKS + 2
000308r 2  D0 02          bne inc_MET
00030Ar 2  E6 rr          inc TICKS + 3
00030Cr 2               
00030Cr 2               ;;
00030Cr 2               ;;  Every time it's called we increment the "hundredths of a second" byte
00030Cr 2               ;;
00030Cr 2               ;;  When there's been 100 x 10ms (i.e. 1 second) we increment the seconds
00030Cr 2               ;;
00030Cr 2               ;; We keep the times in single digits, SECONDS, TEN_SECONDS, MINUTES,
00030Cr 2               ;; TEN_MINUTES etc.... to make it easy to display
00030Cr 2               ;; The values are stored in RAM as binary values, and need to be converted to
00030Cr 2               ;; ASCII characters when they are displayed on LCD
00030Cr 2               ;;
00030Cr 2               ;;  The bulk of this routine comes from http://wilsonminesco.com/6502interrupts/#2.1
00030Cr 2               ;;
00030Cr 2               inc_MET:
00030Cr 2  E6 rr          inc CENTISEC
00030Er 2  A5 rr          lda CENTISEC
000310r 2  C9 64          cmp #100
000312r 2  30 40          bmi end_MET
000314r 2  64 rr          stz CENTISEC
000316r 2               
000316r 2  E6 rr          inc SECONDS
000318r 2  A5 rr          lda SECONDS
00031Ar 2  C9 0A          cmp #10
00031Cr 2  30 36          bmi end_MET
00031Er 2  64 rr          stz SECONDS
000320r 2  E6 rr          inc TEN_SECONDS
000322r 2               
000322r 2  A5 rr          lda TEN_SECONDS
000324r 2  C9 06          cmp #6
000326r 2  30 2C          bmi end_MET
000328r 2  64 rr          stz TEN_SECONDS
00032Ar 2               
00032Ar 2  E6 rr          inc MINUTES
00032Cr 2  A5 rr          lda MINUTES
00032Er 2  C9 0A          cmp #10
000330r 2  30 22          bmi end_MET
000332r 2  64 rr          stz MINUTES
000334r 2               
000334r 2  E6 rr          inc TEN_MINUTES
000336r 2  A5 rr          lda TEN_MINUTES
000338r 2  C9 06          cmp #6
00033Ar 2  30 18          bmi end_MET
00033Cr 2  64 rr          stz TEN_MINUTES
00033Er 2               
00033Er 2  E6 rr          inc HRS
000340r 2  A5 rr          lda HRS
000342r 2  C9 0A          cmp #10
000344r 2  30 0E          bmi end_MET
000346r 2  64 rr          stz HRS
000348r 2               
000348r 2  E6 rr          inc TEN_HRS
00034Ar 2  A5 rr          lda TEN_HRS
00034Cr 2  C9 0A          cmp #10
00034Er 2  30 04          bmi end_MET
000350r 2  64 rr          stz TEN_HRS
000352r 2               
000352r 2  E6 rr          inc HUNDRED_HRS
000354r 2               
000354r 2               end_MET:
000354r 2  60             rts
000355r 2               
000355r 2               
000355r 1               
000355r 1               
000355r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000355r 1               ;;
000355r 1               ;;         START HERE
000355r 1               ;;
000355r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000355r 1               
000355r 1               .code
000355r 1               
000355r 1               reset:
000355r 1               
000355r 1  A2 FF          ldx #$ff
000357r 1  9A             txs
000358r 1  58             cli      ; interrupts ON
000359r 1  20 rr rr       jsr via_1_init ; set-up VIA_1 for LCD/Keypad
00035Cr 1  20 rr rr       jsr lcd_init ; set-up 4-bit mode
00035Fr 1  20 rr rr       jsr lcd_start ; set-up various features of lcd
000362r 1               
000362r 1               init_variables:
000362r 1               
000362r 1  64 rr          stz TICKS
000364r 1  64 rr          stz TICKS + 1
000366r 1  64 rr          stz TICKS + 2
000368r 1  64 rr          stz TICKS + 3
00036Ar 1  64 rr          stz DUMP_POINTER
00036Cr 1  64 rr          stz DUMP_POINTER + 1
00036Er 1  64 rr          stz MESSAGE_POINTER
000370r 1  64 rr          stz MESSAGE_POINTER + 1
000372r 1  64 rr          stz TOGGLE_TIME
000374r 1  64 rr          stz CLOCK_LAST
000376r 1  64 rr          stz CENTISEC
000378r 1  64 rr          stz FLAGS
00037Ar 1  64 rr          stz SECONDS
00037Cr 1  64 rr          stz TEN_SECONDS
00037Er 1  64 rr          stz MINUTES
000380r 1  64 rr          stz HRS
000382r 1  64 rr          stz TEN_HRS
000384r 1  64 rr          stz TEN_MINUTES
000386r 1  64 rr          stz HUNDRED_HRS
000388r 1  9C rr rr       stz TEMP
00038Br 1  9C rr rr       stz TEMP2
00038Er 1  9C rr rr       stz TENS
000391r 1  64 rr          stz MEM_POINTER
000393r 1  64 rr          stz MEM_POINTER + 1
000395r 1  9C rr rr       stz HI_DIGIT
000398r 1  9C rr rr       stz LO_DIGIT
00039Br 1               
00039Br 1               memory_test:
00039Br 1               
00039Br 1  A9 rr          lda #<mem_start_msg
00039Dr 1  85 rr          sta MESSAGE_POINTER
00039Fr 1  A9 rr          lda #>mem_start_msg
0003A1r 1  85 rr          sta MESSAGE_POINTER + 1
0003A3r 1  20 rr rr       jsr print2
0003A6r 1               
0003A6r 1               ;; test then clear RAM between
0003A6r 1               ;; $0200 - $3FFF - avoids the ZP and STACK areas
0003A6r 1               
0003A6r 1  A9 02          lda #$02            ; start at $0200
0003A8r 1  85 rr          sta MEM_POINTER + 1
0003AAr 1  A0 00          ldy #$00
0003ACr 1               loop_ram:
0003ACr 1  A9 AA          lda #$AA              ; test with 10101010
0003AEr 1  91 rr          sta (MEM_POINTER),y   ; write test value to RAM
0003B0r 1  A9 FF          lda #$FF              ; remove test value from A
0003B2r 1  B1 rr          lda (MEM_POINTER),y   ; read RAM contents into A
0003B4r 1  C9 AA          cmp #$AA              ; compare to expected value
0003B6r 1  D0 33          bne mem_fail_1
0003B8r 1  A9 55          lda #$55              ; repeat test with 01010101
0003BAr 1  91 rr          sta (MEM_POINTER),y
0003BCr 1  A9 FF          lda #$FF
0003BEr 1  B1 rr          lda (MEM_POINTER),y
0003C0r 1  C9 55          cmp #$55
0003C2r 1  D0 35          bne mem_fail_2
0003C4r 1  A9 00          lda #$00              ; clear RAM to all zeros
0003C6r 1  91 rr          sta (MEM_POINTER),y
0003C8r 1  C8             iny
0003C9r 1  F0 03          beq next_page
0003CBr 1  4C rr rr       jmp loop_ram
0003CEr 1               next_page:
0003CEr 1  A5 rr          lda MEM_POINTER + 1
0003D0r 1  1A             inc
0003D1r 1  C9 40          cmp #$40
0003D3r 1  F0 05          beq done_ram
0003D5r 1  85 rr          sta MEM_POINTER + 1
0003D7r 1  4C rr rr       jmp loop_ram
0003DAr 1               
0003DAr 1               done_ram:
0003DAr 1               
0003DAr 1  A9 rr          lda #<mem_pass_msg
0003DCr 1  85 rr          sta MESSAGE_POINTER
0003DEr 1  A9 rr          lda #>mem_pass_msg
0003E0r 1  85 rr          sta MESSAGE_POINTER + 1
0003E2r 1  20 rr rr       jsr lcd_clear
0003E5r 1  20 rr rr       jsr print4
0003E8r 1                 ;smb5 FLAGS
0003E8r 1  4C rr rr       jmp loop
0003EBr 1               
0003EBr 1               mem_fail_1:
0003EBr 1               
0003EBr 1  A9 rr          lda #<mem_fail_msg_1
0003EDr 1  85 rr          sta MESSAGE_POINTER
0003EFr 1  A9 rr          lda #>mem_fail_msg_1
0003F1r 1  85 rr          sta MESSAGE_POINTER + 1
0003F3r 1  20 rr rr       jsr print3
0003F6r 1  4C rr rr       jmp loop
0003F9r 1               
0003F9r 1               mem_fail_2:
0003F9r 1               
0003F9r 1  A9 rr          lda #<mem_fail_msg_2
0003FBr 1  85 rr          sta MESSAGE_POINTER
0003FDr 1  A9 rr          lda #>mem_fail_msg_2
0003FFr 1  85 rr          sta MESSAGE_POINTER + 1
000401r 1  20 rr rr       jsr print3
000404r 1  4C rr rr       jmp loop
000407r 1               
000407r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000407r 1               ;;
000407r 1               ;;                 Main Loop
000407r 1               ;;
000407r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000407r 1               
000407r 1               loop:
000407r 1               
000407r 1  CB             wai
000408r 1  20 rr rr       jsr check_flags
00040Br 1  4C rr rr       jmp loop
00040Er 1               
00040Er 1               
00040Er 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00040Er 1               ;;
00040Er 1               ;;                  FUNCTIONS
00040Er 1               ;;
00040Er 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00040Er 1               
00040Er 1               check_flags:
00040Er 1               
00040Er 1  8F rr 04       bbs0 FLAGS, update_block_address
000411r 1  DF rr 15       bbs5 FLAGS, clock_time
000414r 1                 ; check other flags... other actions....
000414r 1  60             rts
000415r 1               
000415r 1               update_block_address:
000415r 1  20 rr rr       jsr lcd_line_2
000418r 1  38             sec
000419r 1  A5 rr          lda TICKS
00041Br 1  E5 rr          sbc TOGGLE_TIME
00041Dr 1  C9 32          cmp #$32
00041Fr 1  90 07          bcc @exit
000421r 1  20 rr rr       jsr block_address
000424r 1  A5 rr          lda TICKS
000426r 1  85 rr          sta TOGGLE_TIME
000428r 1               @exit:
000428r 1  60             rts
000429r 1               
000429r 1               clock_time:
000429r 1  38             sec
00042Ar 1  A5 rr          lda TICKS
00042Cr 1  E5 rr          sbc CLOCK_LAST
00042Er 1  C9 32          cmp #$32
000430r 1  90 3C          bcc @exit
000432r 1  20 rr rr       jsr lcd_cursor_off
000435r 1  20 rr rr       jsr lcd_line_3
000438r 1  A5 rr          lda HUNDRED_HRS
00043Ar 1  20 rr rr       jsr bintoascii
00043Dr 1  A5 rr          lda TEN_HRS
00043Fr 1  20 rr rr       jsr bintoascii
000442r 1  A5 rr          lda HRS
000444r 1  20 rr rr       jsr bintoascii
000447r 1  A9 3A          lda #':'
000449r 1  20 rr rr       jsr print_char
00044Cr 1  A5 rr          lda TEN_MINUTES
00044Er 1  20 rr rr       jsr bintoascii
000451r 1  A5 rr          lda MINUTES
000453r 1  20 rr rr       jsr bintoascii
000456r 1  A9 3A          lda #':'
000458r 1  20 rr rr       jsr print_char
00045Br 1  A5 rr          lda TEN_SECONDS
00045Dr 1  20 rr rr       jsr bintoascii
000460r 1  A5 rr          lda SECONDS
000462r 1  20 rr rr       jsr bintoascii
000465r 1  A9 20          lda #' '
000467r 1  20 rr rr       jsr print_char
00046Ar 1  A5 rr          lda TICKS
00046Cr 1  85 rr          sta CLOCK_LAST
00046Er 1               @exit:
00046Er 1  60             rts
00046Fr 1               
00046Fr 1               
00046Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00046Fr 1               ;;
00046Fr 1               ;;      update screen when new memory location is selected
00046Fr 1               ;;
00046Fr 1               ;;
00046Fr 1               new_address:
00046Fr 1  20 rr rr       jsr lcd_clear
000472r 1  20 rr rr       jsr lcd_cursor_on
000475r 1  A9 rr          lda #<title
000477r 1  85 rr          sta MESSAGE_POINTER
000479r 1  A9 rr          lda #>title
00047Br 1  85 rr          sta MESSAGE_POINTER + 1
00047Dr 1  20 rr rr       jsr print1
000480r 1  20 rr rr       jsr lcd_line_2
000483r 1               print_address:
000483r 1  A9 24          lda #'$'
000485r 1  20 rr rr       jsr print_char
000488r 1  A5 rr          lda DUMP_POINTER + 1
00048Ar 1  20 rr rr       jsr bintohex
00048Dr 1  AD rr rr       lda HI_DIGIT
000490r 1  20 rr rr       jsr print_char
000493r 1  AD rr rr       lda LO_DIGIT
000496r 1  20 rr rr       jsr print_char
000499r 1  A5 rr          lda DUMP_POINTER
00049Br 1  20 rr rr       jsr bintohex
00049Er 1  AD rr rr       lda HI_DIGIT
0004A1r 1  20 rr rr       jsr print_char
0004A4r 1  AD rr rr       lda LO_DIGIT
0004A7r 1  20 rr rr       jsr print_char
0004AAr 1  A9 20          lda #' '
0004ACr 1  20 rr rr       jsr print_char
0004AFr 1  A0 00          ldy #$00
0004B1r 1  B1 rr          lda (DUMP_POINTER),y
0004B3r 1  20 rr rr       jsr bintohex
0004B6r 1  AD rr rr       lda HI_DIGIT
0004B9r 1  20 rr rr       jsr print_char
0004BCr 1  AD rr rr       lda LO_DIGIT
0004BFr 1  20 rr rr       jsr print_char
0004C2r 1  A9 20          lda #' '
0004C4r 1  20 rr rr       jsr print_char
0004C7r 1  B1 rr          lda (DUMP_POINTER),y
0004C9r 1  20 rr rr       jsr print_char
0004CCr 1  A9 rr          lda #<splash
0004CEr 1  85 rr          sta MESSAGE_POINTER
0004D0r 1  A9 rr          lda #>splash
0004D2r 1  85 rr          sta MESSAGE_POINTER + 1
0004D4r 1  20 rr rr       jsr print3   ; add second line (cursor) after re-writing the top line
0004D7r 1  60             rts
0004D8r 1               
0004D8r 1               
0004D8r 1               
0004D8r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004D8r 1               ;;
0004D8r 1               ;;      display 8 bytes of data for a "block" of memory
0004D8r 1               ;;
0004D8r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004D8r 1               
0004D8r 1               block_address:
0004D8r 1               
0004D8r 1  20 rr rr       jsr lcd_clear
0004DBr 1  20 rr rr       jsr lcd_line_2
0004DEr 1  A0 00          ldy #$00
0004E0r 1  A9 24          lda #'$'
0004E2r 1  20 rr rr       jsr print_char
0004E5r 1  A5 rr          lda DUMP_POINTER + 1
0004E7r 1  20 rr rr       jsr bintohex
0004EAr 1  AD rr rr       lda HI_DIGIT
0004EDr 1  20 rr rr       jsr print_char
0004F0r 1  AD rr rr       lda LO_DIGIT
0004F3r 1  20 rr rr       jsr print_char
0004F6r 1  A5 rr          lda DUMP_POINTER
0004F8r 1  20 rr rr       jsr bintohex
0004FBr 1  AD rr rr       lda HI_DIGIT
0004FEr 1  20 rr rr       jsr print_char
000501r 1  AD rr rr       lda LO_DIGIT
000504r 1  20 rr rr       jsr print_char
000507r 1  20 rr rr       jsr lcd_line_3
00050Ar 1               loop1:
00050Ar 1  B1 rr          lda (DUMP_POINTER),y
00050Cr 1  20 rr rr       jsr bintohex
00050Fr 1  AD rr rr       lda HI_DIGIT
000512r 1  20 rr rr       jsr print_char
000515r 1  AD rr rr       lda LO_DIGIT
000518r 1  20 rr rr       jsr print_char
00051Br 1  B1 rr          lda (DUMP_POINTER),y
00051Dr 1  C8             iny
00051Er 1  C0 08          cpy #$08
000520r 1  D0 E8          bne loop1
000522r 1  20 rr rr       jsr lcd_line_4
000525r 1               loop2:
000525r 1  B1 rr          lda (DUMP_POINTER),y
000527r 1  20 rr rr       jsr bintohex
00052Ar 1  AD rr rr       lda HI_DIGIT
00052Dr 1  20 rr rr       jsr print_char
000530r 1  AD rr rr       lda LO_DIGIT
000533r 1  20 rr rr       jsr print_char
000536r 1  B1 rr          lda (DUMP_POINTER),y
000538r 1  C8             iny
000539r 1  C0 10          cpy #$10
00053Br 1  D0 E8          bne loop2
00053Dr 1  60             rts
00053Er 1               
00053Er 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00053Er 1               ;;
00053Er 1               ;;            print on line 1 or line 2
00053Er 1               ;;
00053Er 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00053Er 1               
00053Er 1               
00053Er 1               
00053Er 1               print1:
00053Er 1  20 rr rr       jsr lcd_line_1
000541r 1  A0 00          ldy #0
000543r 1  4C rr rr       jmp line
000546r 1               print2:
000546r 1  20 rr rr       jsr lcd_line_2
000549r 1  A0 00          ldy #0
00054Br 1  4C rr rr       jmp line
00054Er 1               print3:
00054Er 1  20 rr rr       jsr lcd_line_3
000551r 1  A0 00          ldy #0
000553r 1  4C rr rr       jmp line
000556r 1               print4:
000556r 1  20 rr rr       jsr lcd_line_4
000559r 1  A0 00          ldy #0
00055Br 1  4C rr rr       jmp line
00055Er 1               
00055Er 1               line:
00055Er 1  B1 rr          lda (MESSAGE_POINTER),y
000560r 1  F0 07          beq @exit
000562r 1  20 rr rr       jsr print_char
000565r 1  C8             iny
000566r 1  4C rr rr       jmp line
000569r 1               @exit:
000569r 1  60             rts
00056Ar 1               
00056Ar 1               
00056Ar 1               
00056Ar 1               
00056Ar 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00056Ar 1               ;;
00056Ar 1               ;;      Monitor function - decrement the selected address
00056Ar 1               ;;
00056Ar 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00056Ar 1               
00056Ar 1               decrement_address:
00056Ar 1               
00056Ar 1  38             sec
00056Br 1  A5 rr          lda DUMP_POINTER
00056Dr 1  E9 01          sbc #$01
00056Fr 1  85 rr          sta DUMP_POINTER
000571r 1  8D rr rr       sta BYTE
000574r 1  A5 rr          lda DUMP_POINTER + 1
000576r 1  E9 00          sbc #$00
000578r 1  85 rr          sta DUMP_POINTER + 1
00057Ar 1  8D rr rr       sta BYTE + 1
00057Dr 1  60             rts
00057Er 1               
00057Er 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00057Er 1               ;;
00057Er 1               ;;      Monitor function - increment the selected address
00057Er 1               ;;
00057Er 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00057Er 1               
00057Er 1               increment_address:
00057Er 1               
00057Er 1  18             clc
00057Fr 1  A5 rr          lda DUMP_POINTER
000581r 1  69 01          adc #$01
000583r 1  85 rr          sta DUMP_POINTER
000585r 1  8D rr rr       sta BYTE
000588r 1  A5 rr          lda DUMP_POINTER + 1
00058Ar 1  69 00          adc #$00
00058Cr 1  85 rr          sta DUMP_POINTER + 1
00058Er 1  8D rr rr       sta BYTE + 1
000591r 1  60             rts
000592r 1               
000592r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000592r 1               ;;
000592r 1               ;;      Monitor function - increment the selected block of  addresses by 8
000592r 1               ;;
000592r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000592r 1               
000592r 1               increment_block:
000592r 1               
000592r 1  18             clc
000593r 1  A5 rr          lda DUMP_POINTER
000595r 1  69 10          adc #$10
000597r 1  85 rr          sta DUMP_POINTER
000599r 1  8D rr rr       sta BYTE
00059Cr 1  A5 rr          lda DUMP_POINTER + 1
00059Er 1  69 00          adc #$00
0005A0r 1  85 rr          sta DUMP_POINTER + 1
0005A2r 1  8D rr rr       sta BYTE + 1
0005A5r 1  60             rts
0005A6r 1               
0005A6r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005A6r 1               ;;
0005A6r 1               ;;      Monitor function - decrement the selected block of  addresses by 8
0005A6r 1               ;;
0005A6r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005A6r 1               
0005A6r 1               decrement_block:
0005A6r 1               
0005A6r 1  38             sec
0005A7r 1  A5 rr          lda DUMP_POINTER
0005A9r 1  E9 10          sbc #$10
0005ABr 1  85 rr          sta DUMP_POINTER
0005ADr 1  8D rr rr       sta BYTE
0005B0r 1  A5 rr          lda DUMP_POINTER + 1
0005B2r 1  E9 00          sbc #$00
0005B4r 1  85 rr          sta DUMP_POINTER + 1
0005B6r 1  8D rr rr       sta BYTE + 1
0005B9r 1  60             rts
0005BAr 1               
0005BAr 1               
0005BAr 1               
0005BAr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005BAr 1               ;;
0005BAr 1               ;; use last 4 key presses (as hex bytes) to fill two BYTES
0005BAr 1               ;;
0005BAr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005BAr 1               
0005BAr 1               keys_byte:
0005BAr 1               
0005BAr 1  AD rr rr       lda KEY_PRESS + 1
0005BDr 1  0A             asl
0005BEr 1  0A             asl
0005BFr 1  0A             asl
0005C0r 1  0A             asl
0005C1r 1  8D rr rr       sta BYTE
0005C4r 1  AD rr rr       lda KEY_PRESS
0005C7r 1  0D rr rr       ora BYTE
0005CAr 1  8D rr rr       sta BYTE
0005CDr 1  AD rr rr       lda KEY_PRESS + 3
0005D0r 1  0A             asl
0005D1r 1  0A             asl
0005D2r 1  0A             asl
0005D3r 1  0A             asl
0005D4r 1  8D rr rr       sta BYTE + 1
0005D7r 1  AD rr rr       lda KEY_PRESS + 2
0005DAr 1  0D rr rr       ora BYTE + 1
0005DDr 1  8D rr rr       sta BYTE + 1
0005E0r 1  60             rts
0005E1r 1               
0005E1r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005E1r 1               ;;
0005E1r 1               ;;    toggle the display/update of Clock on each appropriate keypress
0005E1r 1               ;;
0005E1r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005E1r 1               
0005E1r 1               show_clock:
0005E1r 1               
0005E1r 1  DF rr 05       bbs5 FLAGS, reset_bit5
0005E4r 1  D7 rr          smb5 FLAGS
0005E6r 1  4C rr rr       jmp exit_show_clock
0005E9r 1               reset_bit5:
0005E9r 1  57 rr          rmb5 FLAGS
0005EBr 1               exit_show_clock:
0005EBr 1  60             rts
0005ECr 1               
0005ECr 1               
0005ECr 1               
0005ECr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005ECr 1               ;;
0005ECr 1               ;;    toggle the automatic update view of the "8-byte memory block"
0005ECr 1               ;;
0005ECr 1               
0005ECr 1               show_block:
0005ECr 1               
0005ECr 1  8F rr 05       bbs0 FLAGS, reset_bit0
0005EFr 1  87 rr          smb0 FLAGS
0005F1r 1  4C rr rr       jmp exit_show_block
0005F4r 1               reset_bit0:
0005F4r 1  07 rr          rmb0 FLAGS
0005F6r 1               exit_show_block:
0005F6r 1  60             rts
0005F7r 1               
0005F7r 1               
0005F7r 1               
0005F7r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005F7r 1               ;;
0005F7r 1               ;;                     INTERRUPT HANDLERS
0005F7r 1               ;;
0005F7r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005F7r 1               
0005F7r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005F7r 1               ;;
0005F7r 1               ;;                 CB1 : reset & restart timer
0005F7r 1               ;;
0005F7r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005F7r 1               
0005F7r 1               cb1_handler:
0005F7r 1               
0005F7r 1  64 rr          stz HUNDRED_HRS
0005F9r 1  64 rr          stz TEN_HRS
0005FBr 1  64 rr          stz TEN_MINUTES
0005FDr 1  64 rr          stz TEN_SECONDS
0005FFr 1  64 rr          stz HRS
000601r 1  64 rr          stz MINUTES
000603r 1  64 rr          stz SECONDS
000605r 1  60             rts
000606r 1               
000606r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000606r 1               ;;
000606r 1               ;;                CB2 : lap-time pause timer
000606r 1               ;;
000606r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000606r 1               
000606r 1               cb2_handler:
000606r 1               
000606r 1  20 rr rr       jsr show_clock
000609r 1  60             rts
00060Ar 1               
00060Ar 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00060Ar 1               ;;
00060Ar 1               ;;                    MONITOR / KEYPAD
00060Ar 1               ;;
00060Ar 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00060Ar 1               
00060Ar 1               keypad_handler:
00060Ar 1               
00060Ar 1  20 rr rr       jsr get_key     ; READs from PORTA which also re-sets VIA's Interrupt flag
00060Dr 1  8D rr rr       sta INKEY       ; put the byte value of input into RAM ( $00 )
000610r 1  AD 00 60       lda PORTB_1       ; check for SHIFT/INSTRUCTION button
000613r 1  29 80          and #%10000000
000615r 1  F0 03          beq check_keypress ; done this way to get around the limit in size of branch jumps....
000617r 1  4C rr rr       jmp handle_new_char
00061Ar 1               
00061Ar 1               check_keypress:
00061Ar 1               
00061Ar 1  AD rr rr       lda INKEY
00061Dr 1  20 rr rr       jsr bintohex  ; convert BYTE value of keypress to its ASCII HEX equivalent "0" -> "A"
000620r 1               
000620r 1               ; choose action of "SHIFTed" key-press
000620r 1               
000620r 1               check_a:
000620r 1               
000620r 1  C9 41          cmp #'A'
000622r 1                 ; move up one memory address and display contents
000622r 1  D0 09          bne check_b
000624r 1  20 rr rr       jsr increment_address
000627r 1  20 rr rr       jsr new_address
00062Ar 1  4C rr rr       jmp exit_key_irq
00062Dr 1               
00062Dr 1               check_b:
00062Dr 1               
00062Dr 1  C9 42          cmp #'B'
00062Fr 1                 ; move down one memory address and display contents
00062Fr 1  D0 09          bne check_c
000631r 1  20 rr rr       jsr decrement_address
000634r 1  20 rr rr       jsr new_address
000637r 1  4C rr rr       jmp exit_key_irq
00063Ar 1               
00063Ar 1               check_c:
00063Ar 1               
00063Ar 1  C9 43          cmp #'C'
00063Cr 1                 ; return to MONITOR
00063Cr 1  D0 13          bne check_d
00063Er 1  57 rr          rmb5 FLAGS
000640r 1  20 rr rr       jsr lcd_clear
000643r 1  A9 rr          lda #<splash
000645r 1  85 rr          sta MESSAGE_POINTER
000647r 1  A9 rr          lda #>splash
000649r 1  85 rr          sta MESSAGE_POINTER + 1
00064Br 1  20 rr rr       jsr new_address
00064Er 1  4C rr rr       jmp exit_key_irq
000651r 1               
000651r 1               check_d:
000651r 1               
000651r 1  C9 44          cmp #'D'
000653r 1                 ; move monitor to entered 4-digit memory address
000653r 1  D0 10          bne check_e
000655r 1  AD rr rr       lda BYTE
000658r 1  85 rr          sta DUMP_POINTER
00065Ar 1  AD rr rr       lda BYTE + 1
00065Dr 1  85 rr          sta DUMP_POINTER + 1
00065Fr 1  20 rr rr       jsr new_address
000662r 1                 ;jsr print2
000662r 1  4C rr rr       jmp exit_key_irq
000665r 1               
000665r 1               check_e:
000665r 1               
000665r 1  C9 45          cmp #'E'
000667r 1                 ; insert (POKE) byte of data in to current memory address, then increment to next address
000667r 1  D0 10          bne check_f
000669r 1  AD rr rr       lda BYTE
00066Cr 1  A0 00          ldy #$00
00066Er 1  91 rr          sta (DUMP_POINTER),y
000670r 1  20 rr rr       jsr increment_address
000673r 1  20 rr rr       jsr new_address
000676r 1                 ;jsr print2
000676r 1  4C rr rr       jmp exit_key_irq
000679r 1               
000679r 1               check_f:
000679r 1               
000679r 1  C9 46          cmp #'F'
00067Br 1                 ; show 8-byte wide block of memory
00067Br 1  D0 12          bne check_1
00067Dr 1  A0 00          ldy #$00
00067Fr 1  AD rr rr       lda BYTE
000682r 1  85 rr          sta DUMP_POINTER
000684r 1  AD rr rr       lda BYTE + 1
000687r 1  85 rr          sta DUMP_POINTER + 1
000689r 1  20 rr rr       jsr block_address
00068Cr 1  4C rr rr       jmp exit_key_irq
00068Fr 1               
00068Fr 1               check_1:
00068Fr 1               
00068Fr 1  C9 31          cmp #'1'
000691r 1                 ; show/auto-update clock
000691r 1  D0 13          bne check_3
000693r 1  20 rr rr       jsr lcd_clear
000696r 1  A9 rr          lda #<emt
000698r 1  85 rr          sta MESSAGE_POINTER
00069Ar 1  A9 rr          lda #>emt
00069Cr 1  85 rr          sta MESSAGE_POINTER + 1
00069Er 1  20 rr rr       jsr print4
0006A1r 1  D7 rr          smb5 FLAGS
0006A3r 1  4C rr rr       jmp exit_key_irq
0006A6r 1               
0006A6r 1               check_3:
0006A6r 1               
0006A6r 1  C9 33          cmp #'3'
0006A8r 1  D0 0B          bne check_6
0006AAr 1  A0 00          ldy #$00
0006ACr 1  20 rr rr       jsr increment_block
0006AFr 1  20 rr rr       jsr block_address
0006B2r 1  4C rr rr       jmp exit_key_irq
0006B5r 1               
0006B5r 1               check_6:
0006B5r 1               
0006B5r 1  C9 36          cmp #'6'
0006B7r 1  D0 0B          bne check_9
0006B9r 1  A0 00          ldy #$00
0006BBr 1  20 rr rr       jsr decrement_block
0006BEr 1  20 rr rr       jsr block_address
0006C1r 1  4C rr rr       jmp exit_key_irq
0006C4r 1               
0006C4r 1               check_9:
0006C4r 1               
0006C4r 1  C9 39          cmp #'9'
0006C6r 1  D0 06          bne check_4
0006C8r 1  20 rr rr       jsr show_block
0006CBr 1  4C rr rr       jmp exit_key_irq
0006CEr 1               
0006CEr 1               check_4:
0006CEr 1               
0006CEr 1  C9 34          cmp #'4'
0006D0r 1  D0 12          bne check_5
0006D2r 1  AD rr rr       lda BYTE
0006D5r 1  8D rr rr       sta HEXB
0006D8r 1  AD rr rr       lda BYTE + 1
0006DBr 1  8D rr rr       sta HEXB + 1
0006DEr 1  20 rr rr       jsr byte_to_hex
0006E1r 1  4C rr rr       jmp exit_key_irq
0006E4r 1               
0006E4r 1               check_5:
0006E4r 1               
0006E4r 1  C9 35          cmp #'5'
0006E6r 1  D0 27          bne exit_key_irq
0006E8r 1  20 00 3F       jsr $3F00
0006EBr 1  4C rr rr       jmp exit_key_irq
0006EEr 1               
0006EEr 1               
0006EEr 1               handle_new_char:
0006EEr 1               
0006EEr 1  AD rr rr       lda KEY_PRESS + 2
0006F1r 1  8D rr rr       sta KEY_PRESS + 3
0006F4r 1  AD rr rr       lda KEY_PRESS + 1
0006F7r 1  8D rr rr       sta KEY_PRESS + 2
0006FAr 1  AD rr rr       lda KEY_PRESS
0006FDr 1  8D rr rr       sta KEY_PRESS + 1
000700r 1  AD rr rr       lda INKEY       ; get the new keypress value and...
000703r 1  8D rr rr       sta KEY_PRESS
000706r 1  20 rr rr       jsr bintohex
000709r 1  20 rr rr       jsr print_char  ; and print it on LCD
00070Cr 1  20 rr rr       jsr keys_byte
00070Fr 1               
00070Fr 1               exit_key_irq:
00070Fr 1               
00070Fr 1  20 rr rr       jsr scan  ; re-enable keypad
000712r 1  60             rts
000713r 1               
000713r 1               
000713r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000713r 1               
000713r 1               nmi:
000713r 1               
000713r 1  40             rti
000714r 1               
000714r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000714r 1               ;;
000714r 1               ;;    interrupt is triggered by HIGH edge on VIA CA1 pin
000714r 1               ;;     PORTA low nibble (keypad columns) inputs are diode ORed to CA1
000714r 1               ;;
000714r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000714r 1               
000714r 1               irq:
000714r 1               
000714r 1               ; put registers on the stack while handling the IRQ
000714r 1  48             pha
000715r 1  DA             phx
000716r 1  5A             phy
000717r 1               
000717r 1               ;  find responsible hardware
000717r 1               
000717r 1               ;  Is it VIA_1?
000717r 1               
000717r 1  AD 0D 60       lda IFR_1   ; if IFR_1 has Bit7 set (ie sign=NEGATIVE) then it IS the source of the interrupt
00071Ar 1  10 30          bpl next_device ; if it's not set (ie sign=POSITIVE) then branch to test the next possible device
00071Cr 1               
00071Cr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00071Cr 1               ;;
00071Cr 1               ;; IFR Flags
00071Cr 1               ;; B7  B6  B5  B4  B3  B2  B1  B0
00071Cr 1               ;; IRQ TI1 TI2 CB1 CB2 SR CA1 CA2
00071Cr 1               ;;
00071Cr 1               ;; Interrupt source is found by sequentially shifting IFR bit left to put bit-of-interest into the CARRY place
00071Cr 1               ;; and then branching based on whether CARRY is SET or not
00071Cr 1               ;;
00071Cr 1               ;; Only add tests for IRQ sources in use, and adjust the ASLs in each test as necessary
00071Cr 1               ;;
00071Cr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00071Cr 1               
00071Cr 1               test_timer1:
00071Cr 1               
00071Cr 1  0A             asl           ; shift IFR left twice puts the TI1 bit into CARRY....
00071Dr 1  0A             asl
00071Er 1  90 09          bcc test_cb1  ; carry clear = next test
000720r 1  2C 04 60       bit T1CL_1      ; clear not clear = handle the TIMER interrupt
000723r 1  20 rr rr       jsr rtc
000726r 1  4C rr rr       jmp exit_irq
000729r 1               
000729r 1               test_cb1:
000729r 1               
000729r 1  0A             asl
00072Ar 1  0A             asl
00072Br 1  90 09          bcc test_cb2
00072Dr 1  2C 00 60       bit PORTB_1
000730r 1  20 rr rr       jsr cb1_handler
000733r 1  4C rr rr       jmp exit_irq
000736r 1               
000736r 1               test_cb2:
000736r 1               
000736r 1  0A             asl
000737r 1  90 09          bcc test_ca1
000739r 1  2C 00 60       bit PORTB_1
00073Cr 1  20 rr rr       jsr cb2_handler
00073Fr 1  4C rr rr       jmp exit_irq
000742r 1               
000742r 1               test_ca1:
000742r 1               
000742r 1  0A             asl           ; shift CA1 bit into the CARRY bit & test
000743r 1  0A             asl
000744r 1  90 06          bcc exit_irq        ; carry clear = leave
000746r 1  20 rr rr       jsr keypad_handler  ; carry not clear = handle the CA1 interrupt (keypad)
000749r 1  4C rr rr       jmp exit_irq
00074Cr 1               
00074Cr 1               
00074Cr 1               next_device:
00074Cr 1               
00074Cr 1               exit_irq:
00074Cr 1               
00074Cr 1  7A             ply
00074Dr 1  FA             plx
00074Er 1  68             pla
00074Fr 1  40             rti
000750r 1               
000750r 1  2E 2E 2E 53  title: .asciiz "...Shed Brain v1..."
000754r 1  68 65 64 20  
000758r 1  42 72 61 69  
000764r 1  53 68 65 64  emt: .asciiz "Shed Time  MET"
000768r 1  20 54 69 6D  
00076Cr 1  65 20 20 4D  
000773r 1  73 68 65 64  splash: .asciiz "shed> "
000777r 1  3E 20 00     
00077Ar 1  4E 6F 74 20  error_message: .asciiz "Not Decimal"
00077Er 1  44 65 63 69  
000782r 1  6D 61 6C 00  
000786r 1  42 65 67 69  mem_start_msg: .asciiz "Begin RAM Test"
00078Ar 1  6E 20 52 41  
00078Er 1  4D 20 54 65  
000795r 1  52 41 4D 20  mem_pass_msg: .asciiz "RAM Test Pass"
000799r 1  54 65 73 74  
00079Dr 1  20 50 61 73  
0007A3r 1  52 41 4D 20  mem_fail_msg_1: .asciiz "RAM Test 1 Fail"
0007A7r 1  54 65 73 74  
0007ABr 1  20 31 20 46  
0007B3r 1  52 41 4D 20  mem_fail_msg_2: .asciiz "RAM Test 2 Fail"
0007B7r 1  54 65 73 74  
0007BBr 1  20 32 20 46  
0007C3r 1               
0007C3r 1               ; Reset/IRQ vectors
0007C3r 1               
0007C3r 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr          .word nmi
000002r 1  rr rr          .word reset
000004r 1  rr rr          .word irq
000004r 1               
