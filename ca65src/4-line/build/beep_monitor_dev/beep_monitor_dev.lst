ca65 V2.18 - Debian 2.19-1
Main file   : beep_monitor_dev.s
Current file: beep_monitor_dev.s

000000r 1               ;;
000000r 1               ;; DEV updates:
000000r 1               ;;
000000r 1               ;;1) pre-load USER MEM @ user_ram
000000r 1               ;;
000000r 1               ;;2) set new VIAs for OUTPUT on both ports A & B
000000r 1               ;;
000000r 1               ;;3) TESTING new VIAS with flashing LEDs on all ports
000000r 1               ;;
000000r 1               ;;4) Add second LCD on VIA_2 PORTA_2 ?
000000r 1               ;;
000000r 1               ;;5) BEEP using VIA2 T1 on PORTB_2 bit 7
000000r 1               ;;
000000r 1               
000000r 1               .zeropage
000000r 1               
000000r 1  xx xx        BEEP_POINTER:     .res 2
000002r 1  xx xx        DUMP_POINTER:     .res 2
000004r 1  xx           FLAGS:            .res 1
000005r 1  xx           TOGGLE_TIME:      .res 1
000006r 1  xx           CLOCK_LAST:       .res 1
000007r 1  xx xx        MESSAGE_POINTER:  .res 2
000009r 1  xx xx xx xx  TICKS:            .res 4
00000Dr 1  xx           CENTISEC:         .res 1
00000Er 1  xx           HUNDRED_HRS:      .res 1
00000Fr 1  xx           TEN_HRS:          .res 1
000010r 1  xx           HRS:              .res 1
000011r 1  xx           TEN_MINUTES:      .res 1
000012r 1  xx           MINUTES:          .res 1
000013r 1  xx           TEN_SECONDS:      .res 1
000014r 1  xx           SECONDS:          .res 1
000015r 1  xx xx        MEM_POINTER:      .res 2
000017r 1  xx           LED2_LAST:        .res 1
000018r 1  xx           LED3_LAST:        .res 1
000019r 1  xx           LAST_KIT:         .res 1
00001Ar 1               
00001Ar 1               
00001Ar 1               .bss
000000r 1               
000000r 1  xx           INKEY:            .res 1
000001r 1  xx xx xx xx  KEY_PRESS:        .res 4
000005r 1  xx xx        BYTE:             .res 2
000007r 1  xx           TENS:             .res 1
000008r 1  xx           HUNDREDS:         .res 1
000009r 1  xx xx        HEX:              .res 2
00000Br 1  xx xx        HEXB:             .res 2
00000Dr 1  xx           TEMP:             .res 1
00000Er 1  xx           TEMP2:            .res 1
00000Fr 1  xx           HI_DIGIT:         .res 1
000010r 1  xx           LO_DIGIT:         .res 1
000011r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000011r 1               ;;
000011r 1               ;;        INCLUDES
000011r 1               ;;
000011r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000011r 1               
000011r 1               
000011r 1               .include "../includes/ioports.inc"
000011r 2               
000011r 2                 .code
000000r 2               
000000r 2               ; VIA_1 Port addresses
000000r 2               VIA_1     = $6000
000000r 2               PORTB_1   = VIA_1
000000r 2               PORTA_1   = VIA_1 + 1
000000r 2               DDRB_1    = VIA_1 + 2
000000r 2               DDRA_1    = VIA_1 + 3
000000r 2               T1CL_1    = VIA_1 + 4
000000r 2               T1CH_1    = VIA_1 + 5
000000r 2               T1LL_1    = VIA_1 + 6
000000r 2               T1LH_1    = VIA_1 + 7
000000r 2               T2CL_1    = VIA_1 + 8
000000r 2               T2CH_1    = VIA_1 + 9
000000r 2               SR_1      = VIA_1 + 10
000000r 2               ACR_1     = VIA_1 + 11
000000r 2               PCR_1     = VIA_1 + 12
000000r 2               IFR_1     = VIA_1 + 13
000000r 2               IER_1     = VIA_1 + 14
000000r 2               PORTA_NO_HS_1 = VIA_1 + 15
000000r 2               
000000r 2               ; VIA_2 Port addresses
000000r 2               VIA_2     = $5000
000000r 2               PORTB_2   = VIA_2
000000r 2               PORTA_2   = VIA_2 + 1
000000r 2               DDRB_2    = VIA_2 + 2
000000r 2               DDRA_2    = VIA_2 + 3
000000r 2               T1CL_2    = VIA_2 + 4
000000r 2               T1CH_2    = VIA_2 + 5
000000r 2               T1LL_2    = VIA_2 + 6
000000r 2               T1LH_2    = VIA_2 + 7
000000r 2               T2CL_2    = VIA_2 + 8
000000r 2               T2CH_2    = VIA_2 + 9
000000r 2               SR_2      = VIA_2 + 10
000000r 2               ACR_2     = VIA_2 + 11
000000r 2               PCR_2     = VIA_2 + 12
000000r 2               IFR_2     = VIA_2 + 13
000000r 2               IER_2     = VIA_2 + 14
000000r 2               PORTA_NO_HS_2 = VIA_2 + 15
000000r 2               
000000r 2               ; VIA_3 Port addresses
000000r 2               VIA_3     = $4800
000000r 2               PORTB_3   = VIA_3
000000r 2               PORTA_3   = VIA_3 + 1
000000r 2               DDRB_3    = VIA_3 + 2
000000r 2               DDRA_3    = VIA_3 + 3
000000r 2               T1CL_3    = VIA_3 + 4
000000r 2               T1CH_3    = VIA_3 + 5
000000r 2               T1LL_3    = VIA_3 + 6
000000r 2               T1LH_3    = VIA_3 + 7
000000r 2               T2CL_3    = VIA_3 + 8
000000r 2               T2CH_3    = VIA_3 + 9
000000r 2               SR_3      = VIA_3 + 10
000000r 2               ACR_3     = VIA_3 + 11
000000r 2               PCR_3     = VIA_3 + 12
000000r 2               IFR_3     = VIA_3 + 13
000000r 2               IER_3     = VIA_3 + 14
000000r 2               PORTA_NO_HS_3 = VIA_3 + 15
000000r 2               
000000r 2               ; ACIA_1 Port Addresses
000000r 2               ACIA_1    = $4400
000000r 2               S_TXRX_1  = ACIA_1      ; TXD / RXD
000000r 2               S_STA_1   = ACIA_1 + 1  ; Status
000000r 2               S_COM_1   = ACIA_1 + 2  ; Command
000000r 2               S_CON_1   = ACIA_1 + 3  ; Control
000000r 2               
000000r 2               
000000r 2               via_1_init:
000000r 2               
000000r 2               
000000r 2               
000000r 2  A9 9A          lda #%10011010  ; CB2, CA1 active
000002r 2  8D 0E 60       sta IER_1
000005r 2               
000005r 2  A9 51          lda #%01010001  ;  CA1 active high-transition, CB2 low
000007r 2  8D 0C 60       sta PCR_1
00000Ar 2               
00000Ar 2  A9 7F          lda #%01111111 ; Set all pins on port B to output except BIT 7 which is used for "SHIFT/INSTRUCTION"  button
00000Cr 2  8D 02 60       sta DDRB_1
00000Fr 2  A9 F0          lda #%11110000 ; Set low-nibble pins on port A to input and high-nibble pins to output, for keypad
000011r 2  8D 03 60       sta DDRA_1
000014r 2               
000014r 2  60             rts
000015r 2               
000015r 2               via_2_init:
000015r 2               
000015r 2               ;; TIMER T1 is set up in functions.inc to act as source of beep tones
000015r 2               
000015r 2  A9 FF          lda #%11111111 ; set all pins on port A & B to output
000017r 2  8D 03 50       sta DDRA_2
00001Ar 2  8D 02 50       sta DDRB_2
00001Dr 2  A9 00          lda #%00000000
00001Fr 2  8D 0E 50       sta IER_2
000022r 2  60             rts
000023r 2               
000023r 2               via_3_init:
000023r 2               
000023r 2               ;; TIMER T1 used as TICK source for RTC - set for 10ms per tick
000023r 2               ;; $270E = 9998d = count 10,000 phi2 cycles @ 1MHz = 10ms per interrupt
000023r 2               
000023r 2  A9 40          lda #%01000000 ; DON'T use PB7 as a T1 pulse timer clock output (ACR b7 = 0)
000025r 2                                ; Use T1 Timer in continuous reset-interrupt mode (ACR b6 = 1)
000025r 2  8D 0B 48       sta ACR_3
000028r 2               
000028r 2                 ; set T1 delay for 10ms interrupts
000028r 2  A9 0E          lda #$0E
00002Ar 2  8D 04 48       sta T1CL_3
00002Dr 2  A9 27          lda #$27
00002Fr 2  8D 05 48       sta T1CH_3
000032r 2               
000032r 2  A9 C0          lda #%11000000  ; Interrupt / T1 interrupt active
000034r 2  8D 0E 48       sta IER_3
000037r 2               
000037r 2  A9 FF          lda #%11111111 ; set all pins on port A & B to output for now
000039r 2  8D 03 48       sta DDRA_3
00003Cr 2  8D 02 48       sta DDRB_3
00003Fr 2               
00003Fr 2  60             rts
000040r 2               
000040r 2               
000040r 2               
000040r 2               
000040r 1               .include "../includes/lcd.inc"
000040r 2               
000040r 2               
000040r 2                 .code
000040r 2               
000040r 2               ; LCD Command masks
000040r 2               E  = %01000000
000040r 2               RW = %00100000
000040r 2               RS = %00010000
000040r 2               
000040r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000040r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000040r 2               ;;
000040r 2               ;;
000040r 2               ;;                              LCD Functions
000040r 2               ;;
000040r 2               ;;
000040r 2               ;;
000040r 2               
000040r 2               lcd_start:
000040r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000042r 2  20 rr rr       jsr lcd_instruction
000045r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000047r 2  20 rr rr       jsr lcd_instruction
00004Ar 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00004Cr 2  20 rr rr       jsr lcd_instruction
00004Fr 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000051r 2  20 rr rr       jsr lcd_instruction
000054r 2  20 rr rr       jsr lcd_entry_mode
000057r 2  20 rr rr       jsr lcd_cursor_off
00005Ar 2  20 rr rr       jsr lcd_clear
00005Dr 2                 ;jsr lcd_add0
00005Dr 2  60             rts
00005Er 2               
00005Er 2               lcd_entry_mode:
00005Er 2  A9 06          lda #%00000110 ; Increment and shift cursor; don't shift display
000060r 2  20 rr rr       jsr lcd_instruction
000063r 2  60             rts
000064r 2               
000064r 2               lcd_home:
000064r 2  A9 02          lda #%00000010 ; cursor HOME
000066r 2  20 rr rr       jsr lcd_instruction
000069r 2  60             rts
00006Ar 2               
00006Ar 2               lcd_add0:
00006Ar 2  A9 80          lda #%10000000 ; back to zero position
00006Cr 2  20 rr rr       jsr lcd_instruction
00006Fr 2  60             rts
000070r 2               
000070r 2               lcd_clear:
000070r 2  A9 01          lda #%00000001 ; Clear display
000072r 2  20 rr rr       jsr lcd_instruction
000075r 2  60             rts
000076r 2               
000076r 2               lcd_cursor_off:
000076r 2  A9 0C          lda #%00001100 ; Display on; cursor off; blink off
000078r 2  20 rr rr       jsr lcd_instruction
00007Br 2  60             rts
00007Cr 2               
00007Cr 2               lcd_cursor_on:
00007Cr 2  A9 0F          lda #%00001111 ; Display on; cursor on; blink on
00007Er 2  20 rr rr       jsr lcd_instruction
000081r 2  60             rts
000082r 2               
000082r 2               lcd_line_1:
000082r 2  A9 80          lda #($80)
000084r 2  20 rr rr       jsr lcd_instruction
000087r 2  60             rts
000088r 2               
000088r 2               lcd_line_2:
000088r 2  A9 C0          lda #($80 + $40)
00008Ar 2  20 rr rr       jsr lcd_instruction
00008Dr 2  60             rts
00008Er 2               
00008Er 2               lcd_line_3:
00008Er 2  A9 94          lda #($80 + $14)
000090r 2  20 rr rr       jsr lcd_instruction
000093r 2  60             rts
000094r 2               
000094r 2               lcd_line_4:
000094r 2  A9 D4          lda #($80 + $54)
000096r 2  20 rr rr       jsr lcd_instruction
000099r 2  60             rts
00009Ar 2               
00009Ar 2               lcd_wait:
00009Ar 2  48             pha
00009Br 2  A9 70          lda #%01110000  ; LCD data is input (don't change MSB BIT7, it has to stay ZERO for SHIFT Button input)
00009Dr 2  8D 02 60       sta DDRB_1
0000A0r 2               lcdbusy:
0000A0r 2  A9 20          lda #RW
0000A2r 2  8D 00 60       sta PORTB_1
0000A5r 2  A9 60          lda #(RW | E)
0000A7r 2  8D 00 60       sta PORTB_1
0000AAr 2  AD 00 60       lda PORTB_1     ; Read high nibble
0000ADr 2  48             pha             ; and put on stack since it has the busy flag
0000AEr 2  A9 20          lda #RW
0000B0r 2  8D 00 60       sta PORTB_1
0000B3r 2  A9 60          lda #(RW | E)
0000B5r 2  8D 00 60       sta PORTB_1
0000B8r 2  AD 00 60       lda PORTB_1       ; Read low nibble
0000BBr 2  68             pla             ; Get high nibble off stack
0000BCr 2  29 08          and #%00001000
0000BEr 2  D0 E0          bne lcdbusy
0000C0r 2               
0000C0r 2  A9 20          lda #RW
0000C2r 2  8D 00 60       sta PORTB_1
0000C5r 2  A9 7F          lda #%01111111  ; LCD data is output (don't change MSB BIT7, it has to stay ZERO for SHIFT Buttion input)
0000C7r 2  8D 02 60       sta DDRB_1
0000CAr 2  68             pla
0000CBr 2  60             rts
0000CCr 2               
0000CCr 2               lcd_init:
0000CCr 2  A9 02          lda #%00000010 ; Set 4-bit mode : DO ONCE AT POWER UP
0000CEr 2  8D 00 60       sta PORTB_1
0000D1r 2  09 40          ora #E
0000D3r 2  8D 00 60       sta PORTB_1
0000D6r 2  29 0F          and #%00001111
0000D8r 2  8D 00 60       sta PORTB_1
0000DBr 2  60             rts
0000DCr 2               
0000DCr 2               lcd_instruction:
0000DCr 2  20 rr rr       jsr lcd_wait
0000DFr 2  48             pha
0000E0r 2  4A             lsr
0000E1r 2  4A             lsr
0000E2r 2  4A             lsr
0000E3r 2  4A             lsr            ; Send high 4 bits
0000E4r 2  8D 00 60       sta PORTB_1
0000E7r 2  09 40          ora #E         ; Set E bit to send instruction
0000E9r 2  8D 00 60       sta PORTB_1
0000ECr 2  49 40          eor #E         ; Clear E bit
0000EEr 2  8D 00 60       sta PORTB_1
0000F1r 2  68             pla
0000F2r 2  29 0F          and #%00001111 ; Send low 4 bits
0000F4r 2  8D 00 60       sta PORTB_1
0000F7r 2  09 40          ora #E         ; Set E bit to send instruction
0000F9r 2  8D 00 60       sta PORTB_1
0000FCr 2  49 40          eor #E         ; Clear E bit
0000FEr 2  8D 00 60       sta PORTB_1
000101r 2  60             rts
000102r 2               
000102r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000102r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000102r 2               ;;
000102r 2               ;;
000102r 2               ;;                              LCD 2 Functions
000102r 2               ;;
000102r 2               ;;
000102r 2               ;;
000102r 2               
000102r 2               lcd_2_start:
000102r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000104r 2  20 rr rr       jsr lcd_2_instruction
000107r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000109r 2  20 rr rr       jsr lcd_2_instruction
00010Cr 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00010Er 2  20 rr rr       jsr lcd_2_instruction
000111r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000113r 2  20 rr rr       jsr lcd_2_instruction
000116r 2  20 rr rr       jsr lcd_2_entry_mode
000119r 2  20 rr rr       jsr lcd_2_cursor_off
00011Cr 2  20 rr rr       jsr lcd_2_clear
00011Fr 2                 ;jsr lcd_add0
00011Fr 2  60             rts
000120r 2               
000120r 2               lcd_2_entry_mode:
000120r 2  A9 06          lda #%00000110 ; Increment and shift cursor; don't shift display
000122r 2  20 rr rr       jsr lcd_2_instruction
000125r 2  60             rts
000126r 2               
000126r 2               lcd_2_home:
000126r 2  A9 02          lda #%00000010 ; cursor HOME
000128r 2  20 rr rr       jsr lcd_2_instruction
00012Br 2  60             rts
00012Cr 2               
00012Cr 2               lcd_2_add0:
00012Cr 2  A9 80          lda #%10000000 ; back to zero position
00012Er 2  20 rr rr       jsr lcd_2_instruction
000131r 2  60             rts
000132r 2               
000132r 2               lcd_2_clear:
000132r 2  A9 01          lda #%00000001 ; Clear display
000134r 2  20 rr rr       jsr lcd_2_instruction
000137r 2  60             rts
000138r 2               
000138r 2               lcd_2_cursor_off:
000138r 2  A9 0C          lda #%00001100 ; Display on; cursor off; blink off
00013Ar 2  20 rr rr       jsr lcd_2_instruction
00013Dr 2  60             rts
00013Er 2               
00013Er 2               lcd_2_cursor_on:
00013Er 2  A9 0F          lda #%00001111 ; Display on; cursor on; blink on
000140r 2  20 rr rr       jsr lcd_2_instruction
000143r 2  60             rts
000144r 2               
000144r 2               lcd_2_line_1:
000144r 2  A9 80          lda #($80)
000146r 2  20 rr rr       jsr lcd_2_instruction
000149r 2  60             rts
00014Ar 2               
00014Ar 2               lcd_2_line_2:
00014Ar 2  A9 C0          lda #($80 + $40)
00014Cr 2  20 rr rr       jsr lcd_2_instruction
00014Fr 2  60             rts
000150r 2               
000150r 2               lcd_2_wait:
000150r 2  48             pha
000151r 2  A9 70          lda #%01110000  ; LCD data is input (don't change MSB BIT7, it has to stay ZERO for SHIFT Button input)
000153r 2  8D 03 48       sta DDRA_3
000156r 2               
000156r 2               lcdbusy2:
000156r 2  A9 20          lda #RW
000158r 2  8D 01 48       sta PORTA_3
00015Br 2  A9 60          lda #(RW | E)
00015Dr 2  8D 01 48       sta PORTA_3
000160r 2  AD 01 48       lda PORTA_3     ; Read high nibble
000163r 2  48             pha             ; and put on stack since it has the busy flag
000164r 2  A9 20          lda #RW
000166r 2  8D 01 48       sta PORTA_3
000169r 2  A9 60          lda #(RW | E)
00016Br 2  8D 01 48       sta PORTA_3
00016Er 2  AD 01 48       lda PORTA_3       ; Read low nibble
000171r 2  68             pla             ; Get high nibble off stack
000172r 2  29 08          and #%00001000
000174r 2  D0 E0          bne lcdbusy2
000176r 2               
000176r 2  A9 20          lda #RW
000178r 2  8D 01 48       sta PORTA_3
00017Br 2  A9 7F          lda #%01111111  ; LCD data is output (don't change MSB BIT7, it has to stay ZERO for SHIFT Buttion input)
00017Dr 2  8D 03 48       sta DDRA_3
000180r 2  68             pla
000181r 2  60             rts
000182r 2               
000182r 2               lcd_2_init:
000182r 2  A9 02          lda #%00000010 ; Set 4-bit mode : DO ONCE AT POWER UP
000184r 2  8D 01 48       sta PORTA_3
000187r 2  09 40          ora #E
000189r 2  8D 01 48       sta PORTA_3
00018Cr 2  29 0F          and #%00001111
00018Er 2  8D 01 48       sta PORTA_3
000191r 2  60             rts
000192r 2               
000192r 2               lcd_2_instruction:
000192r 2  20 rr rr       jsr lcd_2_wait
000195r 2  48             pha
000196r 2  4A             lsr
000197r 2  4A             lsr
000198r 2  4A             lsr
000199r 2  4A             lsr            ; Send high 4 bits
00019Ar 2  8D 01 48       sta PORTA_3
00019Dr 2  09 40          ora #E         ; Set E bit to send instruction
00019Fr 2  8D 01 48       sta PORTA_3
0001A2r 2  49 40          eor #E         ; Clear E bit
0001A4r 2  8D 01 48       sta PORTA_3
0001A7r 2  68             pla
0001A8r 2  29 0F          and #%00001111 ; Send low 4 bits
0001AAr 2  8D 01 48       sta PORTA_3
0001ADr 2  09 40          ora #E         ; Set E bit to send instruction
0001AFr 2  8D 01 48       sta PORTA_3
0001B2r 2  49 40          eor #E         ; Clear E bit
0001B4r 2  8D 01 48       sta PORTA_3
0001B7r 2  60             rts
0001B8r 2               
0001B8r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0001B8r 2               ;;
0001B8r 2               ;;        PRINT Characters on LCD 2 - an ASCII value in Accumulator
0001B8r 2               ;;        is printed on the display
0001B8r 2               ;;
0001B8r 2               
0001B8r 2               print_2_char:
0001B8r 2  20 rr rr       jsr lcd_2_wait
0001BBr 2  48             pha
0001BCr 2  4A             lsr
0001BDr 2  4A             lsr
0001BEr 2  4A             lsr
0001BFr 2  4A             lsr             ; Send high 4 bits
0001C0r 2  09 10          ora #RS         ; Set RS
0001C2r 2  8D 01 48       sta PORTA_3
0001C5r 2  09 40          ora #E          ; Set E bit to send instruction
0001C7r 2  8D 01 48       sta PORTA_3
0001CAr 2  49 40          eor #E          ; Clear E bit
0001CCr 2  8D 01 48       sta PORTA_3
0001CFr 2  68             pla
0001D0r 2  29 0F          and #%00001111  ; Send low 4 bits
0001D2r 2  09 10          ora #RS         ; Set RS
0001D4r 2  8D 01 48       sta PORTA_3
0001D7r 2  09 40          ora #E          ; Set E bit to send instruction
0001D9r 2  8D 01 48       sta PORTA_3
0001DCr 2  49 40          eor #E          ; Clear E bit
0001DEr 2  8D 01 48       sta PORTA_3
0001E1r 2  60             rts
0001E2r 2               
0001E2r 2               
0001E2r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0001E2r 2               ;;
0001E2r 2               ;;        PRINT Characters on LCD - an ASCII value in Accumulator
0001E2r 2               ;;        is printed on the display
0001E2r 2               ;;
0001E2r 2               
0001E2r 2               print_char:
0001E2r 2  20 rr rr       jsr lcd_wait
0001E5r 2  48             pha
0001E6r 2  4A             lsr
0001E7r 2  4A             lsr
0001E8r 2  4A             lsr
0001E9r 2  4A             lsr             ; Send high 4 bits
0001EAr 2  09 10          ora #RS         ; Set RS
0001ECr 2  8D 00 60       sta PORTB_1
0001EFr 2  09 40          ora #E          ; Set E bit to send instruction
0001F1r 2  8D 00 60       sta PORTB_1
0001F4r 2  49 40          eor #E          ; Clear E bit
0001F6r 2  8D 00 60       sta PORTB_1
0001F9r 2  68             pla
0001FAr 2  29 0F          and #%00001111  ; Send low 4 bits
0001FCr 2  09 10          ora #RS         ; Set RS
0001FEr 2  8D 00 60       sta PORTB_1
000201r 2  09 40          ora #E          ; Set E bit to send instruction
000203r 2  8D 00 60       sta PORTB_1
000206r 2  49 40          eor #E          ; Clear E bit
000208r 2  8D 00 60       sta PORTB_1
00020Br 2  60             rts
00020Cr 2               
00020Cr 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00020Cr 2               ;;
00020Cr 2               ;;            print on line 1 or line 2 of LCD 1 or 2
00020Cr 2               ;;
00020Cr 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00020Cr 2               
00020Cr 2               
00020Cr 2               
00020Cr 2               print1:
00020Cr 2  20 rr rr       jsr lcd_line_1
00020Fr 2  A0 00          ldy #0
000211r 2  4C rr rr       jmp line
000214r 2               print2:
000214r 2  20 rr rr       jsr lcd_line_2
000217r 2  A0 00          ldy #0
000219r 2  4C rr rr       jmp line
00021Cr 2               print3:
00021Cr 2  20 rr rr       jsr lcd_line_3
00021Fr 2  A0 00          ldy #0
000221r 2  4C rr rr       jmp line
000224r 2               print4:
000224r 2  20 rr rr       jsr lcd_line_4
000227r 2  A0 00          ldy #0
000229r 2  4C rr rr       jmp line
00022Cr 2               
00022Cr 2               print2_2:
00022Cr 2  20 rr rr       jsr lcd_2_line_2
00022Fr 2  A0 00          ldy #0
000231r 2  4C rr rr       jmp line2
000234r 2               
000234r 2               line:
000234r 2  B1 rr          lda (MESSAGE_POINTER),y
000236r 2  F0 07          beq @exit
000238r 2  20 rr rr       jsr print_char
00023Br 2  C8             iny
00023Cr 2  4C rr rr       jmp line
00023Fr 2               @exit:
00023Fr 2  60             rts
000240r 2               
000240r 2               line2:
000240r 2  B1 rr          lda (MESSAGE_POINTER),y
000242r 2  F0 07          beq @exit
000244r 2  20 rr rr       jsr print_2_char
000247r 2  C8             iny
000248r 2  4C rr rr       jmp line2
00024Br 2               @exit:
00024Br 2  60             rts
00024Cr 2               
00024Cr 2               
00024Cr 2               
00024Cr 1               .include "../includes/getkey.inc"
00024Cr 2               
00024Cr 2                 .code
00024Cr 2               
00024Cr 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00024Cr 2               ;;
00024Cr 2               ;;
00024Cr 2               ;;      READ THE 4x4 keypad using  VIA_1 PORTA
00024Cr 2               ;;
00024Cr 2               ;;      Accumulator holds the ASCII value of the pressed key when it returns
00024Cr 2               ;;
00024Cr 2               
00024Cr 2               get_key:
00024Cr 2               readKeypad:
00024Cr 2  A2 04          ldx #$04        ; Row 4 - counting down
00024Er 2  A0 80          ldy #%10000000  ;
000250r 2               ScanRow:
000250r 2  8C 01 60       sty PORTA_1
000253r 2  AD 01 60       lda PORTA_1
000256r 2  29 0F          and #$0F  ; mask off keypad input - only low 4 (keypad column) bits are read
000258r 2  C9 00          cmp #$00
00025Ar 2  D0 0B          bne Row_Found   ; non-zero means a row output has been connected via a switch to a column input
00025Cr 2  CA             dex             ; zero means it hasn't been found, so check next row down
00025Dr 2  98             tya
00025Er 2  4A             lsr
00025Fr 2  A8             tay
000260r 2  C9 08          cmp #%00001000
000262r 2  D0 EC          bne ScanRow
000264r 2  A9 FF          lda #$ff
000266r 2  60             rts
000267r 2               Row_Found:
000267r 2  8E rr rr       stx TEMP ; store row
00026Ar 2  A0 FF          ldy #$ff
00026Cr 2               FindCol:
00026Cr 2  C8             iny
00026Dr 2  4A             lsr
00026Er 2  90 FC          bcc FindCol
000270r 2  98             tya
000271r 2  0A             asl
000272r 2  0A             asl  ; col * 4
000273r 2  18             clc
000274r 2  6D rr rr       adc TEMP ; add row
000277r 2  AA             tax
000278r 2  BD rr rr       lda keypad_array,x
00027Br 2  60             rts
00027Cr 2               
00027Cr 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00027Cr 2               ;;
00027Cr 2               ;;       key = <INDEX> ; pressing a key returns a 4-bit number
00027Cr 2               ;;       calculated as (Column * 4 ) + Row, in the range
00027Cr 2               ;;       1 - 16 which acts as an index to a lookup-table.
00027Cr 2               ;;       The lookup table returns a byte value equal to the key's
00027Cr 2               ;;       numerical value
00027Cr 2               ;;       e.g.
00027Cr 2               ;;       button 1 returns byte $01 / 00000001
00027Cr 2               ;;       button F returns byte $0f / 00001111
00027Cr 2               ;;    ____________________________________________________
00027Cr 2               ;;   |     1 = <16> | 2 = <12> |    3 = <8> | A(10) = <4> |
00027Cr 2               ;;   |______________|__________|____________|_____________|
00027Cr 2               ;;   |     4 = <15> | 5 = <11> |    6 = <7> | B(11) = <3> |
00027Cr 2               ;;   |______________|__________|____________|_____________|
00027Cr 2               ;;   |     7 = <14> | 8 = <10> |    9 = <6> | C(12) = <2> |
00027Cr 2               ;;   |______________|__________|____________|_____________|
00027Cr 2               ;;   | E(14) = <13> | 0 = <9>  | F(15)= <5> | D(13) = <1> |
00027Cr 2               ;;   |______________|__________|____________|_____________|
00027Cr 2               ;;
00027Cr 2               ;;            Button  ..   D    C    B    A    F    9    6    3    0    8    5    2    E    7    4    1
00027Cr 2               ;;            <INDEX> 0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16
00027Cr 2  00 0D 0C 0B  keypad_array: .byte $00, $0D, $0C, $0B, $0A, $0F, $09, $06, $03, $00, $08, $05, $02, $0E, $07, $04, $01
000280r 2  0A 0F 09 06  
000284r 2  03 00 08 05  
00028Dr 2               
00028Dr 2               
00028Dr 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00028Dr 2               ;;
00028Dr 2               ;;  set ROW keypad outputs high as a source for triggering interrupt when a key is pressed
00028Dr 2               ;;
00028Dr 2               ;;
00028Dr 2               scan:
00028Dr 2  A0 F0          ldy #%11110000
00028Fr 2  8C 01 60       sty PORTA_1
000292r 2  60             rts
000293r 2               
000293r 2               
000293r 1               .include "../includes/functions.inc"
000293r 2               
000293r 2               
000293r 2                 .code
000293r 2               
000293r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000293r 2               ;;
000293r 2               ;;        Use T1 Timer in free-run mode to put pulse
000293r 2               ;;        train on PB7 at rate determined by
000293r 2               ;;        the chosen delay. Tone output is enabled by
000293r 2               ;;        setting bit7 of ACR register and disabled by
000293r 2               ;;        resetting it. This should really be done by or'ing
000293r 2               ;;        %10000000 with the current value of ACR, to preserve
000293r 2               ;;        the other bit-values. At the moment it's just a two
000293r 2               ;;        state setting: 11000000 = Tone On, 01000000 = Tone off.
000293r 2               ;;        bit6 of ACR sets T1 in free-run repeat mode and stays set
000293r 2               ;;
000293r 2               
000293r 2               ;; T1 Timer values:
000293r 2               
000293r 2               ;; (Phi2 / (2 * f) ) - 2
000293r 2               ;;
000293r 2               ;;  Phi2 = 1MHz = 1,000,000
000293r 2               ;;
000293r 2               ;;    f  = count => Hex    => Counter Low : Counter High
000293r 2               ;; =========================================================
000293r 2               ;;  50Hz = 9998d => $270E  => T1CL = $0E  : T1CH = $27
000293r 2               ;; 100Hz = 4998d => $1386  => T1CL = $86  : T1CH = $13
000293r 2               ;; 200Hz = 2498d => $09C2  => T1CL = $C2  : T1CH = $09
000293r 2               ;; 500Hz =  998d => $03E6  => T1CL = $E6  : T1CH = $03
000293r 2               ;; 800Hz =  623d => $026F  => T1CL = $6F  : T1CH = $02
000293r 2               ;; 1kHz  =  498d => $01F2  => T1CL = $F2  : T1CH = $01
000293r 2               ;; 2kHz  =  248d => $00F8  => T1CL = $F8  : T1CH = $00
000293r 2               ;;
000293r 2               ;; USING VIA_2 for the beep Timer/output
000293r 2               ;;
000293r 2               ;; DO NOT CONFIGURE T1 TIMER settings in ioports.inc
000293r 2               ;; They are set here whenever the beep is needed
000293r 2               ;;
000293r 2               
000293r 2               count_50 = $270E
000293r 2               count_100 = $1386
000293r 2               count_200 = $09C2
000293r 2               count_500 = $03E6
000293r 2               count_800 = $026F
000293r 2               count_1k = $01F2
000293r 2               count_2k = $00F8
000293r 2               
000293r 2               ;;               50Hz, 100Hz, 200Hz, 500Hz, 800Hz, 1kHz, 2kHz
000293r 2  0E 27 86 13  beepList: .word $270E, $1386, $09C2, $03E6, $026F, $01F2, $00F8
000297r 2  C2 09 E6 03  
00029Br 2  6F 02 F2 01  
0002A1r 2               
0002A1r 2               ;; Load A with the required index and call beep_from_list
0002A1r 2               
0002A1r 2               beep_from_list:
0002A1r 2               
0002A1r 2  0A             asl
0002A2r 2  A8             tay
0002A3r 2  B9 rr rr       lda beepList,y
0002A6r 2  8D 04 50       sta T1CL_2
0002A9r 2  C8             iny
0002AAr 2  B9 rr rr       lda beepList,y
0002ADr 2  8D 05 50       sta T1CH_2
0002B0r 2               
0002B0r 2  A9 C0          lda #%11000000
0002B2r 2  8D 0B 50       sta ACR_2
0002B5r 2               
0002B5r 2  20 rr rr       jsr beep_delay
0002B8r 2               
0002B8r 2  A9 40          lda #%01000000
0002BAr 2  8D 0B 50       sta ACR_2
0002BDr 2               
0002BDr 2  60             rts
0002BEr 2               
0002BEr 2               beep:
0002BEr 2               
0002BEr 2               ;; 800Hz keybeep
0002BEr 2               
0002BEr 2  A9 6F          lda #<count_800
0002C0r 2  8D 04 50       sta T1CL_2
0002C3r 2  A9 02          lda #>count_800
0002C5r 2  8D 05 50       sta T1CH_2
0002C8r 2  A9 C0          lda #%11000000
0002CAr 2  8D 0B 50       sta ACR_2
0002CDr 2  20 rr rr       jsr beep_delay
0002D0r 2  A9 40          lda #%01000000
0002D2r 2  8D 0B 50       sta ACR_2
0002D5r 2  60             rts
0002D6r 2               
0002D6r 2               beep_from_pointer:  ; put the 2 bytes for the required count into BEEP_POINTER and BEEP_POINTER + 1 and then
0002D6r 2                                   ; call beep_from_pointer
0002D6r 2               
0002D6r 2               
0002D6r 2  A5 rr          lda BEEP_POINTER
0002D8r 2  8D 04 50       sta T1CL_2
0002DBr 2  A5 rr          lda BEEP_POINTER + 1
0002DDr 2  8D 05 50       sta T1CH_2
0002E0r 2               
0002E0r 2  A9 C0          lda #%11000000 ; enable PB7 pulses out
0002E2r 2  8D 0B 50       sta ACR_2
0002E5r 2               
0002E5r 2  20 rr rr       jsr beep_delay
0002E8r 2               
0002E8r 2  A9 40          lda #%01000000 ; disable PB7 pulses out
0002EAr 2  8D 0B 50       sta ACR_2
0002EDr 2  60             rts
0002EEr 2               
0002EEr 2               beep2: ; high/low beep for boot-up success notification
0002EEr 2               
0002EEr 2               ; 1kHz
0002EEr 2  A9 F2          lda #<count_1k
0002F0r 2  8D 04 50       sta T1CL_2
0002F3r 2  A9 01          lda #>count_1k
0002F5r 2  8D 05 50       sta T1CH_2
0002F8r 2               
0002F8r 2  A9 C0          lda #%11000000
0002FAr 2  8D 0B 50       sta ACR_2
0002FDr 2               
0002FDr 2  20 rr rr       jsr beep_delay
000300r 2               
000300r 2               
000300r 2               
000300r 2               
000300r 2               ; 800Hz
000300r 2  A9 6F          lda #<count_800
000302r 2  8D 04 50       sta T1CL_2
000305r 2  A9 02          lda #>count_800
000307r 2  8D 05 50       sta T1CH_2
00030Ar 2  A2 FF          ldx #$ff
00030Cr 2  A0 7F          ldy #$7f
00030Er 2               
00030Er 2  20 rr rr       jsr beep_delay
000311r 2               
000311r 2  A9 40          lda #%01000000
000313r 2  8D 0B 50       sta ACR_2
000316r 2  60             rts
000317r 2               
000317r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000317r 2               ;;
000317r 2               ;;      basic loop delay to make the beep
000317r 2               ;;
000317r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000317r 2               
000317r 2               beep_delay:
000317r 2  A2 FF          ldx #$ff
000319r 2  A0 38          ldy #$38  ; <= set here to adjjust the beep length
00031Br 2               @loop:
00031Br 2  EA             nop
00031Cr 2  CA             dex
00031Dr 2  D0 FC          bne @loop
00031Fr 2  88             dey
000320r 2  D0 F9          bne @loop
000322r 2  60             rts
000323r 2               
000323r 2               
000323r 2               
000323r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000323r 2               ;;
000323r 2               ;;          convert an 8-bit binary number from Accumulator, in range 00000000 -> 11111111 ($00 to $FF)
000323r 2               ;;          to its HEX number encode as ASCII -  using a simple lookup table. Store each digit in RAM. Accumulator
000323r 2               ;;          holds the last/low digit on return.
000323r 2               ;;
000323r 2               
000323r 2               
000323r 2               bintohex:
000323r 2  48             pha
000324r 2  4A             lsr
000325r 2  4A             lsr
000326r 2  4A             lsr
000327r 2  4A             lsr
000328r 2  AA             tax
000329r 2  BD rr rr       lda hexascii,x
00032Cr 2  8D rr rr       sta HI_DIGIT
00032Fr 2  68             pla
000330r 2  29 0F          and #$0f
000332r 2  AA             tax
000333r 2  BD rr rr       lda hexascii,x
000336r 2  8D rr rr       sta LO_DIGIT
000339r 2  60             rts
00033Ar 2               
00033Ar 2  30 31 32 33  hexascii: .byte "0123456789ABCDEF"
00033Er 2  34 35 36 37  
000342r 2  38 39 41 42  
00034Ar 2               
00034Ar 2               
00034Ar 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00034Ar 2               ;;
00034Ar 2               ;;    convert a binary (hex) value in Accumulator into
00034Ar 2               ;;    its ASCII equivalent character in decimal 0-99 and print it
00034Ar 2               ;;    this converts hex/binary numbers from the RTC into human readable
00034Ar 2               ;;    decimal for display on clock
00034Ar 2               
00034Ar 2               
00034Ar 2               bintoascii:
00034Ar 2               
00034Ar 2  C9 0A          cmp #10
00034Cr 2  30 10          bmi single_figure
00034Er 2  0A             asl
00034Fr 2  AA             tax
000350r 2  BD rr rr       lda binascii,x
000353r 2  20 rr rr       jsr print_char
000356r 2               
000356r 2  E8             inx
000357r 2               
000357r 2  BD rr rr       lda binascii,x
00035Ar 2  20 rr rr       jsr print_char
00035Dr 2  60             rts
00035Er 2               
00035Er 2               single_figure:
00035Er 2  0A             asl
00035Fr 2  AA             tax
000360r 2  E8             inx
000361r 2  BD rr rr       lda binascii,x
000364r 2  20 rr rr       jsr print_char
000367r 2  60             rts
000368r 2               
000368r 2               bintoascii_2:
000368r 2               
000368r 2  C9 0A          cmp #10
00036Ar 2  30 10          bmi single_figure_2
00036Cr 2  0A             asl
00036Dr 2  AA             tax
00036Er 2  BD rr rr       lda binascii,x
000371r 2  20 rr rr       jsr print_2_char
000374r 2               
000374r 2  E8             inx
000375r 2               
000375r 2  BD rr rr       lda binascii,x
000378r 2  20 rr rr       jsr print_2_char
00037Br 2  60             rts
00037Cr 2               
00037Cr 2               single_figure_2:
00037Cr 2  0A             asl
00037Dr 2  AA             tax
00037Er 2  E8             inx
00037Fr 2  BD rr rr       lda binascii,x
000382r 2  20 rr rr       jsr print_2_char
000385r 2  60             rts
000386r 2               
000386r 2               
000386r 2  30 30 30 31  binascii: .byte "00010203040506070809"
00038Ar 2  30 32 30 33  
00038Er 2  30 34 30 35  
00039Ar 2  31 30 31 31            .byte "10111213141516171819"
00039Er 2  31 32 31 33  
0003A2r 2  31 34 31 35  
0003AEr 2  32 30 32 31            .byte "20212223242526272829"
0003B2r 2  32 32 32 33  
0003B6r 2  32 34 32 35  
0003C2r 2  33 30 33 31            .byte "30313233343536373839"
0003C6r 2  33 32 33 33  
0003CAr 2  33 34 33 35  
0003D6r 2  34 30 34 31            .byte "40414243444546474849"
0003DAr 2  34 32 34 33  
0003DEr 2  34 34 34 35  
0003EAr 2  35 30 35 31            .byte "50515253545556575859"
0003EEr 2  35 32 35 33  
0003F2r 2  35 34 35 35  
0003FEr 2  36 30 36 31            .byte "60616263646566676869"
000402r 2  36 32 36 33  
000406r 2  36 34 36 35  
000412r 2  37 30 37 31            .byte "70717273747576777879"
000416r 2  37 32 37 33  
00041Ar 2  37 34 37 35  
000426r 2  38 30 38 31            .byte "80818283848586878889"
00042Ar 2  38 32 38 33  
00042Er 2  38 34 38 35  
00043Ar 2  39 30 39 31            .byte "90919293949596979899"
00043Er 2  39 32 39 33  
000442r 2  39 34 39 35  
00044Er 2               
00044Er 2               
00044Er 2               
00044Er 2               
00044Er 2               
00044Er 1               .include "../includes/rtc.inc"
00044Er 2               
00044Er 2               
00044Er 2               
00044Er 2               
00044Er 2                 .code
00044Er 2               
00044Er 2               
00044Er 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00044Er 2               ;;
00044Er 2               ;;                          RTC / Jiffy Tick
00044Er 2               ;;
00044Er 2               
00044Er 2               
00044Er 2               
00044Er 2               rtc:
00044Er 2               
00044Er 2               
00044Er 2               ;;  RTC stores ticks at 10ms intervals into a 4-byte (32 bit) value
00044Er 2               ;;
00044Er 2               ;;  as each byte rolls over the next one is incremented
00044Er 2               ;;  on a tick that doesn't roll over the TIME OF DAY
00044Er 2               ;;  is updated
00044Er 2               
00044Er 2  E6 rr          inc TICKS
000450r 2  D0 0A          bne inc_MET
000452r 2  E6 rr          inc TICKS + 1
000454r 2  D0 06          bne inc_MET
000456r 2  E6 rr          inc TICKS + 2
000458r 2  D0 02          bne inc_MET
00045Ar 2  E6 rr          inc TICKS + 3
00045Cr 2               
00045Cr 2               ;;
00045Cr 2               ;;  Every time it's called we increment the "hundredths of a second" byte
00045Cr 2               ;;
00045Cr 2               ;;  When there's been 100 x 10ms (i.e. 1 second) we increment the seconds
00045Cr 2               ;;
00045Cr 2               ;; We keep the times in single digits, SECONDS, TEN_SECONDS, MINUTES,
00045Cr 2               ;; TEN_MINUTES etc.... to make it easy to display
00045Cr 2               ;; The values are stored in RAM as binary values, and need to be converted to
00045Cr 2               ;; ASCII characters when they are displayed on LCD
00045Cr 2               ;;
00045Cr 2               ;;  The bulk of this routine comes from http://wilsonminesco.com/6502interrupts/#2.1
00045Cr 2               ;;
00045Cr 2               inc_MET:
00045Cr 2  E6 rr          inc CENTISEC
00045Er 2  A5 rr          lda CENTISEC
000460r 2  C9 64          cmp #100
000462r 2  30 40          bmi end_MET
000464r 2  64 rr          stz CENTISEC
000466r 2               
000466r 2  E6 rr          inc SECONDS
000468r 2  A5 rr          lda SECONDS
00046Ar 2  C9 0A          cmp #10
00046Cr 2  30 36          bmi end_MET
00046Er 2  64 rr          stz SECONDS
000470r 2  E6 rr          inc TEN_SECONDS
000472r 2               
000472r 2  A5 rr          lda TEN_SECONDS
000474r 2  C9 06          cmp #6
000476r 2  30 2C          bmi end_MET
000478r 2  64 rr          stz TEN_SECONDS
00047Ar 2               
00047Ar 2  E6 rr          inc MINUTES
00047Cr 2  A5 rr          lda MINUTES
00047Er 2  C9 0A          cmp #10
000480r 2  30 22          bmi end_MET
000482r 2  64 rr          stz MINUTES
000484r 2               
000484r 2  E6 rr          inc TEN_MINUTES
000486r 2  A5 rr          lda TEN_MINUTES
000488r 2  C9 06          cmp #6
00048Ar 2  30 18          bmi end_MET
00048Cr 2  64 rr          stz TEN_MINUTES
00048Er 2               
00048Er 2  E6 rr          inc HRS
000490r 2  A5 rr          lda HRS
000492r 2  C9 0A          cmp #10
000494r 2  30 0E          bmi end_MET
000496r 2  64 rr          stz HRS
000498r 2               
000498r 2  E6 rr          inc TEN_HRS
00049Ar 2  A5 rr          lda TEN_HRS
00049Cr 2  C9 0A          cmp #10
00049Er 2  30 04          bmi end_MET
0004A0r 2  64 rr          stz TEN_HRS
0004A2r 2               
0004A2r 2  E6 rr          inc HUNDRED_HRS
0004A4r 2               
0004A4r 2               end_MET:
0004A4r 2  60             rts
0004A5r 2               
0004A5r 2               
0004A5r 1               
0004A5r 1               
0004A5r 1               
0004A5r 1               
0004A5r 1               
0004A5r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004A5r 1               ;;
0004A5r 1               ;;         START HERE
0004A5r 1               ;;
0004A5r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004A5r 1               
0004A5r 1               .code
0004A5r 1               
0004A5r 1               
0004A5r 1               
0004A5r 1               
0004A5r 1               
0004A5r 1               
0004A5r 1               reset:
0004A5r 1               
0004A5r 1               
0004A5r 1  A2 FF          ldx #$ff
0004A7r 1  9A             txs
0004A8r 1  58             cli      ; interrupts ON
0004A9r 1               
0004A9r 1                 ;; IOPORTS
0004A9r 1  20 rr rr       jsr via_1_init ; set-up VIA_1 for LCD/Keypad
0004ACr 1  20 rr rr       jsr via_2_init ; set-up VIA_2 for general I/O
0004AFr 1  20 rr rr       jsr via_3_init ; set-up VIA_3 for general I/O
0004B2r 1               
0004B2r 1                 ;; LCD
0004B2r 1  20 rr rr       jsr lcd_start ; set-up various features of lcd
0004B5r 1  20 rr rr       jsr lcd_2_start ; set-up various features of lcd
0004B8r 1               
0004B8r 1               
0004B8r 1               init_variables:
0004B8r 1               
0004B8r 1  64 rr          stz TICKS
0004BAr 1  64 rr          stz TICKS + 1
0004BCr 1  64 rr          stz TICKS + 2
0004BEr 1  64 rr          stz TICKS + 3
0004C0r 1  64 rr          stz DUMP_POINTER
0004C2r 1  64 rr          stz DUMP_POINTER + 1
0004C4r 1  64 rr          stz MESSAGE_POINTER
0004C6r 1  64 rr          stz MESSAGE_POINTER + 1
0004C8r 1  64 rr          stz BEEP_POINTER
0004CAr 1  64 rr          stz BEEP_POINTER + 1
0004CCr 1  64 rr          stz TOGGLE_TIME
0004CEr 1  64 rr          stz CLOCK_LAST
0004D0r 1  64 rr          stz LED2_LAST
0004D2r 1  64 rr          stz LED3_LAST
0004D4r 1  64 rr          stz CENTISEC
0004D6r 1  64 rr          stz FLAGS
0004D8r 1  64 rr          stz SECONDS
0004DAr 1  64 rr          stz TEN_SECONDS
0004DCr 1  64 rr          stz MINUTES
0004DEr 1  64 rr          stz HRS
0004E0r 1  64 rr          stz TEN_HRS
0004E2r 1  64 rr          stz TEN_MINUTES
0004E4r 1  64 rr          stz HUNDRED_HRS
0004E6r 1  9C rr rr       stz TEMP
0004E9r 1  9C rr rr       stz TEMP2
0004ECr 1  9C rr rr       stz TENS
0004EFr 1  64 rr          stz MEM_POINTER
0004F1r 1  64 rr          stz MEM_POINTER + 1
0004F3r 1  9C rr rr       stz HI_DIGIT
0004F6r 1  9C rr rr       stz LO_DIGIT
0004F9r 1  A9 10          lda #$10
0004FBr 1  85 rr          sta LAST_KIT
0004FDr 1               
0004FDr 1  A9 rr          lda #<title
0004FFr 1  85 rr          sta MESSAGE_POINTER
000501r 1  A9 rr          lda #>title
000503r 1  85 rr          sta MESSAGE_POINTER + 1
000505r 1  20 rr rr       jsr print1
000508r 1               
000508r 1               
000508r 1               memory_test:
000508r 1               
000508r 1  A9 rr          lda #<mem_start_msg
00050Ar 1  85 rr          sta MESSAGE_POINTER
00050Cr 1  A9 rr          lda #>mem_start_msg
00050Er 1  85 rr          sta MESSAGE_POINTER + 1
000510r 1  20 rr rr       jsr print2
000513r 1               
000513r 1               ;; test then clear RAM between
000513r 1               ;; $0200 - $3FFF - avoids the ZP and STACK areas
000513r 1               
000513r 1  A9 02          lda #$02            ; start at $0200
000515r 1  85 rr          sta MEM_POINTER + 1
000517r 1  A0 00          ldy #$00
000519r 1               loop_ram:
000519r 1  A9 AA          lda #$AA              ; test with 10101010
00051Br 1  91 rr          sta (MEM_POINTER),y   ; write test value to RAM
00051Dr 1  A9 FF          lda #$FF              ; remove test value from A
00051Fr 1  B1 rr          lda (MEM_POINTER),y   ; read RAM contents into A
000521r 1  C9 AA          cmp #$AA              ; compare to expected value
000523r 1  D0 4E          bne mem_fail_1
000525r 1  A9 55          lda #$55              ; repeat test with 01010101
000527r 1  91 rr          sta (MEM_POINTER),y
000529r 1  A9 FF          lda #$FF
00052Br 1  B1 rr          lda (MEM_POINTER),y
00052Dr 1  C9 55          cmp #$55
00052Fr 1  D0 59          bne mem_fail_2
000531r 1  A9 00          lda #$00              ; clear RAM to all zeros
000533r 1  91 rr          sta (MEM_POINTER),y
000535r 1  C8             iny
000536r 1  F0 03          beq next_page
000538r 1  4C rr rr       jmp loop_ram
00053Br 1               next_page:
00053Br 1  A5 rr          lda MEM_POINTER + 1
00053Dr 1  1A             inc
00053Er 1  C9 40          cmp #$40
000540r 1  F0 05          beq done_ram
000542r 1  85 rr          sta MEM_POINTER + 1
000544r 1  4C rr rr       jmp loop_ram
000547r 1               
000547r 1               done_ram:
000547r 1               
000547r 1  20 rr rr       jsr beep2
00054Ar 1  A9 rr          lda #<mem_pass_msg
00054Cr 1  85 rr          sta MESSAGE_POINTER
00054Er 1  A9 rr          lda #>mem_pass_msg
000550r 1  85 rr          sta MESSAGE_POINTER + 1
000552r 1                 ;jsr lcd_clear
000552r 1  20 rr rr       jsr print3
000555r 1  D7 rr          smb5 FLAGS
000557r 1  A9 rr          lda #<start_msg
000559r 1  85 rr          sta MESSAGE_POINTER
00055Br 1  A9 rr          lda #>start_msg
00055Dr 1  85 rr          sta MESSAGE_POINTER + 1
00055Fr 1  20 rr rr       jsr print4
000562r 1  20 rr rr       jsr lcd_2_clear
000565r 1  A9 rr          lda #<emt
000567r 1  85 rr          sta MESSAGE_POINTER
000569r 1  A9 rr          lda #>emt
00056Br 1  85 rr          sta MESSAGE_POINTER + 1
00056Dr 1  20 rr rr       jsr print2_2
000570r 1  4C rr rr       jmp user_ram
000573r 1               
000573r 1               mem_fail_1:
000573r 1  20 rr rr       jsr beep
000576r 1  20 rr rr       jsr beep2
000579r 1  20 rr rr       jsr beep
00057Cr 1  A9 rr          lda #<mem_fail_msg_1
00057Er 1  85 rr          sta MESSAGE_POINTER
000580r 1  A9 rr          lda #>mem_fail_msg_1
000582r 1  85 rr          sta MESSAGE_POINTER + 1
000584r 1  20 rr rr       jsr print3
000587r 1  4C rr rr       jmp loop
00058Ar 1               
00058Ar 1               mem_fail_2:
00058Ar 1  20 rr rr       jsr beep
00058Dr 1  20 rr rr       jsr beep2
000590r 1  20 rr rr       jsr beep
000593r 1  A9 rr          lda #<mem_fail_msg_2
000595r 1  85 rr          sta MESSAGE_POINTER
000597r 1  A9 rr          lda #>mem_fail_msg_2
000599r 1  85 rr          sta MESSAGE_POINTER + 1
00059Br 1  20 rr rr       jsr print3
00059Er 1  4C rr rr       jmp loop
0005A1r 1               
0005A1r 1               
0005A1r 1               
0005A1r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005A1r 1               ;;
0005A1r 1               ;;  load the User RAM area $3F00 with the bytes
0005A1r 1               ;;  set in "userProg" - currently a small routine that
0005A1r 1               ;;  changed the contents of MESSAGE_POINTER (+1) to point
0005A1r 1               ;;  at $2000 instead. Then a string "userPrompt" is stored
0005A1r 1               ;;  at $2000. Running the user sub-routine (<shift>5) will now show
0005A1r 1               ;;  the "userPrompt" string on line4 of the main LCD
0005A1r 1               ;;  The user prog at $3F00 can be edited at will - it also has the
0005A1r 1               ;;  location of "print4" automatically inserted.
0005A1r 1               ;;
0005A1r 1               
0005A1r 1               ;; Put a sample program into "User Ram" at $3F00
0005A1r 1               user_ram:
0005A1r 1  A0 00          ldy #$00
0005A3r 1               @loop:
0005A3r 1  B9 rr rr       lda userProg,y
0005A6r 1  F0 07          beq @exit
0005A8r 1  99 00 3F       sta $3F00,y
0005ABr 1  C8             iny
0005ACr 1  4C rr rr       jmp @loop
0005AFr 1               @exit:
0005AFr 1               
0005AFr 1               ;; Put a sample text string in "User Text" @ $2000
0005AFr 1               prompt:
0005AFr 1  A0 00          ldy #$00
0005B1r 1               @loop:
0005B1r 1  B9 rr rr       lda userPrompt,y
0005B4r 1  F0 07          beq @exit
0005B6r 1  99 00 20       sta $2000,y
0005B9r 1  C8             iny
0005BAr 1  4C rr rr       jmp @loop
0005BDr 1               @exit:
0005BDr 1               
0005BDr 1               
0005BDr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005BDr 1               ;;
0005BDr 1               ;;                 Main Loop
0005BDr 1               ;;
0005BDr 1               
0005BDr 1               
0005BDr 1               loop:
0005BDr 1               
0005BDr 1  CB             wai
0005BEr 1  20 rr rr       jsr check_flags
0005C1r 1  4C rr rr       jmp loop
0005C4r 1               
0005C4r 1               
0005C4r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005C4r 1               ;;
0005C4r 1               ;;                  FUNCTIONS
0005C4r 1               ;;
0005C4r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005C4r 1               
0005C4r 1               check_flags:
0005C4r 1               
0005C4r 1               flag_zero:
0005C4r 1  0F rr 03       bbr0 FLAGS, flag_two
0005C7r 1  20 rr rr       jsr update_block_address
0005CAr 1               flag_two:
0005CAr 1  2F rr 03       bbr2 FLAGS, flag_five
0005CDr 1  20 rr rr       jsr kit_led_via_3
0005D0r 1               flag_five:
0005D0r 1  5F rr 03       bbr5 FLAGS, flag_three
0005D3r 1  20 rr rr       jsr clock_time
0005D6r 1               flag_three:
0005D6r 1  60             rts
0005D7r 1               
0005D7r 1               
0005D7r 1               
0005D7r 1               kit_led_via_3:
0005D7r 1               
0005D7r 1  38             sec
0005D8r 1  A5 rr          lda TICKS
0005DAr 1  E5 rr          sbc LED3_LAST
0005DCr 1  C9 0A          cmp #10
0005DEr 1  90 15          bcc exit_kit_leds
0005E0r 1  A4 rr          ldy LAST_KIT
0005E2r 1  B9 rr rr       lda kitLeds,y
0005E5r 1  8D 00 48       sta PORTB_3
0005E8r 1  88             dey
0005E9r 1  D0 04          bne @exit
0005EBr 1  A0 10          ldy #$10
0005EDr 1  84 rr          sty LAST_KIT
0005EFr 1               @exit:
0005EFr 1  84 rr          sty LAST_KIT
0005F1r 1  A5 rr          lda TICKS
0005F3r 1  85 rr          sta LED3_LAST
0005F5r 1               exit_kit_leds:
0005F5r 1  60             rts
0005F6r 1               
0005F6r 1               clock_via_2:
0005F6r 1  38             sec
0005F7r 1  A5 rr          lda TICKS
0005F9r 1  E5 rr          sbc LED2_LAST
0005FBr 1  C9 64          cmp #100
0005FDr 1  90 1A          bcc exit_clock_via_2
0005FFr 1  A5 rr          lda TEN_SECONDS
000601r 1  0A             asl
000602r 1  0A             asl
000603r 1  0A             asl
000604r 1  0A             asl
000605r 1  05 rr          ora SECONDS
000607r 1  8D 01 50       sta PORTA_2
00060Ar 1               
00060Ar 1  A5 rr          lda TEN_MINUTES
00060Cr 1  0A             asl
00060Dr 1  0A             asl
00060Er 1  0A             asl
00060Fr 1  0A             asl
000610r 1  05 rr          ora MINUTES
000612r 1  8D 00 50       sta PORTB_2
000615r 1               
000615r 1               @exit:
000615r 1  A5 rr          lda TICKS
000617r 1  85 rr          sta LED2_LAST
000619r 1               exit_clock_via_2:
000619r 1  60             rts
00061Ar 1               
00061Ar 1               
00061Ar 1               update_block_address:
00061Ar 1  20 rr rr       jsr lcd_line_2
00061Dr 1  38             sec
00061Er 1  A5 rr          lda TICKS
000620r 1  E5 rr          sbc TOGGLE_TIME
000622r 1  C9 64          cmp #$64
000624r 1  90 07          bcc @exit
000626r 1  20 rr rr       jsr block_address
000629r 1  A5 rr          lda TICKS
00062Br 1  85 rr          sta TOGGLE_TIME
00062Dr 1               @exit:
00062Dr 1  60             rts
00062Er 1               
00062Er 1               clock_time:
00062Er 1  38             sec
00062Fr 1  A5 rr          lda TICKS
000631r 1  E5 rr          sbc CLOCK_LAST
000633r 1  C9 32          cmp #50
000635r 1  90 3C          bcc @exit
000637r 1  20 rr rr       jsr lcd_2_cursor_off
00063Ar 1  20 rr rr       jsr lcd_2_line_1
00063Dr 1  A5 rr          lda HUNDRED_HRS
00063Fr 1  20 rr rr       jsr bintoascii_2
000642r 1  A5 rr          lda TEN_HRS
000644r 1  20 rr rr       jsr bintoascii_2
000647r 1  A5 rr          lda HRS
000649r 1  20 rr rr       jsr bintoascii_2
00064Cr 1  A9 3A          lda #':'
00064Er 1  20 rr rr       jsr print_2_char
000651r 1  A5 rr          lda TEN_MINUTES
000653r 1  20 rr rr       jsr bintoascii_2
000656r 1  A5 rr          lda MINUTES
000658r 1  20 rr rr       jsr bintoascii_2
00065Br 1  A9 3A          lda #':'
00065Dr 1  20 rr rr       jsr print_2_char
000660r 1  A5 rr          lda TEN_SECONDS
000662r 1  20 rr rr       jsr bintoascii_2
000665r 1  A5 rr          lda SECONDS
000667r 1  20 rr rr       jsr bintoascii_2
00066Ar 1  A9 20          lda #' '
00066Cr 1  20 rr rr       jsr print_2_char
00066Fr 1  A5 rr          lda TICKS
000671r 1  85 rr          sta CLOCK_LAST
000673r 1               @exit:
000673r 1  60             rts
000674r 1               
000674r 1               
000674r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000674r 1               ;;
000674r 1               ;;      update screen when new memory location is selected
000674r 1               ;;
000674r 1               ;;
000674r 1               new_address:
000674r 1  20 rr rr       jsr lcd_clear
000677r 1  20 rr rr       jsr lcd_cursor_on
00067Ar 1  A9 rr          lda #<new_address_msg
00067Cr 1  85 rr          sta MESSAGE_POINTER
00067Er 1  A9 rr          lda #>new_address_msg
000680r 1  85 rr          sta MESSAGE_POINTER + 1
000682r 1  20 rr rr       jsr print1
000685r 1  20 rr rr       jsr lcd_line_2
000688r 1               print_address:
000688r 1  A9 24          lda #'$'
00068Ar 1  20 rr rr       jsr print_char
00068Dr 1  A5 rr          lda DUMP_POINTER + 1
00068Fr 1  20 rr rr       jsr bintohex
000692r 1  AD rr rr       lda HI_DIGIT
000695r 1  20 rr rr       jsr print_char
000698r 1  AD rr rr       lda LO_DIGIT
00069Br 1  20 rr rr       jsr print_char
00069Er 1  A5 rr          lda DUMP_POINTER
0006A0r 1  20 rr rr       jsr bintohex
0006A3r 1  AD rr rr       lda HI_DIGIT
0006A6r 1  20 rr rr       jsr print_char
0006A9r 1  AD rr rr       lda LO_DIGIT
0006ACr 1  20 rr rr       jsr print_char
0006AFr 1  A9 20          lda #' '
0006B1r 1  20 rr rr       jsr print_char
0006B4r 1  A0 00          ldy #$00
0006B6r 1  B1 rr          lda (DUMP_POINTER),y
0006B8r 1  20 rr rr       jsr bintohex
0006BBr 1  AD rr rr       lda HI_DIGIT
0006BEr 1  20 rr rr       jsr print_char
0006C1r 1  AD rr rr       lda LO_DIGIT
0006C4r 1  20 rr rr       jsr print_char
0006C7r 1  A9 20          lda #' '
0006C9r 1  20 rr rr       jsr print_char
0006CCr 1  B1 rr          lda (DUMP_POINTER),y
0006CEr 1  20 rr rr       jsr print_char
0006D1r 1  A9 rr          lda #<splash
0006D3r 1  85 rr          sta MESSAGE_POINTER
0006D5r 1  A9 rr          lda #>splash
0006D7r 1  85 rr          sta MESSAGE_POINTER + 1
0006D9r 1  20 rr rr       jsr print3   ; add cursor after re-writing the address/data line
0006DCr 1  60             rts
0006DDr 1               
0006DDr 1               
0006DDr 1               
0006DDr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006DDr 1               ;;
0006DDr 1               ;;      display 8 bytes of data for a "block" of memory
0006DDr 1               ;;
0006DDr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006DDr 1               
0006DDr 1               block_address:
0006DDr 1               
0006DDr 1  20 rr rr       jsr lcd_clear
0006E0r 1  20 rr rr       jsr lcd_cursor_off
0006E3r 1  A9 rr          lda #<block_address_msg
0006E5r 1  85 rr          sta MESSAGE_POINTER
0006E7r 1  A9 rr          lda #>block_address_msg
0006E9r 1  85 rr          sta MESSAGE_POINTER + 1
0006EBr 1  20 rr rr       jsr print1
0006EEr 1  20 rr rr       jsr lcd_line_2
0006F1r 1  A0 00          ldy #$00
0006F3r 1  A9 24          lda #'$'
0006F5r 1  20 rr rr       jsr print_char
0006F8r 1  A5 rr          lda DUMP_POINTER + 1
0006FAr 1  20 rr rr       jsr bintohex
0006FDr 1  AD rr rr       lda HI_DIGIT
000700r 1  20 rr rr       jsr print_char
000703r 1  AD rr rr       lda LO_DIGIT
000706r 1  20 rr rr       jsr print_char
000709r 1  A5 rr          lda DUMP_POINTER
00070Br 1  20 rr rr       jsr bintohex
00070Er 1  AD rr rr       lda HI_DIGIT
000711r 1  20 rr rr       jsr print_char
000714r 1  AD rr rr       lda LO_DIGIT
000717r 1  20 rr rr       jsr print_char
00071Ar 1  20 rr rr       jsr lcd_line_3
00071Dr 1               loop1:
00071Dr 1  B1 rr          lda (DUMP_POINTER),y
00071Fr 1  20 rr rr       jsr bintohex
000722r 1  AD rr rr       lda HI_DIGIT
000725r 1  20 rr rr       jsr print_char
000728r 1  AD rr rr       lda LO_DIGIT
00072Br 1  20 rr rr       jsr print_char
00072Er 1  B1 rr          lda (DUMP_POINTER),y
000730r 1  C8             iny
000731r 1  C0 08          cpy #$08
000733r 1  D0 E8          bne loop1
000735r 1  A9 20          lda #' '
000737r 1  20 rr rr       jsr print_char
00073Ar 1  A9 48          lda #'H'
00073Cr 1  20 rr rr       jsr print_char
00073Fr 1  A9 65          lda #'e'
000741r 1  20 rr rr       jsr print_char
000744r 1  A9 78          lda #'x'
000746r 1  20 rr rr       jsr print_char
000749r 1  20 rr rr       jsr lcd_line_4
00074Cr 1  A0 00          ldy #$00
00074Er 1               loop2:
00074Er 1  A9 20          lda #$20
000750r 1  20 rr rr       jsr print_char
000753r 1  B1 rr          lda (DUMP_POINTER),y
000755r 1  20 rr rr       jsr print_char
000758r 1  C8             iny
000759r 1  C0 08          cpy #$08
00075Br 1  D0 F1          bne loop2
00075Dr 1  A9 20          lda #' '
00075Fr 1  20 rr rr       jsr print_char
000762r 1  A9 43          lda #'C'
000764r 1  20 rr rr       jsr print_char
000767r 1  A9 68          lda #'h'
000769r 1  20 rr rr       jsr print_char
00076Cr 1  A9 72          lda #'r'
00076Er 1  20 rr rr       jsr print_char
000771r 1  60             rts
000772r 1               
000772r 1               
000772r 1               
000772r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000772r 1               ;;
000772r 1               ;;      Monitor function - decrement the selected address
000772r 1               ;;
000772r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000772r 1               
000772r 1               decrement_address:
000772r 1               
000772r 1  38             sec
000773r 1  A5 rr          lda DUMP_POINTER
000775r 1  E9 01          sbc #$01
000777r 1  85 rr          sta DUMP_POINTER
000779r 1  8D rr rr       sta BYTE
00077Cr 1  A5 rr          lda DUMP_POINTER + 1
00077Er 1  E9 00          sbc #$00
000780r 1  85 rr          sta DUMP_POINTER + 1
000782r 1  8D rr rr       sta BYTE + 1
000785r 1  60             rts
000786r 1               
000786r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000786r 1               ;;
000786r 1               ;;      Monitor function - increment the selected address
000786r 1               ;;
000786r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000786r 1               
000786r 1               increment_address:
000786r 1               
000786r 1  18             clc
000787r 1  A5 rr          lda DUMP_POINTER
000789r 1  69 01          adc #$01
00078Br 1  85 rr          sta DUMP_POINTER
00078Dr 1  8D rr rr       sta BYTE
000790r 1  A5 rr          lda DUMP_POINTER + 1
000792r 1  69 00          adc #$00
000794r 1  85 rr          sta DUMP_POINTER + 1
000796r 1  8D rr rr       sta BYTE + 1
000799r 1  60             rts
00079Ar 1               
00079Ar 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00079Ar 1               ;;
00079Ar 1               ;;      Monitor function - increment the selected block of  addresses by 8
00079Ar 1               ;;
00079Ar 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00079Ar 1               
00079Ar 1               increment_block:
00079Ar 1               
00079Ar 1  18             clc
00079Br 1  A5 rr          lda DUMP_POINTER
00079Dr 1  69 08          adc #$08
00079Fr 1  85 rr          sta DUMP_POINTER
0007A1r 1  8D rr rr       sta BYTE
0007A4r 1  A5 rr          lda DUMP_POINTER + 1
0007A6r 1  69 00          adc #$00
0007A8r 1  85 rr          sta DUMP_POINTER + 1
0007AAr 1  8D rr rr       sta BYTE + 1
0007ADr 1  60             rts
0007AEr 1               
0007AEr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007AEr 1               ;;
0007AEr 1               ;;      Monitor function - decrement the selected block of  addresses by 8
0007AEr 1               ;;
0007AEr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007AEr 1               
0007AEr 1               decrement_block:
0007AEr 1               
0007AEr 1  38             sec
0007AFr 1  A5 rr          lda DUMP_POINTER
0007B1r 1  E9 08          sbc #$08
0007B3r 1  85 rr          sta DUMP_POINTER
0007B5r 1  8D rr rr       sta BYTE
0007B8r 1  A5 rr          lda DUMP_POINTER + 1
0007BAr 1  E9 00          sbc #$00
0007BCr 1  85 rr          sta DUMP_POINTER + 1
0007BEr 1  8D rr rr       sta BYTE + 1
0007C1r 1  60             rts
0007C2r 1               
0007C2r 1               
0007C2r 1               
0007C2r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007C2r 1               ;;
0007C2r 1               ;; use last 4 key presses (as hex bytes) to fill two BYTES
0007C2r 1               ;;
0007C2r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007C2r 1               
0007C2r 1               keys_byte:
0007C2r 1               
0007C2r 1  AD rr rr       lda KEY_PRESS + 1
0007C5r 1  0A             asl
0007C6r 1  0A             asl
0007C7r 1  0A             asl
0007C8r 1  0A             asl
0007C9r 1  8D rr rr       sta BYTE
0007CCr 1  AD rr rr       lda KEY_PRESS
0007CFr 1  0D rr rr       ora BYTE
0007D2r 1  8D rr rr       sta BYTE
0007D5r 1  AD rr rr       lda KEY_PRESS + 3
0007D8r 1  0A             asl
0007D9r 1  0A             asl
0007DAr 1  0A             asl
0007DBr 1  0A             asl
0007DCr 1  8D rr rr       sta BYTE + 1
0007DFr 1  AD rr rr       lda KEY_PRESS + 2
0007E2r 1  0D rr rr       ora BYTE + 1
0007E5r 1  8D rr rr       sta BYTE + 1
0007E8r 1  60             rts
0007E9r 1               
0007E9r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007E9r 1               ;;
0007E9r 1               ;;    toggle the display/update of Clock on each appropriate keypress
0007E9r 1               ;;
0007E9r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007E9r 1               
0007E9r 1               show_clock:
0007E9r 1               
0007E9r 1  DF rr 10       bbs5 FLAGS, reset_bit5
0007ECr 1  D7 rr          smb5 FLAGS
0007EEr 1  A9 rr          lda #<emt
0007F0r 1  85 rr          sta MESSAGE_POINTER
0007F2r 1  A9 rr          lda #>emt
0007F4r 1  85 rr          sta MESSAGE_POINTER + 1
0007F6r 1  20 rr rr       jsr print2_2
0007F9r 1  4C rr rr       jmp exit_show_clock
0007FCr 1               reset_bit5:
0007FCr 1  57 rr          rmb5 FLAGS
0007FEr 1  A9 rr          lda #<pause_msg
000800r 1  85 rr          sta MESSAGE_POINTER
000802r 1  A9 rr          lda #>pause_msg
000804r 1  85 rr          sta MESSAGE_POINTER + 1
000806r 1  20 rr rr       jsr print2_2
000809r 1               
000809r 1               exit_show_clock:
000809r 1  60             rts
00080Ar 1               
00080Ar 1               
00080Ar 1               
00080Ar 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00080Ar 1               ;;
00080Ar 1               ;;    toggle the automatic update view of the "8-byte memory block"
00080Ar 1               ;;
00080Ar 1               
00080Ar 1               show_block:
00080Ar 1               
00080Ar 1  8F rr 05       bbs0 FLAGS, reset_bit0
00080Dr 1  87 rr          smb0 FLAGS
00080Fr 1  4C rr rr       jmp exit_show_block
000812r 1               reset_bit0:
000812r 1  07 rr          rmb0 FLAGS
000814r 1               exit_show_block:
000814r 1  60             rts
000815r 1               
000815r 1               
000815r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000815r 1               ;;
000815r 1               ;;     toggle the scanning LED routine on VIA_3 Port B
000815r 1               ;;
000815r 1               
000815r 1               show_kitt:
000815r 1               
000815r 1  AF rr 05       bbs2 FLAGS, reset_bit2
000818r 1  A7 rr          smb2 FLAGS
00081Ar 1  4C rr rr       jmp exit_show_kitt
00081Dr 1               reset_bit2:
00081Dr 1  27 rr          rmb2 FLAGS
00081Fr 1               exit_show_kitt:
00081Fr 1  60             rts
000820r 1               
000820r 1               
000820r 1               
000820r 1               
000820r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000820r 1               ;;
000820r 1               ;;                     INTERRUPT HANDLERS
000820r 1               ;;
000820r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000820r 1               
000820r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000820r 1               ;;
000820r 1               ;;         reset & restart timer
000820r 1               ;;
000820r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000820r 1               
000820r 1               
000820r 1               reset_met:
000820r 1  64 rr          stz HUNDRED_HRS
000822r 1  64 rr          stz TEN_HRS
000824r 1  64 rr          stz TEN_MINUTES
000826r 1  64 rr          stz TEN_SECONDS
000828r 1  64 rr          stz HRS
00082Ar 1  64 rr          stz MINUTES
00082Cr 1  64 rr          stz SECONDS
00082Er 1  60             rts
00082Fr 1               
00082Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00082Fr 1               ;;
00082Fr 1               ;;                CB : TEST FUNCTIONS
00082Fr 1               ;;
00082Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00082Fr 1               cb1_handler:
00082Fr 1               
00082Fr 1  A9 04          lda #$04
000831r 1  20 rr rr       jsr beep_from_list
000834r 1  60             rts
000835r 1               
000835r 1               cb2_handler:
000835r 1               
000835r 1  A9 02          lda #$02 ; tone # = 100Hz
000837r 1  20 rr rr       jsr beep_from_list
00083Ar 1  60             rts
00083Br 1               
00083Br 1               
00083Br 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00083Br 1               ;;
00083Br 1               ;;                    MONITOR / KEYPAD
00083Br 1               ;;
00083Br 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00083Br 1               
00083Br 1               keypad_handler:
00083Br 1               
00083Br 1  20 rr rr       jsr get_key     ; READs from PORTA which also re-sets VIA's Interrupt flag
00083Er 1  8D rr rr       sta INKEY       ; put the byte value of input into RAM ( $00 )
000841r 1  AD 00 60       lda PORTB_1       ; check for SHIFT/INSTRUCTION button, 0=pressed, 1=not pressed
000844r 1  29 80          and #%10000000    ; zero (eq) when button pressed -> check_keypress, otherwise it's not zero, jmp to handle_new_char
000846r 1  F0 03          beq check_keypress ; done this way to get around the limit in size of branch jumps....
000848r 1  4C rr rr       jmp handle_new_char
00084Br 1               
00084Br 1               check_keypress:
00084Br 1               
00084Br 1  AD rr rr       lda INKEY
00084Er 1               
00084Er 1               ; choose action of "SHIFTed" key-press
00084Er 1               
00084Er 1               check_a:
00084Er 1               
00084Er 1  C9 0A          cmp #$0A
000850r 1                 ; move up one memory address and display contents
000850r 1  D0 09          bne check_b
000852r 1  20 rr rr       jsr increment_address
000855r 1  20 rr rr       jsr new_address
000858r 1  4C rr rr       jmp exit_key_irq
00085Br 1               
00085Br 1               check_b:
00085Br 1               
00085Br 1  C9 0B          cmp #$0B
00085Dr 1                 ; move down one memory address and display contents
00085Dr 1  D0 09          bne check_c
00085Fr 1  20 rr rr       jsr decrement_address
000862r 1  20 rr rr       jsr new_address
000865r 1  4C rr rr       jmp exit_key_irq
000868r 1               
000868r 1               check_c:
000868r 1               
000868r 1  C9 0C          cmp #$0C
00086Ar 1                 ; return to MONITOR
00086Ar 1  D0 13          bne check_d
00086Cr 1  07 rr          rmb0 FLAGS
00086Er 1  20 rr rr       jsr lcd_clear
000871r 1  A9 rr          lda #<splash
000873r 1  85 rr          sta MESSAGE_POINTER
000875r 1  A9 rr          lda #>splash
000877r 1  85 rr          sta MESSAGE_POINTER + 1
000879r 1  20 rr rr       jsr new_address
00087Cr 1  4C rr rr       jmp exit_key_irq
00087Fr 1               
00087Fr 1               check_d:
00087Fr 1               
00087Fr 1  C9 0D          cmp #$0D
000881r 1                 ; move monitor to entered 4-digit memory address
000881r 1  D0 10          bne check_e
000883r 1  AD rr rr       lda BYTE
000886r 1  85 rr          sta DUMP_POINTER
000888r 1  AD rr rr       lda BYTE + 1
00088Br 1  85 rr          sta DUMP_POINTER + 1
00088Dr 1  20 rr rr       jsr new_address
000890r 1  4C rr rr       jmp exit_key_irq
000893r 1               
000893r 1               check_e:
000893r 1               
000893r 1  C9 0E          cmp #$0E
000895r 1                 ; insert (POKE) byte of data in to current memory address, then increment to next address
000895r 1  D0 10          bne check_f
000897r 1  AD rr rr       lda BYTE
00089Ar 1  A0 00          ldy #$00
00089Cr 1  91 rr          sta (DUMP_POINTER),y
00089Er 1  20 rr rr       jsr new_address
0008A1r 1  20 rr rr       jsr beep
0008A4r 1  4C rr rr       jmp exit_key_irq
0008A7r 1               
0008A7r 1               check_f:
0008A7r 1               
0008A7r 1  C9 0F          cmp #$0F
0008A9r 1                 ; show 8-byte wide block of memory
0008A9r 1  D0 12          bne check_1
0008ABr 1  A0 00          ldy #$00
0008ADr 1  AD rr rr       lda BYTE
0008B0r 1  85 rr          sta DUMP_POINTER
0008B2r 1  AD rr rr       lda BYTE + 1
0008B5r 1  85 rr          sta DUMP_POINTER + 1
0008B7r 1  20 rr rr       jsr block_address
0008BAr 1  4C rr rr       jmp exit_key_irq
0008BDr 1               
0008BDr 1               check_1:
0008BDr 1               
0008BDr 1  C9 01          cmp #$01
0008BFr 1                 ; pause time display (clock still running)
0008BFr 1  D0 09          bne check_2
0008C1r 1  20 rr rr       jsr beep
0008C4r 1  20 rr rr       jsr show_clock
0008C7r 1  4C rr rr       jmp exit_key_irq
0008CAr 1               
0008CAr 1               check_2:
0008CAr 1               
0008CAr 1  C9 02          cmp #$02
0008CCr 1                 ; reset_clock
0008CCr 1  D0 09          bne check_3
0008CEr 1  20 rr rr       jsr beep
0008D1r 1  20 rr rr       jsr reset_met
0008D4r 1  4C rr rr       jmp exit_key_irq
0008D7r 1               
0008D7r 1               check_3:
0008D7r 1               
0008D7r 1  C9 03          cmp #$03
0008D9r 1  D0 0B          bne check_6
0008DBr 1  A0 00          ldy #$00
0008DDr 1  20 rr rr       jsr increment_block
0008E0r 1  20 rr rr       jsr block_address
0008E3r 1  4C rr rr       jmp exit_key_irq
0008E6r 1               
0008E6r 1               check_6:
0008E6r 1               
0008E6r 1  C9 06          cmp #$06
0008E8r 1  D0 0B          bne check_9
0008EAr 1  A0 00          ldy #$00
0008ECr 1  20 rr rr       jsr decrement_block
0008EFr 1  20 rr rr       jsr block_address
0008F2r 1  4C rr rr       jmp exit_key_irq
0008F5r 1               
0008F5r 1               check_9:
0008F5r 1               
0008F5r 1  C9 09          cmp #$09
0008F7r 1  D0 06          bne check_4
0008F9r 1  20 rr rr       jsr show_block
0008FCr 1  4C rr rr       jmp exit_key_irq
0008FFr 1               
0008FFr 1               check_4:
0008FFr 1               
0008FFr 1  C9 04          cmp #$04
000901r 1  D0 09          bne check_5
000903r 1  20 rr rr       jsr beep
000906r 1  20 rr rr       jsr show_kitt
000909r 1  4C rr rr       jmp exit_key_irq
00090Cr 1               
00090Cr 1               check_5:
00090Cr 1               
00090Cr 1  C9 05          cmp #$05
00090Er 1  D0 2A          bne exit_key_irq
000910r 1  20 rr rr       jsr beep2
000913r 1  20 00 3F       jsr $3F00
000916r 1  4C rr rr       jmp exit_key_irq
000919r 1               
000919r 1               
000919r 1               handle_new_char:
000919r 1               
000919r 1  AD rr rr       lda KEY_PRESS + 2
00091Cr 1  8D rr rr       sta KEY_PRESS + 3
00091Fr 1  AD rr rr       lda KEY_PRESS + 1
000922r 1  8D rr rr       sta KEY_PRESS + 2
000925r 1  AD rr rr       lda KEY_PRESS
000928r 1  8D rr rr       sta KEY_PRESS + 1
00092Br 1  AD rr rr       lda INKEY       ; get the new keypress value and...
00092Er 1  8D rr rr       sta KEY_PRESS
000931r 1  20 rr rr       jsr bintohex
000934r 1  20 rr rr       jsr print_char  ; and print it on LCD
000937r 1  20 rr rr       jsr keys_byte
00093Ar 1               
00093Ar 1               exit_key_irq:
00093Ar 1               
00093Ar 1  20 rr rr       jsr scan  ; re-enable keypad
00093Dr 1  60             rts
00093Er 1               
00093Er 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00093Er 1               
00093Er 1               nmi:
00093Er 1  48             pha
00093Fr 1  DA             phx
000940r 1  5A             phy
000941r 1               
000941r 1  2C 04 48       bit T1CL_3      ; reset interrupt flag
000944r 1  20 rr rr       jsr rtc
000947r 1  4C rr rr       jmp exit_nmi
00094Ar 1               
00094Ar 1               exit_nmi:
00094Ar 1  7A             ply
00094Br 1  FA             plx
00094Cr 1  68             pla
00094Dr 1  40             rti
00094Er 1               
00094Er 1  40             rti
00094Fr 1               
00094Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00094Fr 1               ;;
00094Fr 1               ;;    interrupt is triggered by HIGH edge on VIA CA1 pin
00094Fr 1               ;;     PORTA low nibble (keypad columns) inputs are diode ORed to CA1
00094Fr 1               ;;
00094Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00094Fr 1               
00094Fr 1               irq:
00094Fr 1               
00094Fr 1               ; put registers on the stack while handling the IRQ
00094Fr 1               
00094Fr 1  48             pha
000950r 1  DA             phx
000951r 1  5A             phy
000952r 1               
000952r 1               ;  find responsible hardware
000952r 1               
000952r 1               ;  Is it VIA_1?
000952r 1               
000952r 1  AD 0D 60       lda IFR_1       ; if IFR_1 has Bit7 set (ie sign=NEGATIVE) then it IS the source of the interrupt
000955r 1  10 25          bpl next_device ; if it's not set (ie sign=POSITIVE) then branch to test the next possible device
000957r 1               
000957r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000957r 1               ;;
000957r 1               ;; IFR Flags
000957r 1               ;; B7  B6  B5  B4  B3  B2  B1  B0
000957r 1               ;; IRQ TI1 TI2 CB1 CB2 SR CA1 CA2
000957r 1               ;;
000957r 1               ;; Interrupt source is found by sequentially shifting IFR bit left to put bit-of-interest into the CARRY place
000957r 1               ;; and then branching based on whether CARRY is SET or not
000957r 1               ;;
000957r 1               ;; Only add tests for IRQ sources in use, and adjust the ASLs in each test as necessary
000957r 1               ;;
000957r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000957r 1               
000957r 1               test_cb1:
000957r 1  0A             asl
000958r 1  0A             asl
000959r 1  0A             asl
00095Ar 1  0A             asl
00095Br 1  90 09          bcc test_cb2
00095Dr 1  2C 00 60       bit PORTB_1
000960r 1  20 rr rr       jsr cb1_handler
000963r 1  4C rr rr       jmp exit_irq
000966r 1               
000966r 1               test_cb2:
000966r 1  0A             asl
000967r 1  90 09          bcc test_ca1
000969r 1  2C 00 60       bit PORTB_1
00096Cr 1  20 rr rr       jsr cb2_handler
00096Fr 1  4C rr rr       jmp exit_irq
000972r 1               
000972r 1               test_ca1:
000972r 1               
000972r 1  0A             asl           ; shift CA1 bit into the CARRY bit & test
000973r 1  0A             asl
000974r 1  90 06          bcc exit_irq        ; carry clear = leave
000976r 1  20 rr rr       jsr keypad_handler  ; carry not clear = handle the CA1 interrupt (keypad)
000979r 1  4C rr rr       jmp exit_irq
00097Cr 1               
00097Cr 1               
00097Cr 1               next_device:
00097Cr 1               
00097Cr 1               exit_irq:
00097Cr 1               
00097Cr 1  7A             ply
00097Dr 1  FA             plx
00097Er 1  68             pla
00097Fr 1  40             rti
000980r 1               
000980r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000980r 1               ;;
000980r 1               ;;      String and data byte variables
000980r 1               ;;
000980r 1               ;;
000980r 1               ;;
000980r 1               
000980r 1  4D 61 72 6B  pause_msg: .asciiz "Mark Time     "
000984r 1  20 54 69 6D  
000988r 1  65 20 20 20  
00098Fr 1  3C 73 68 69  start_msg: .asciiz "<shift>+C to start"
000993r 1  66 74 3E 2B  
000997r 1  43 20 74 6F  
0009A2r 1  56 69 65 77  new_address_msg: .asciiz "View/Edit Memory"
0009A6r 1  2F 45 64 69  
0009AAr 1  74 20 4D 65  
0009B3r 1  38 20 42 79  block_address_msg: .asciiz "8 Byte view"
0009B7r 1  74 65 20 76  
0009BBr 1  69 65 77 00  
0009BFr 1  2E 2E 2E 53  title: .asciiz "...Shed Brain v1..."
0009C3r 1  68 65 64 20  
0009C7r 1  42 72 61 69  
0009D3r 1  53 68 65 64  emt: .asciiz "Shed Time  MET"
0009D7r 1  20 54 69 6D  
0009DBr 1  65 20 20 4D  
0009E2r 1  73 68 65 64  splash: .asciiz "shed> "
0009E6r 1  3E 20 00     
0009E9r 1  42 65 67 69  mem_start_msg: .asciiz "Begin RAM Test"
0009EDr 1  6E 20 52 41  
0009F1r 1  4D 20 54 65  
0009F8r 1  52 41 4D 20  mem_pass_msg: .asciiz "RAM Test Pass"
0009FCr 1  54 65 73 74  
000A00r 1  20 50 61 73  
000A06r 1  52 41 4D 20  mem_fail_msg_1: .asciiz "RAM Test 1 Fail"
000A0Ar 1  54 65 73 74  
000A0Er 1  20 31 20 46  
000A16r 1  52 41 4D 20  mem_fail_msg_2: .asciiz "RAM Test 2 Fail"
000A1Ar 1  54 65 73 74  
000A1Er 1  20 32 20 46  
000A26r 1               
000A26r 1  54 68 69 73  userPrompt: .asciiz "This is shed! "
000A2Ar 1  20 69 73 20  
000A2Er 1  73 68 65 64  
000A35r 1               
000A35r 1  64 rr A9 20  userProg: .byte $64, MESSAGE_POINTER, $A9, $20, $85, MESSAGE_POINTER + 1, $20, <print4, >print4, $60, $00
000A39r 1  85 rr 20 rr  
000A3Dr 1  rr 60 00     
000A40r 1               
000A40r 1  01 03 06 0C  kitLeds: .byte $01, $03, $06, $0C, $18, $30, $60, $C0, $80, $C0, $60, $30, $18, $0C, $06, $03, $01
000A44r 1  18 30 60 C0  
000A48r 1  80 C0 60 30  
000A51r 1               
000A51r 1               
000A51r 1               ; Reset/IRQ vectors
000A51r 1               
000A51r 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr          .word nmi
000002r 1  rr rr          .word reset
000004r 1  rr rr          .word irq
000004r 1               
