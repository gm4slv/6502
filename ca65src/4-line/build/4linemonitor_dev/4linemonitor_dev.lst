ca65 V2.18 - Debian 2.19-1
Main file   : 4linemonitor_dev.s
Current file: 4linemonitor_dev.s

000000r 1               ;;
000000r 1               ;; DEV updates:
000000r 1               ;;
000000r 1               ;;1) pre-load USER MEM @ user_ram
000000r 1               ;;
000000r 1               ;;2) set new VIAs for OUTPUT on both ports A & B
000000r 1               ;;
000000r 1               ;;3) TESTING new VIAS with flashing LEDs on all ports
000000r 1               ;;
000000r 1               ;;4) Add second LCD on VIA_2 PORTA_2 ?
000000r 1               
000000r 1               .zeropage
000000r 1               
000000r 1  xx xx        DUMP_POINTER:     .res 2
000002r 1  xx           FLAGS:            .res 1
000003r 1  xx           TOGGLE_TIME:      .res 1
000004r 1  xx           CLOCK_LAST:       .res 1
000005r 1  xx xx        MESSAGE_POINTER:  .res 2
000007r 1  xx xx xx xx  TICKS:            .res 4
00000Br 1  xx           CENTISEC:         .res 1
00000Cr 1  xx           HUNDRED_HRS:      .res 1
00000Dr 1  xx           TEN_HRS:          .res 1
00000Er 1  xx           HRS:              .res 1
00000Fr 1  xx           TEN_MINUTES:      .res 1
000010r 1  xx           MINUTES:          .res 1
000011r 1  xx           TEN_SECONDS:      .res 1
000012r 1  xx           SECONDS:          .res 1
000013r 1  xx xx        MEM_POINTER:      .res 2
000015r 1  xx           LED2_LAST:        .res 1
000016r 1  xx           LED3_LAST:        .res 1
000017r 1  xx           LAST_KIT:         .res 1
000018r 1               
000018r 1               .bss
000000r 1               
000000r 1  xx           INKEY:            .res 1
000001r 1  xx xx xx xx  KEY_PRESS:        .res 4
000005r 1  xx xx        BYTE:             .res 2
000007r 1  xx           TENS:             .res 1
000008r 1  xx           HUNDREDS:         .res 1
000009r 1  xx xx        HEX:              .res 2
00000Br 1  xx xx        HEXB:             .res 2
00000Dr 1  xx           TEMP:             .res 1
00000Er 1  xx           TEMP2:            .res 1
00000Fr 1  xx           HI_DIGIT:         .res 1
000010r 1  xx           LO_DIGIT:         .res 1
000011r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000011r 1               ;;
000011r 1               ;;        INCLUDES
000011r 1               ;;
000011r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000011r 1               
000011r 1               .include "../includes/ioports.inc"
000011r 2               
000011r 2                 .code
000000r 2               
000000r 2               ; VIA_1 Port addresses
000000r 2               VIA_1     = $6000
000000r 2               PORTB_1   = VIA_1
000000r 2               PORTA_1   = VIA_1 + 1
000000r 2               DDRB_1    = VIA_1 + 2
000000r 2               DDRA_1    = VIA_1 + 3
000000r 2               T1CL_1    = VIA_1 + 4
000000r 2               T1CH_1    = VIA_1 + 5
000000r 2               T1LL_1    = VIA_1 + 6
000000r 2               T1LH_1    = VIA_1 + 7
000000r 2               T2CL_1    = VIA_1 + 8
000000r 2               T2CH_1    = VIA_1 + 9
000000r 2               SR_1      = VIA_1 + 10
000000r 2               ACR_1     = VIA_1 + 11
000000r 2               PCR_1     = VIA_1 + 12
000000r 2               IFR_1     = VIA_1 + 13
000000r 2               IER_1     = VIA_1 + 14
000000r 2               PORTA_NO_HS_1 = VIA_1 + 15
000000r 2               
000000r 2               ; VIA_2 Port addresses
000000r 2               VIA_2     = $5000
000000r 2               PORTB_2   = VIA_2
000000r 2               PORTA_2   = VIA_2 + 1
000000r 2               DDRB_2    = VIA_2 + 2
000000r 2               DDRA_2    = VIA_2 + 3
000000r 2               T1CL_2    = VIA_2 + 4
000000r 2               T1CH_2    = VIA_2 + 5
000000r 2               T1LL_2    = VIA_2 + 6
000000r 2               T1LH_2    = VIA_2 + 7
000000r 2               T2CL_2    = VIA_2 + 8
000000r 2               T2CH_2    = VIA_2 + 9
000000r 2               SR_2      = VIA_2 + 10
000000r 2               ACR_2     = VIA_2 + 11
000000r 2               PCR_2     = VIA_2 + 12
000000r 2               IFR_2     = VIA_2 + 13
000000r 2               IER_2     = VIA_2 + 14
000000r 2               PORTA_NO_HS_2 = VIA_2 + 15
000000r 2               
000000r 2               ; VIA_3 Port addresses
000000r 2               VIA_3     = $4800
000000r 2               PORTB_3   = VIA_3
000000r 2               PORTA_3   = VIA_3 + 1
000000r 2               DDRB_3    = VIA_3 + 2
000000r 2               DDRA_3    = VIA_3 + 3
000000r 2               T1CL_3    = VIA_3 + 4
000000r 2               T1CH_3    = VIA_3 + 5
000000r 2               T1LL_3    = VIA_3 + 6
000000r 2               T1LH_3    = VIA_3 + 7
000000r 2               T2CL_3    = VIA_3 + 8
000000r 2               T2CH_3    = VIA_3 + 9
000000r 2               SR_3      = VIA_3 + 10
000000r 2               ACR_3     = VIA_3 + 11
000000r 2               PCR_3     = VIA_3 + 12
000000r 2               IFR_3     = VIA_3 + 13
000000r 2               IER_3     = VIA_3 + 14
000000r 2               PORTA_NO_HS_3 = VIA_3 + 15
000000r 2               
000000r 2               ; ACIA_1 Port Addresses
000000r 2               ACIA_1    = $4400
000000r 2               S_TXRX_1  = ACIA_1      ; TXD / RXD
000000r 2               S_STA_1   = ACIA_1 + 1  ; Status
000000r 2               S_COM_1   = ACIA_1 + 2  ; Command
000000r 2               S_CON_1   = ACIA_1 + 3  ; Control
000000r 2               
000000r 2               
000000r 2               via_1_init:
000000r 2               
000000r 2                 ;lda #%01000000
000000r 2                 ;sta ACR_1
000000r 2                 ;lda #$0E
000000r 2                 ;sta T1CL_1
000000r 2                 ;lda #$27
000000r 2                 ;sta T1CH_1
000000r 2               
000000r 2  A9 9A          lda #%10011010  ; , CA1 active
000002r 2  8D 0E 60       sta IER_1
000005r 2               
000005r 2  A9 01          lda #$01  ;  CA1 active high-transition
000007r 2  8D 0C 60       sta PCR_1
00000Ar 2               
00000Ar 2  A9 7F          lda #%01111111 ; Set all pins on port B to output except BIT 7 which is used for "SHIFT/INSTRUCTION"  button
00000Cr 2  8D 02 60       sta DDRB_1
00000Fr 2  A9 F0          lda #%11110000 ; Set low-nibble pins on port A to input and high-nibble pins to output, for keypad
000011r 2  8D 03 60       sta DDRA_1
000014r 2               
000014r 2  60             rts
000015r 2               
000015r 2               via_2_init:
000015r 2               
000015r 2  A9 C0          lda #%11000000
000017r 2  8D 0B 50       sta ACR_2
00001Ar 2  A9 F2          lda #$F2
00001Cr 2  8D 04 50       sta T1CL_2
00001Fr 2  A9 01          lda #$01
000021r 2  8D 05 50       sta T1CH_2
000024r 2               
000024r 2  A9 FF          lda #%11111111 ; set all pins on port A & B to output
000026r 2  8D 03 50       sta DDRA_2
000029r 2  8D 02 50       sta DDRB_2
00002Cr 2  A9 00          lda #%00000000
00002Er 2  8D 0E 50       sta IER_2
000031r 2  60             rts
000032r 2               
000032r 2               via_3_init:
000032r 2               
000032r 2  A9 40          lda #%01000000
000034r 2  8D 0B 48       sta ACR_3
000037r 2  A9 0E          lda #$0E
000039r 2  8D 04 48       sta T1CL_3
00003Cr 2  A9 27          lda #$27
00003Er 2  8D 05 48       sta T1CH_3
000041r 2               
000041r 2  A9 C0          lda #%11000000  ; T1, CA1 active
000043r 2  8D 0E 48       sta IER_3
000046r 2               
000046r 2  A9 FF          lda #%11111111 ; set all pins on port A & B to output
000048r 2  8D 03 48       sta DDRA_3
00004Br 2  8D 02 48       sta DDRB_3
00004Er 2  A9 00          lda #%00000000
000050r 2  8D 0E 48       sta IER_3
000053r 2               
000053r 2  60             rts
000054r 2               
000054r 2               
000054r 2               
000054r 2               
000054r 1               .include "../includes/lcd.inc"
000054r 2               
000054r 2               
000054r 2                 .code
000054r 2               
000054r 2               ; LCD Command masks
000054r 2               E  = %01000000
000054r 2               RW = %00100000
000054r 2               RS = %00010000
000054r 2               
000054r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000054r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000054r 2               ;;
000054r 2               ;;
000054r 2               ;;                              LCD Functions
000054r 2               ;;
000054r 2               ;;
000054r 2               ;;
000054r 2               
000054r 2               lcd_start:
000054r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000056r 2  20 rr rr       jsr lcd_instruction
000059r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00005Br 2  20 rr rr       jsr lcd_instruction
00005Er 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000060r 2  20 rr rr       jsr lcd_instruction
000063r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000065r 2  20 rr rr       jsr lcd_instruction
000068r 2  20 rr rr       jsr lcd_entry_mode
00006Br 2  20 rr rr       jsr lcd_cursor_off
00006Er 2  20 rr rr       jsr lcd_clear
000071r 2                 ;jsr lcd_add0
000071r 2  60             rts
000072r 2               
000072r 2               lcd_entry_mode:
000072r 2  A9 06          lda #%00000110 ; Increment and shift cursor; don't shift display
000074r 2  20 rr rr       jsr lcd_instruction
000077r 2  60             rts
000078r 2               
000078r 2               lcd_home:
000078r 2  A9 02          lda #%00000010 ; cursor HOME
00007Ar 2  20 rr rr       jsr lcd_instruction
00007Dr 2  60             rts
00007Er 2               
00007Er 2               lcd_add0:
00007Er 2  A9 80          lda #%10000000 ; back to zero position
000080r 2  20 rr rr       jsr lcd_instruction
000083r 2  60             rts
000084r 2               
000084r 2               lcd_clear:
000084r 2  A9 01          lda #%00000001 ; Clear display
000086r 2  20 rr rr       jsr lcd_instruction
000089r 2  60             rts
00008Ar 2               
00008Ar 2               lcd_cursor_off:
00008Ar 2  A9 0C          lda #%00001100 ; Display on; cursor off; blink off
00008Cr 2  20 rr rr       jsr lcd_instruction
00008Fr 2  60             rts
000090r 2               
000090r 2               lcd_cursor_on:
000090r 2  A9 0F          lda #%00001111 ; Display on; cursor on; blink on
000092r 2  20 rr rr       jsr lcd_instruction
000095r 2  60             rts
000096r 2               
000096r 2               lcd_line_1:
000096r 2  A9 80          lda #($80)
000098r 2  20 rr rr       jsr lcd_instruction
00009Br 2  60             rts
00009Cr 2               
00009Cr 2               lcd_line_2:
00009Cr 2  A9 C0          lda #($80 + $40)
00009Er 2  20 rr rr       jsr lcd_instruction
0000A1r 2  60             rts
0000A2r 2               
0000A2r 2               lcd_line_3:
0000A2r 2  A9 94          lda #($80 + $14)
0000A4r 2  20 rr rr       jsr lcd_instruction
0000A7r 2  60             rts
0000A8r 2               
0000A8r 2               lcd_line_4:
0000A8r 2  A9 D4          lda #($80 + $54)
0000AAr 2  20 rr rr       jsr lcd_instruction
0000ADr 2  60             rts
0000AEr 2               
0000AEr 2               lcd_wait:
0000AEr 2  48             pha
0000AFr 2  A9 70          lda #%01110000  ; LCD data is input (don't change MSB BIT7, it has to stay ZERO for SHIFT Button input)
0000B1r 2  8D 02 60       sta DDRB_1
0000B4r 2               lcdbusy:
0000B4r 2  A9 20          lda #RW
0000B6r 2  8D 00 60       sta PORTB_1
0000B9r 2  A9 60          lda #(RW | E)
0000BBr 2  8D 00 60       sta PORTB_1
0000BEr 2  AD 00 60       lda PORTB_1     ; Read high nibble
0000C1r 2  48             pha             ; and put on stack since it has the busy flag
0000C2r 2  A9 20          lda #RW
0000C4r 2  8D 00 60       sta PORTB_1
0000C7r 2  A9 60          lda #(RW | E)
0000C9r 2  8D 00 60       sta PORTB_1
0000CCr 2  AD 00 60       lda PORTB_1       ; Read low nibble
0000CFr 2  68             pla             ; Get high nibble off stack
0000D0r 2  29 08          and #%00001000
0000D2r 2  D0 E0          bne lcdbusy
0000D4r 2               
0000D4r 2  A9 20          lda #RW
0000D6r 2  8D 00 60       sta PORTB_1
0000D9r 2  A9 7F          lda #%01111111  ; LCD data is output (don't change MSB BIT7, it has to stay ZERO for SHIFT Buttion input)
0000DBr 2  8D 02 60       sta DDRB_1
0000DEr 2  68             pla
0000DFr 2  60             rts
0000E0r 2               
0000E0r 2               lcd_init:
0000E0r 2  A9 02          lda #%00000010 ; Set 4-bit mode : DO ONCE AT POWER UP
0000E2r 2  8D 00 60       sta PORTB_1
0000E5r 2  09 40          ora #E
0000E7r 2  8D 00 60       sta PORTB_1
0000EAr 2  29 0F          and #%00001111
0000ECr 2  8D 00 60       sta PORTB_1
0000EFr 2  60             rts
0000F0r 2               
0000F0r 2               lcd_instruction:
0000F0r 2  20 rr rr       jsr lcd_wait
0000F3r 2  48             pha
0000F4r 2  4A             lsr
0000F5r 2  4A             lsr
0000F6r 2  4A             lsr
0000F7r 2  4A             lsr            ; Send high 4 bits
0000F8r 2  8D 00 60       sta PORTB_1
0000FBr 2  09 40          ora #E         ; Set E bit to send instruction
0000FDr 2  8D 00 60       sta PORTB_1
000100r 2  49 40          eor #E         ; Clear E bit
000102r 2  8D 00 60       sta PORTB_1
000105r 2  68             pla
000106r 2  29 0F          and #%00001111 ; Send low 4 bits
000108r 2  8D 00 60       sta PORTB_1
00010Br 2  09 40          ora #E         ; Set E bit to send instruction
00010Dr 2  8D 00 60       sta PORTB_1
000110r 2  49 40          eor #E         ; Clear E bit
000112r 2  8D 00 60       sta PORTB_1
000115r 2  60             rts
000116r 2               
000116r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000116r 2               ;;
000116r 2               ;;        PRINT Characters on LCD - an ASCII value in Accumulator
000116r 2               ;;        is printed on the display
000116r 2               ;;
000116r 2               
000116r 2               print_char:
000116r 2  20 rr rr       jsr lcd_wait
000119r 2  48             pha
00011Ar 2  4A             lsr
00011Br 2  4A             lsr
00011Cr 2  4A             lsr
00011Dr 2  4A             lsr             ; Send high 4 bits
00011Er 2  09 10          ora #RS         ; Set RS
000120r 2  8D 00 60       sta PORTB_1
000123r 2  09 40          ora #E          ; Set E bit to send instruction
000125r 2  8D 00 60       sta PORTB_1
000128r 2  49 40          eor #E          ; Clear E bit
00012Ar 2  8D 00 60       sta PORTB_1
00012Dr 2  68             pla
00012Er 2  29 0F          and #%00001111  ; Send low 4 bits
000130r 2  09 10          ora #RS         ; Set RS
000132r 2  8D 00 60       sta PORTB_1
000135r 2  09 40          ora #E          ; Set E bit to send instruction
000137r 2  8D 00 60       sta PORTB_1
00013Ar 2  49 40          eor #E          ; Clear E bit
00013Cr 2  8D 00 60       sta PORTB_1
00013Fr 2  60             rts
000140r 2               
000140r 2               
000140r 1               .include "../includes/lcd_2.inc"
000140r 2               
000140r 2               
000140r 2                 .code
000140r 2               
000140r 2               ; LCD Command masks
000140r 2               ;E  = %01000000
000140r 2               ;RW = %00100000
000140r 2               ;RS = %00010000
000140r 2               
000140r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000140r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000140r 2               ;;
000140r 2               ;;
000140r 2               ;;                              LCD Functions
000140r 2               ;;
000140r 2               ;;
000140r 2               ;;
000140r 2               
000140r 2               lcd_2_start:
000140r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000142r 2  20 rr rr       jsr lcd_2_instruction
000145r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000147r 2  20 rr rr       jsr lcd_2_instruction
00014Ar 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00014Cr 2  20 rr rr       jsr lcd_2_instruction
00014Fr 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000151r 2  20 rr rr       jsr lcd_2_instruction
000154r 2  20 rr rr       jsr lcd_2_entry_mode
000157r 2  20 rr rr       jsr lcd_2_cursor_off
00015Ar 2  20 rr rr       jsr lcd_2_clear
00015Dr 2                 ;jsr lcd_add0
00015Dr 2  60             rts
00015Er 2               
00015Er 2               lcd_2_entry_mode:
00015Er 2  A9 06          lda #%00000110 ; Increment and shift cursor; don't shift display
000160r 2  20 rr rr       jsr lcd_2_instruction
000163r 2  60             rts
000164r 2               
000164r 2               lcd_2_home:
000164r 2  A9 02          lda #%00000010 ; cursor HOME
000166r 2  20 rr rr       jsr lcd_2_instruction
000169r 2  60             rts
00016Ar 2               
00016Ar 2               lcd_2_add0:
00016Ar 2  A9 80          lda #%10000000 ; back to zero position
00016Cr 2  20 rr rr       jsr lcd_2_instruction
00016Fr 2  60             rts
000170r 2               
000170r 2               lcd_2_clear:
000170r 2  A9 01          lda #%00000001 ; Clear display
000172r 2  20 rr rr       jsr lcd_2_instruction
000175r 2  60             rts
000176r 2               
000176r 2               lcd_2_cursor_off:
000176r 2  A9 0C          lda #%00001100 ; Display on; cursor off; blink off
000178r 2  20 rr rr       jsr lcd_2_instruction
00017Br 2  60             rts
00017Cr 2               
00017Cr 2               lcd_2_cursor_on:
00017Cr 2  A9 0F          lda #%00001111 ; Display on; cursor on; blink on
00017Er 2  20 rr rr       jsr lcd_2_instruction
000181r 2  60             rts
000182r 2               
000182r 2               lcd_2_line_1:
000182r 2  A9 80          lda #($80)
000184r 2  20 rr rr       jsr lcd_2_instruction
000187r 2  60             rts
000188r 2               
000188r 2               lcd_2_line_2:
000188r 2  A9 C0          lda #($80 + $40)
00018Ar 2  20 rr rr       jsr lcd_2_instruction
00018Dr 2  60             rts
00018Er 2               
00018Er 2               ;lcd_line_3:
00018Er 2               ;  lda #($80 + $14)
00018Er 2               ;  jsr lcd_instruction
00018Er 2               ;  rts
00018Er 2               
00018Er 2               ;lcd_line_4:
00018Er 2               ;  lda #($80 + $54)
00018Er 2               ;  jsr lcd_instruction
00018Er 2               ;  rts
00018Er 2               
00018Er 2               lcd_2_wait:
00018Er 2  48             pha
00018Fr 2  A9 70          lda #%01110000  ; LCD data is input (don't change MSB BIT7, it has to stay ZERO for SHIFT Button input)
000191r 2  8D 03 48       sta DDRA_3
000194r 2               
000194r 2               lcdbusy2:
000194r 2  A9 20          lda #RW
000196r 2  8D 01 48       sta PORTA_3
000199r 2  A9 60          lda #(RW | E)
00019Br 2  8D 01 48       sta PORTA_3
00019Er 2  AD 01 48       lda PORTA_3     ; Read high nibble
0001A1r 2  48             pha             ; and put on stack since it has the busy flag
0001A2r 2  A9 20          lda #RW
0001A4r 2  8D 01 48       sta PORTA_3
0001A7r 2  A9 60          lda #(RW | E)
0001A9r 2  8D 01 48       sta PORTA_3
0001ACr 2  AD 01 48       lda PORTA_3       ; Read low nibble
0001AFr 2  68             pla             ; Get high nibble off stack
0001B0r 2  29 08          and #%00001000
0001B2r 2  D0 E0          bne lcdbusy2
0001B4r 2               
0001B4r 2  A9 20          lda #RW
0001B6r 2  8D 01 48       sta PORTA_3
0001B9r 2  A9 7F          lda #%01111111  ; LCD data is output (don't change MSB BIT7, it has to stay ZERO for SHIFT Buttion input)
0001BBr 2  8D 03 48       sta DDRA_3
0001BEr 2  68             pla
0001BFr 2  60             rts
0001C0r 2               
0001C0r 2               lcd_2_init:
0001C0r 2  A9 02          lda #%00000010 ; Set 4-bit mode : DO ONCE AT POWER UP
0001C2r 2  8D 01 48       sta PORTA_3
0001C5r 2  09 40          ora #E
0001C7r 2  8D 01 48       sta PORTA_3
0001CAr 2  29 0F          and #%00001111
0001CCr 2  8D 01 48       sta PORTA_3
0001CFr 2  60             rts
0001D0r 2               
0001D0r 2               lcd_2_instruction:
0001D0r 2  20 rr rr       jsr lcd_2_wait
0001D3r 2  48             pha
0001D4r 2  4A             lsr
0001D5r 2  4A             lsr
0001D6r 2  4A             lsr
0001D7r 2  4A             lsr            ; Send high 4 bits
0001D8r 2  8D 01 48       sta PORTA_3
0001DBr 2  09 40          ora #E         ; Set E bit to send instruction
0001DDr 2  8D 01 48       sta PORTA_3
0001E0r 2  49 40          eor #E         ; Clear E bit
0001E2r 2  8D 01 48       sta PORTA_3
0001E5r 2  68             pla
0001E6r 2  29 0F          and #%00001111 ; Send low 4 bits
0001E8r 2  8D 01 48       sta PORTA_3
0001EBr 2  09 40          ora #E         ; Set E bit to send instruction
0001EDr 2  8D 01 48       sta PORTA_3
0001F0r 2  49 40          eor #E         ; Clear E bit
0001F2r 2  8D 01 48       sta PORTA_3
0001F5r 2  60             rts
0001F6r 2               
0001F6r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0001F6r 2               ;;
0001F6r 2               ;;        PRINT Characters on LCD - an ASCII value in Accumulator
0001F6r 2               ;;        is printed on the display
0001F6r 2               ;;
0001F6r 2               
0001F6r 2               print_2_char:
0001F6r 2  20 rr rr       jsr lcd_2_wait
0001F9r 2  48             pha
0001FAr 2  4A             lsr
0001FBr 2  4A             lsr
0001FCr 2  4A             lsr
0001FDr 2  4A             lsr             ; Send high 4 bits
0001FEr 2  09 10          ora #RS         ; Set RS
000200r 2  8D 01 48       sta PORTA_3
000203r 2  09 40          ora #E          ; Set E bit to send instruction
000205r 2  8D 01 48       sta PORTA_3
000208r 2  49 40          eor #E          ; Clear E bit
00020Ar 2  8D 01 48       sta PORTA_3
00020Dr 2  68             pla
00020Er 2  29 0F          and #%00001111  ; Send low 4 bits
000210r 2  09 10          ora #RS         ; Set RS
000212r 2  8D 01 48       sta PORTA_3
000215r 2  09 40          ora #E          ; Set E bit to send instruction
000217r 2  8D 01 48       sta PORTA_3
00021Ar 2  49 40          eor #E          ; Clear E bit
00021Cr 2  8D 01 48       sta PORTA_3
00021Fr 2  60             rts
000220r 2               
000220r 2               
000220r 1               .include "../includes/getkey.inc"
000220r 2               
000220r 2                 .code
000220r 2               
000220r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000220r 2               ;;
000220r 2               ;;
000220r 2               ;;      READ THE 4x4 keypad using  VIA_1 PORTA
000220r 2               ;;
000220r 2               ;;      Accumulator holds the ASCII value of the pressed key when it returns
000220r 2               ;;
000220r 2               
000220r 2               get_key:
000220r 2               readKeypad:
000220r 2  A2 04          ldx #$04        ; Row 4 - counting down
000222r 2  A0 80          ldy #%10000000  ;
000224r 2               ScanRow:
000224r 2  8C 01 60       sty PORTA_1
000227r 2  AD 01 60       lda PORTA_1
00022Ar 2  29 0F          and #%00001111  ; mask off keypad input - only low 4 (keypad column) bits are read
00022Cr 2  C9 00          cmp #$00
00022Er 2  D0 0B          bne Row_Found   ; non-zero means a row output has been connected via a switch to a column input
000230r 2  CA             dex             ; zero means it hasn't been found, so check next row down
000231r 2  98             tya
000232r 2  4A             lsr
000233r 2  A8             tay
000234r 2  C9 08          cmp #%00001000
000236r 2  D0 EC          bne ScanRow
000238r 2  A9 FF          lda #$ff
00023Ar 2  60             rts
00023Br 2               Row_Found:
00023Br 2  8E rr rr       stx TEMP ; store row
00023Er 2  A0 FF          ldy #$ff
000240r 2               FindCol:
000240r 2  C8             iny
000241r 2  4A             lsr
000242r 2  90 FC          bcc FindCol
000244r 2  98             tya
000245r 2  0A             asl
000246r 2  0A             asl  ; col * 4
000247r 2  18             clc
000248r 2  6D rr rr       adc TEMP ; add row
00024Br 2  AA             tax
00024Cr 2  BD rr rr       lda keypad_array,x
00024Fr 2  60             rts
000250r 2               
000250r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000250r 2               ;;
000250r 2               ;;       key = <INDEX> ; pressing a key returns a 4-bit number
000250r 2               ;;       calculated as (Column * 4 ) + Row, in the range
000250r 2               ;;       1 - 16 which acts as an index to a lookup-table.
000250r 2               ;;       The lookup table returns a byte value equal to the key's
000250r 2               ;;       numerical value
000250r 2               ;;       e.g.
000250r 2               ;;       button 1 returns byte $01 / 00000001
000250r 2               ;;       button F returns byte $0f / 00001111
000250r 2               ;;    ____________________________________________________
000250r 2               ;;   |     1 = <16> | 2 = <12> |    3 = <8> | A(10) = <4> |
000250r 2               ;;   |______________|__________|____________|_____________|
000250r 2               ;;   |     4 = <15> | 5 = <11> |    6 = <7> | B(11) = <3> |
000250r 2               ;;   |______________|__________|____________|_____________|
000250r 2               ;;   |     7 = <14> | 8 = <10> |    9 = <6> | C(12) = <2> |
000250r 2               ;;   |______________|__________|____________|_____________|
000250r 2               ;;   | E(14) = <13> | 0 = <9>  | F(15)= <5> | D(13) = <1> |
000250r 2               ;;   |______________|__________|____________|_____________|
000250r 2               ;;
000250r 2               ;;            Button  ..   D    C    B    A    F    9    6    3    0    8    5    2    E    7    4    1
000250r 2               ;;            <INDEX> 0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16
000250r 2  00 0D 0C 0B  keypad_array: .byte $00, $0D, $0C, $0B, $0A, $0F, $09, $06, $03, $00, $08, $05, $02, $0E, $07, $04, $01
000254r 2  0A 0F 09 06  
000258r 2  03 00 08 05  
000261r 2               
000261r 2               
000261r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000261r 2               ;;
000261r 2               ;;  set ROW keypad outputs high as a source for triggering interrupt when a key is pressed
000261r 2               ;;
000261r 2               ;;
000261r 2               scan:
000261r 2  A0 F0          ldy #%11110000
000263r 2  8C 01 60       sty PORTA_1
000266r 2  60             rts
000267r 2               
000267r 2               
000267r 1               .include "../includes/functions.inc"
000267r 2               
000267r 2               
000267r 2                 .code
000267r 2               
000267r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000267r 2               ;;
000267r 2               ;;          convert an 8-bit binary number from Accumulator, in range 00000000 -> 11111111 ($00 to $FF)
000267r 2               ;;          to its HEX number encode as ASCII -  using a simple lookup table. Store each digit in RAM. Accumulator
000267r 2               ;;          holds the last/low digit on return.
000267r 2               ;;
000267r 2               
000267r 2               
000267r 2               bintohex:
000267r 2  48             pha
000268r 2  4A             lsr
000269r 2  4A             lsr
00026Ar 2  4A             lsr
00026Br 2  4A             lsr
00026Cr 2  AA             tax
00026Dr 2  BD rr rr       lda hexascii,x
000270r 2  8D rr rr       sta HI_DIGIT
000273r 2  68             pla
000274r 2  29 0F          and #$0f
000276r 2  AA             tax
000277r 2  BD rr rr       lda hexascii,x
00027Ar 2  8D rr rr       sta LO_DIGIT
00027Dr 2  60             rts
00027Er 2               
00027Er 2  30 31 32 33  hexascii: .byte "0123456789ABCDEF"
000282r 2  34 35 36 37  
000286r 2  38 39 41 42  
00028Er 2               
00028Er 2               
00028Er 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00028Er 2               ;;
00028Er 2               ;;    convert a binary (hex) value in Accumulator into
00028Er 2               ;;    its ASCII equivalent character in decimal 0-99 and print it
00028Er 2               ;;    this converts hex/binary numbers from the RTC into human readable
00028Er 2               ;;    decimal for display on clock
00028Er 2               
00028Er 2               
00028Er 2               bintoascii:
00028Er 2               
00028Er 2  C9 0A          cmp #10
000290r 2  30 10          bmi single_figure
000292r 2  0A             asl
000293r 2  AA             tax
000294r 2  BD rr rr       lda binascii,x
000297r 2  20 rr rr       jsr print_char
00029Ar 2               
00029Ar 2  E8             inx
00029Br 2               
00029Br 2  BD rr rr       lda binascii,x
00029Er 2  20 rr rr       jsr print_char
0002A1r 2  60             rts
0002A2r 2               
0002A2r 2               single_figure:
0002A2r 2  0A             asl
0002A3r 2  AA             tax
0002A4r 2  E8             inx
0002A5r 2  BD rr rr       lda binascii,x
0002A8r 2  20 rr rr       jsr print_char
0002ABr 2  60             rts
0002ACr 2               
0002ACr 2               bintoascii_2:
0002ACr 2               
0002ACr 2  C9 0A          cmp #10
0002AEr 2  30 10          bmi single_figure_2
0002B0r 2  0A             asl
0002B1r 2  AA             tax
0002B2r 2  BD rr rr       lda binascii,x
0002B5r 2  20 rr rr       jsr print_2_char
0002B8r 2               
0002B8r 2  E8             inx
0002B9r 2               
0002B9r 2  BD rr rr       lda binascii,x
0002BCr 2  20 rr rr       jsr print_2_char
0002BFr 2  60             rts
0002C0r 2               
0002C0r 2               single_figure_2:
0002C0r 2  0A             asl
0002C1r 2  AA             tax
0002C2r 2  E8             inx
0002C3r 2  BD rr rr       lda binascii,x
0002C6r 2  20 rr rr       jsr print_2_char
0002C9r 2  60             rts
0002CAr 2               
0002CAr 2               
0002CAr 2  30 30 30 31  binascii: .byte "00010203040506070809"
0002CEr 2  30 32 30 33  
0002D2r 2  30 34 30 35  
0002DEr 2  31 30 31 31            .byte "10111213141516171819"
0002E2r 2  31 32 31 33  
0002E6r 2  31 34 31 35  
0002F2r 2  32 30 32 31            .byte "20212223242526272829"
0002F6r 2  32 32 32 33  
0002FAr 2  32 34 32 35  
000306r 2  33 30 33 31            .byte "30313233343536373839"
00030Ar 2  33 32 33 33  
00030Er 2  33 34 33 35  
00031Ar 2  34 30 34 31            .byte "40414243444546474849"
00031Er 2  34 32 34 33  
000322r 2  34 34 34 35  
00032Er 2  35 30 35 31            .byte "50515253545556575859"
000332r 2  35 32 35 33  
000336r 2  35 34 35 35  
000342r 2  36 30 36 31            .byte "60616263646566676869"
000346r 2  36 32 36 33  
00034Ar 2  36 34 36 35  
000356r 2  37 30 37 31            .byte "70717273747576777879"
00035Ar 2  37 32 37 33  
00035Er 2  37 34 37 35  
00036Ar 2  38 30 38 31            .byte "80818283848586878889"
00036Er 2  38 32 38 33  
000372r 2  38 34 38 35  
00037Er 2  39 30 39 31            .byte "90919293949596979899"
000382r 2  39 32 39 33  
000386r 2  39 34 39 35  
000392r 2               
000392r 2               
000392r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000392r 2               ;;
000392r 2               ;;      Convert a decimal number entered at keypad into its
000392r 2               ;;      HEX equivalent and display
000392r 2               ;;
000392r 2               
000392r 2               ;byte_to_hex:
000392r 2               ;
000392r 2               ;  jsr lcd_clear
000392r 2               ;  lda HEXB + 1
000392r 2               ;  and #$0f
000392r 2               ;  jsr bintohex
000392r 2               ;  lda HI_DIGIT
000392r 2               ;  jsr print_char
000392r 2               ;  lda LO_DIGIT
000392r 2               ;  jsr print_char
000392r 2               ;  lda HEXB
000392r 2               ;  jsr bintohex
000392r 2               ;  lda HI_DIGIT
000392r 2               ; jsr print_char
000392r 2               ; lda LO_DIGIT
000392r 2               ; jsr print_char
000392r 2               ;  lda #'d'
000392r 2               ;  jsr print_char
000392r 2               ;  lda #'='
000392r 2               ;  jsr print_char
000392r 2               ;  lda #'$'
000392r 2               ;  jsr print_char
000392r 2               ;
000392r 2               ;  lda HEXB ; lo byte
000392r 2               ;  pha
000392r 2               ;  lsr
000392r 2               ;  lsr
000392r 2               ;  lsr
000392r 2               ;  lsr
000392r 2               ;  cmp #10
000392r 2               ;  bpl error
000392r 2               ;  jsr mult10
000392r 2               ;  sta TENS
000392r 2               ;  pla
000392r 2               ;  and #%00001111 ; UNITS
000392r 2               ;  cmp #10
000392r 2               ;  bpl print_error
000392r 2               ;;  jsr mult10
000392r 2               ;  clc
000392r 2               ;  adc TENS
000392r 2               ;  sta HEX
000392r 2               ;
000392r 2               ;  lda HEXB + 1 ; hi byte
000392r 2               ;  and #%00001111
000392r 2               ;  cmp #10
000392r 2               ;  bpl print_error
000392r 2               ;  jsr mult10
000392r 2               ;  jsr mult10 ; hundreds
000392r 2               ;  adc HEX
000392r 2               ;
000392r 2               ;  jsr bintohex
000392r 2               ;  lda HI_DIGIT
000392r 2               ;  jsr print_char
000392r 2               ;  lda LO_DIGIT
000392r 2               ;  jsr print_char
000392r 2               ;  jmp exit_byte_to_hex
000392r 2               ;
000392r 2               ;error:
000392r 2               ;  pla
000392r 2               ;print_error:
000392r 2               ;  lda #<error_message
000392r 2               ;  sta MESSAGE_POINTER
000392r 2               ;  lda #>error_message
000392r 2               ;  sta MESSAGE_POINTER + 1
000392r 2               ;  jsr print3
000392r 2               ;  ;jsr lcd_cursor_off
000392r 2               ;  rts
000392r 2               ;
000392r 2               ;exit_byte_to_hex:
000392r 2               ;  jsr lcd_line_2
000392r 2               ;
000392r 2               ;  rts
000392r 2               
000392r 2               
000392r 2               
000392r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000392r 2               ;;
000392r 2               ;;  (A * 8) + (A * 2) = A * 10
000392r 2               
000392r 2               mult10:
000392r 2  48             pha
000393r 2  0A             asl
000394r 2  0A             asl
000395r 2  0A             asl
000396r 2  8D rr rr       sta TEMP2 ; A*8
000399r 2  68             pla
00039Ar 2  0A             asl      ; A*2
00039Br 2  6D rr rr       adc TEMP2 ; A*10
00039Er 2  60             rts
00039Fr 2               
00039Fr 2               
00039Fr 2               
00039Fr 2               
00039Fr 2               
00039Fr 1               .include "../includes/rtc.inc"
00039Fr 2               
00039Fr 2               
00039Fr 2               
00039Fr 2               
00039Fr 2                 .code
00039Fr 2               
00039Fr 2               
00039Fr 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00039Fr 2               ;;
00039Fr 2               ;;                          RTC / Jiffy Tick
00039Fr 2               ;;
00039Fr 2               
00039Fr 2               
00039Fr 2               
00039Fr 2               rtc:
00039Fr 2               
00039Fr 2               
00039Fr 2               ;;  RTC stores ticks at 10ms intervals into a 4-byte (32 bit) value
00039Fr 2               ;;
00039Fr 2               ;;  as each byte rolls over the next one is incremented
00039Fr 2               ;;  on a tick that doesn't roll over the TIME OF DAY
00039Fr 2               ;;  is updated
00039Fr 2               
00039Fr 2  E6 rr          inc TICKS
0003A1r 2  D0 0A          bne inc_MET
0003A3r 2  E6 rr          inc TICKS + 1
0003A5r 2  D0 06          bne inc_MET
0003A7r 2  E6 rr          inc TICKS + 2
0003A9r 2  D0 02          bne inc_MET
0003ABr 2  E6 rr          inc TICKS + 3
0003ADr 2               
0003ADr 2               ;;
0003ADr 2               ;;  Every time it's called we increment the "hundredths of a second" byte
0003ADr 2               ;;
0003ADr 2               ;;  When there's been 100 x 10ms (i.e. 1 second) we increment the seconds
0003ADr 2               ;;
0003ADr 2               ;; We keep the times in single digits, SECONDS, TEN_SECONDS, MINUTES,
0003ADr 2               ;; TEN_MINUTES etc.... to make it easy to display
0003ADr 2               ;; The values are stored in RAM as binary values, and need to be converted to
0003ADr 2               ;; ASCII characters when they are displayed on LCD
0003ADr 2               ;;
0003ADr 2               ;;  The bulk of this routine comes from http://wilsonminesco.com/6502interrupts/#2.1
0003ADr 2               ;;
0003ADr 2               inc_MET:
0003ADr 2  E6 rr          inc CENTISEC
0003AFr 2  A5 rr          lda CENTISEC
0003B1r 2  C9 64          cmp #100
0003B3r 2  30 40          bmi end_MET
0003B5r 2  64 rr          stz CENTISEC
0003B7r 2               
0003B7r 2  E6 rr          inc SECONDS
0003B9r 2  A5 rr          lda SECONDS
0003BBr 2  C9 0A          cmp #10
0003BDr 2  30 36          bmi end_MET
0003BFr 2  64 rr          stz SECONDS
0003C1r 2  E6 rr          inc TEN_SECONDS
0003C3r 2               
0003C3r 2  A5 rr          lda TEN_SECONDS
0003C5r 2  C9 06          cmp #6
0003C7r 2  30 2C          bmi end_MET
0003C9r 2  64 rr          stz TEN_SECONDS
0003CBr 2               
0003CBr 2  E6 rr          inc MINUTES
0003CDr 2  A5 rr          lda MINUTES
0003CFr 2  C9 0A          cmp #10
0003D1r 2  30 22          bmi end_MET
0003D3r 2  64 rr          stz MINUTES
0003D5r 2               
0003D5r 2  E6 rr          inc TEN_MINUTES
0003D7r 2  A5 rr          lda TEN_MINUTES
0003D9r 2  C9 06          cmp #6
0003DBr 2  30 18          bmi end_MET
0003DDr 2  64 rr          stz TEN_MINUTES
0003DFr 2               
0003DFr 2  E6 rr          inc HRS
0003E1r 2  A5 rr          lda HRS
0003E3r 2  C9 0A          cmp #10
0003E5r 2  30 0E          bmi end_MET
0003E7r 2  64 rr          stz HRS
0003E9r 2               
0003E9r 2  E6 rr          inc TEN_HRS
0003EBr 2  A5 rr          lda TEN_HRS
0003EDr 2  C9 0A          cmp #10
0003EFr 2  30 04          bmi end_MET
0003F1r 2  64 rr          stz TEN_HRS
0003F3r 2               
0003F3r 2  E6 rr          inc HUNDRED_HRS
0003F5r 2               
0003F5r 2               end_MET:
0003F5r 2  60             rts
0003F6r 2               
0003F6r 2               
0003F6r 1               
0003F6r 1               
0003F6r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003F6r 1               ;;
0003F6r 1               ;;         START HERE
0003F6r 1               ;;
0003F6r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003F6r 1               
0003F6r 1               .code
0003F6r 1               
0003F6r 1               reset:
0003F6r 1               
0003F6r 1  A2 FF          ldx #$ff
0003F8r 1  9A             txs
0003F9r 1  58             cli      ; interrupts ON
0003FAr 1               
0003FAr 1                 ;; IOPORTS
0003FAr 1  20 rr rr       jsr via_1_init ; set-up VIA_1 for LCD/Keypad
0003FDr 1  20 rr rr       jsr via_2_init ; set-up VIA_2 for general I/O
000400r 1  20 rr rr       jsr via_3_init ; set-up VIA_3 for general I/O
000403r 1               
000403r 1                 ;; LCD
000403r 1  20 rr rr       jsr lcd_start ; set-up various features of lcd
000406r 1  20 rr rr       jsr lcd_2_start ; set-up various features of lcd
000409r 1               
000409r 1               init_variables:
000409r 1               
000409r 1  64 rr          stz TICKS
00040Br 1  64 rr          stz TICKS + 1
00040Dr 1  64 rr          stz TICKS + 2
00040Fr 1  64 rr          stz TICKS + 3
000411r 1  64 rr          stz DUMP_POINTER
000413r 1  64 rr          stz DUMP_POINTER + 1
000415r 1  64 rr          stz MESSAGE_POINTER
000417r 1  64 rr          stz MESSAGE_POINTER + 1
000419r 1  64 rr          stz TOGGLE_TIME
00041Br 1  64 rr          stz CLOCK_LAST
00041Dr 1  64 rr          stz LED2_LAST
00041Fr 1  64 rr          stz LED3_LAST
000421r 1  64 rr          stz CENTISEC
000423r 1  64 rr          stz FLAGS
000425r 1  64 rr          stz SECONDS
000427r 1  64 rr          stz TEN_SECONDS
000429r 1  64 rr          stz MINUTES
00042Br 1  64 rr          stz HRS
00042Dr 1  64 rr          stz TEN_HRS
00042Fr 1  64 rr          stz TEN_MINUTES
000431r 1  64 rr          stz HUNDRED_HRS
000433r 1  9C rr rr       stz TEMP
000436r 1  9C rr rr       stz TEMP2
000439r 1  9C rr rr       stz TENS
00043Cr 1  64 rr          stz MEM_POINTER
00043Er 1  64 rr          stz MEM_POINTER + 1
000440r 1  9C rr rr       stz HI_DIGIT
000443r 1  9C rr rr       stz LO_DIGIT
000446r 1  A9 10          lda #$10
000448r 1  85 rr          sta LAST_KIT
00044Ar 1  A9 rr          lda #<title
00044Cr 1  85 rr          sta MESSAGE_POINTER
00044Er 1  A9 rr          lda #>title
000450r 1  85 rr          sta MESSAGE_POINTER + 1
000452r 1  20 rr rr       jsr print1
000455r 1               
000455r 1               memory_test:
000455r 1               
000455r 1  A9 rr          lda #<mem_start_msg
000457r 1  85 rr          sta MESSAGE_POINTER
000459r 1  A9 rr          lda #>mem_start_msg
00045Br 1  85 rr          sta MESSAGE_POINTER + 1
00045Dr 1  20 rr rr       jsr print2
000460r 1               
000460r 1               ;; test then clear RAM between
000460r 1               ;; $0200 - $3FFF - avoids the ZP and STACK areas
000460r 1               
000460r 1  A9 02          lda #$02            ; start at $0200
000462r 1  85 rr          sta MEM_POINTER + 1
000464r 1  A0 00          ldy #$00
000466r 1               loop_ram:
000466r 1  A9 AA          lda #$AA              ; test with 10101010
000468r 1  91 rr          sta (MEM_POINTER),y   ; write test value to RAM
00046Ar 1  A9 FF          lda #$FF              ; remove test value from A
00046Cr 1  B1 rr          lda (MEM_POINTER),y   ; read RAM contents into A
00046Er 1  C9 AA          cmp #$AA              ; compare to expected value
000470r 1  D0 4B          bne mem_fail_1
000472r 1  A9 55          lda #$55              ; repeat test with 01010101
000474r 1  91 rr          sta (MEM_POINTER),y
000476r 1  A9 FF          lda #$FF
000478r 1  B1 rr          lda (MEM_POINTER),y
00047Ar 1  C9 55          cmp #$55
00047Cr 1  D0 4D          bne mem_fail_2
00047Er 1  A9 00          lda #$00              ; clear RAM to all zeros
000480r 1  91 rr          sta (MEM_POINTER),y
000482r 1  C8             iny
000483r 1  F0 03          beq next_page
000485r 1  4C rr rr       jmp loop_ram
000488r 1               next_page:
000488r 1  A5 rr          lda MEM_POINTER + 1
00048Ar 1  1A             inc
00048Br 1  C9 40          cmp #$40
00048Dr 1  F0 05          beq done_ram
00048Fr 1  85 rr          sta MEM_POINTER + 1
000491r 1  4C rr rr       jmp loop_ram
000494r 1               
000494r 1               done_ram:
000494r 1               
000494r 1  A9 rr          lda #<mem_pass_msg
000496r 1  85 rr          sta MESSAGE_POINTER
000498r 1  A9 rr          lda #>mem_pass_msg
00049Ar 1  85 rr          sta MESSAGE_POINTER + 1
00049Cr 1                 ;jsr lcd_clear
00049Cr 1  20 rr rr       jsr print3
00049Fr 1  D7 rr          smb5 FLAGS
0004A1r 1  A9 rr          lda #<start_msg
0004A3r 1  85 rr          sta MESSAGE_POINTER
0004A5r 1  A9 rr          lda #>start_msg
0004A7r 1  85 rr          sta MESSAGE_POINTER + 1
0004A9r 1  20 rr rr       jsr print4
0004ACr 1  20 rr rr       jsr lcd_2_clear
0004AFr 1  A9 rr          lda #<emt
0004B1r 1  85 rr          sta MESSAGE_POINTER
0004B3r 1  A9 rr          lda #>emt
0004B5r 1  85 rr          sta MESSAGE_POINTER + 1
0004B7r 1  20 rr rr       jsr print2_2
0004BAr 1  4C rr rr       jmp user_ram
0004BDr 1               
0004BDr 1               mem_fail_1:
0004BDr 1               
0004BDr 1  A9 rr          lda #<mem_fail_msg_1
0004BFr 1  85 rr          sta MESSAGE_POINTER
0004C1r 1  A9 rr          lda #>mem_fail_msg_1
0004C3r 1  85 rr          sta MESSAGE_POINTER + 1
0004C5r 1  20 rr rr       jsr print3
0004C8r 1  4C rr rr       jmp loop
0004CBr 1               
0004CBr 1               mem_fail_2:
0004CBr 1               
0004CBr 1  A9 rr          lda #<mem_fail_msg_2
0004CDr 1  85 rr          sta MESSAGE_POINTER
0004CFr 1  A9 rr          lda #>mem_fail_msg_2
0004D1r 1  85 rr          sta MESSAGE_POINTER + 1
0004D3r 1  20 rr rr       jsr print3
0004D6r 1  4C rr rr       jmp loop
0004D9r 1               
0004D9r 1               
0004D9r 1               
0004D9r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004D9r 1               ;;
0004D9r 1               ;;    Put NOPs in the "user ram" area $3F00 -> $3F0A
0004D9r 1               ;;    This is better than leaving this area full of $00, which is
0004D9r 1               ;;    the BRK command, and causes problems when the "GO" function is
0004D9r 1               ;;    done before putting any user code at $3F00.
0004D9r 1               ;;
0004D9r 1               ;;    Put a "guardian" RTS ($60) instruction at $3F0A to
0004D9r 1               ;;    catch any accidental use of the "GO" <shift>-5 command
0004D9r 1               ;;
0004D9r 1               ;;    Copy the current address of the "print4" function into sequential bytes,
0004D9r 1               ;;    $3F10 and $3F11, beyond the "guardian RTS", just to allow it to be found easily when
0004D9r 1               ;;    writing user code that might want to print something on Line 4
0004D9r 1               ;;    i.e.  "jsr print4" - look in $3F10 and £3F11 to see what 2 bytes are
0004D9r 1               ;;    needed to make the jsr target.
0004D9r 1               ;;
0004D9r 1               user_ram:
0004D9r 1  A0 00          ldy #$00
0004DBr 1               @loop:
0004DBr 1  B9 rr rr       lda userProg,y
0004DEr 1  F0 07          beq @exit
0004E0r 1  99 00 3F       sta $3F00,y
0004E3r 1  C8             iny
0004E4r 1  4C rr rr       jmp @loop
0004E7r 1               @exit:
0004E7r 1               
0004E7r 1               prompt:
0004E7r 1  A0 00          ldy #$00
0004E9r 1               @loop:
0004E9r 1  B9 rr rr       lda userPrompt,y
0004ECr 1  F0 07          beq @exit
0004EEr 1  99 00 20       sta $2000,y
0004F1r 1  C8             iny
0004F2r 1  4C rr rr       jmp @loop
0004F5r 1               @exit:
0004F5r 1               
0004F5r 1               
0004F5r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004F5r 1               ;;
0004F5r 1               ;;                 Main Loop
0004F5r 1               ;;
0004F5r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004F5r 1               
0004F5r 1               loop:
0004F5r 1               
0004F5r 1  CB             wai
0004F6r 1                 ;jsr clock_time
0004F6r 1                 ;jsr clock_via_2
0004F6r 1                 ;jsr kit_led_via_3
0004F6r 1  20 rr rr       jsr check_flags
0004F9r 1  4C rr rr       jmp loop
0004FCr 1               
0004FCr 1               
0004FCr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004FCr 1               ;;
0004FCr 1               ;;                  FUNCTIONS
0004FCr 1               ;;
0004FCr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004FCr 1               
0004FCr 1               check_flags:
0004FCr 1               
0004FCr 1               flag_zero:
0004FCr 1  0F rr 03       bbr0 FLAGS, flag_two
0004FFr 1  20 rr rr       jsr update_block_address
000502r 1                 ;bbs5 FLAGS, clock_time_flag:
000502r 1               flag_two:
000502r 1  2F rr 03       bbr2 FLAGS, flag_five
000505r 1  20 rr rr       jsr kit_led_via_3
000508r 1               flag_five:
000508r 1  5F rr 03       bbr5 FLAGS, flag_null
00050Br 1  20 rr rr       jsr clock_time
00050Er 1               flag_null:
00050Er 1                 ; check other flags... other actions....
00050Er 1  60             rts
00050Fr 1               
00050Fr 1               
00050Fr 1               
00050Fr 1               kit_led_via_3:
00050Fr 1               
00050Fr 1  38             sec
000510r 1  A5 rr          lda TICKS
000512r 1  E5 rr          sbc LED3_LAST
000514r 1  C9 0A          cmp #10
000516r 1  90 15          bcc exit_kit_leds
000518r 1  A4 rr          ldy LAST_KIT
00051Ar 1  B9 rr rr       lda kitLeds,y
00051Dr 1  8D 00 48       sta PORTB_3
000520r 1  88             dey
000521r 1  D0 04          bne @exit
000523r 1  A0 10          ldy #$10
000525r 1  84 rr          sty LAST_KIT
000527r 1               @exit:
000527r 1  84 rr          sty LAST_KIT
000529r 1  A5 rr          lda TICKS
00052Br 1  85 rr          sta LED3_LAST
00052Dr 1               exit_kit_leds:
00052Dr 1  60             rts
00052Er 1               
00052Er 1               clock_via_2:
00052Er 1  38             sec
00052Fr 1  A5 rr          lda TICKS
000531r 1  E5 rr          sbc LED2_LAST
000533r 1  C9 64          cmp #100
000535r 1  90 1A          bcc exit_clock_via_2
000537r 1  A5 rr          lda TEN_SECONDS
000539r 1  0A             asl
00053Ar 1  0A             asl
00053Br 1  0A             asl
00053Cr 1  0A             asl
00053Dr 1  05 rr          ora SECONDS
00053Fr 1  8D 01 50       sta PORTA_2
000542r 1               
000542r 1  A5 rr          lda TEN_MINUTES
000544r 1  0A             asl
000545r 1  0A             asl
000546r 1  0A             asl
000547r 1  0A             asl
000548r 1  05 rr          ora MINUTES
00054Ar 1  8D 00 50       sta PORTB_2
00054Dr 1               
00054Dr 1               
00054Dr 1               ;  inc PORTB_3
00054Dr 1               ;  bne @exit
00054Dr 1               ;  inc PORTA_2
00054Dr 1               ;  bne @exit
00054Dr 1               ;  inc PORTB_2
00054Dr 1               @exit:
00054Dr 1  A5 rr          lda TICKS
00054Fr 1  85 rr          sta LED2_LAST
000551r 1               exit_clock_via_2:
000551r 1  60             rts
000552r 1               
000552r 1               
000552r 1               update_block_address:
000552r 1  20 rr rr       jsr lcd_line_2
000555r 1  38             sec
000556r 1  A5 rr          lda TICKS
000558r 1  E5 rr          sbc TOGGLE_TIME
00055Ar 1  C9 64          cmp #$64
00055Cr 1  90 07          bcc @exit
00055Er 1  20 rr rr       jsr block_address
000561r 1  A5 rr          lda TICKS
000563r 1  85 rr          sta TOGGLE_TIME
000565r 1               @exit:
000565r 1  60             rts
000566r 1               
000566r 1               clock_time:
000566r 1  38             sec
000567r 1  A5 rr          lda TICKS
000569r 1  E5 rr          sbc CLOCK_LAST
00056Br 1  C9 32          cmp #50
00056Dr 1  90 3C          bcc @exit
00056Fr 1  20 rr rr       jsr lcd_2_cursor_off
000572r 1  20 rr rr       jsr lcd_2_line_1
000575r 1  A5 rr          lda HUNDRED_HRS
000577r 1  20 rr rr       jsr bintoascii_2
00057Ar 1  A5 rr          lda TEN_HRS
00057Cr 1  20 rr rr       jsr bintoascii_2
00057Fr 1  A5 rr          lda HRS
000581r 1  20 rr rr       jsr bintoascii_2
000584r 1  A9 3A          lda #':'
000586r 1  20 rr rr       jsr print_2_char
000589r 1  A5 rr          lda TEN_MINUTES
00058Br 1  20 rr rr       jsr bintoascii_2
00058Er 1  A5 rr          lda MINUTES
000590r 1  20 rr rr       jsr bintoascii_2
000593r 1  A9 3A          lda #':'
000595r 1  20 rr rr       jsr print_2_char
000598r 1  A5 rr          lda TEN_SECONDS
00059Ar 1  20 rr rr       jsr bintoascii_2
00059Dr 1  A5 rr          lda SECONDS
00059Fr 1  20 rr rr       jsr bintoascii_2
0005A2r 1  A9 20          lda #' '
0005A4r 1  20 rr rr       jsr print_2_char
0005A7r 1  A5 rr          lda TICKS
0005A9r 1  85 rr          sta CLOCK_LAST
0005ABr 1               @exit:
0005ABr 1  60             rts
0005ACr 1               
0005ACr 1               
0005ACr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005ACr 1               ;;
0005ACr 1               ;;      update screen when new memory location is selected
0005ACr 1               ;;
0005ACr 1               ;;
0005ACr 1               new_address:
0005ACr 1  20 rr rr       jsr lcd_clear
0005AFr 1  20 rr rr       jsr lcd_cursor_on
0005B2r 1  A9 rr          lda #<new_address_msg
0005B4r 1  85 rr          sta MESSAGE_POINTER
0005B6r 1  A9 rr          lda #>new_address_msg
0005B8r 1  85 rr          sta MESSAGE_POINTER + 1
0005BAr 1  20 rr rr       jsr print1
0005BDr 1  20 rr rr       jsr lcd_line_2
0005C0r 1               print_address:
0005C0r 1  A9 24          lda #'$'
0005C2r 1  20 rr rr       jsr print_char
0005C5r 1  A5 rr          lda DUMP_POINTER + 1
0005C7r 1  20 rr rr       jsr bintohex
0005CAr 1  AD rr rr       lda HI_DIGIT
0005CDr 1  20 rr rr       jsr print_char
0005D0r 1  AD rr rr       lda LO_DIGIT
0005D3r 1  20 rr rr       jsr print_char
0005D6r 1  A5 rr          lda DUMP_POINTER
0005D8r 1  20 rr rr       jsr bintohex
0005DBr 1  AD rr rr       lda HI_DIGIT
0005DEr 1  20 rr rr       jsr print_char
0005E1r 1  AD rr rr       lda LO_DIGIT
0005E4r 1  20 rr rr       jsr print_char
0005E7r 1  A9 20          lda #' '
0005E9r 1  20 rr rr       jsr print_char
0005ECr 1  A0 00          ldy #$00
0005EEr 1  B1 rr          lda (DUMP_POINTER),y
0005F0r 1  20 rr rr       jsr bintohex
0005F3r 1  AD rr rr       lda HI_DIGIT
0005F6r 1  20 rr rr       jsr print_char
0005F9r 1  AD rr rr       lda LO_DIGIT
0005FCr 1  20 rr rr       jsr print_char
0005FFr 1  A9 20          lda #' '
000601r 1  20 rr rr       jsr print_char
000604r 1  B1 rr          lda (DUMP_POINTER),y
000606r 1  20 rr rr       jsr print_char
000609r 1  A9 rr          lda #<splash
00060Br 1  85 rr          sta MESSAGE_POINTER
00060Dr 1  A9 rr          lda #>splash
00060Fr 1  85 rr          sta MESSAGE_POINTER + 1
000611r 1  20 rr rr       jsr print3   ; add second line (cursor) after re-writing the top line
000614r 1  60             rts
000615r 1               
000615r 1               
000615r 1               
000615r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000615r 1               ;;
000615r 1               ;;      display 8 bytes of data for a "block" of memory
000615r 1               ;;
000615r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000615r 1               
000615r 1               block_address:
000615r 1               
000615r 1  20 rr rr       jsr lcd_clear
000618r 1  20 rr rr       jsr lcd_cursor_off
00061Br 1  A9 rr          lda #<block_address_msg
00061Dr 1  85 rr          sta MESSAGE_POINTER
00061Fr 1  A9 rr          lda #>block_address_msg
000621r 1  85 rr          sta MESSAGE_POINTER + 1
000623r 1  20 rr rr       jsr print1
000626r 1  20 rr rr       jsr lcd_line_2
000629r 1  A0 00          ldy #$00
00062Br 1  A9 24          lda #'$'
00062Dr 1  20 rr rr       jsr print_char
000630r 1  A5 rr          lda DUMP_POINTER + 1
000632r 1  20 rr rr       jsr bintohex
000635r 1  AD rr rr       lda HI_DIGIT
000638r 1  20 rr rr       jsr print_char
00063Br 1  AD rr rr       lda LO_DIGIT
00063Er 1  20 rr rr       jsr print_char
000641r 1  A5 rr          lda DUMP_POINTER
000643r 1  20 rr rr       jsr bintohex
000646r 1  AD rr rr       lda HI_DIGIT
000649r 1  20 rr rr       jsr print_char
00064Cr 1  AD rr rr       lda LO_DIGIT
00064Fr 1  20 rr rr       jsr print_char
000652r 1  20 rr rr       jsr lcd_line_3
000655r 1               loop1:
000655r 1  B1 rr          lda (DUMP_POINTER),y
000657r 1  20 rr rr       jsr bintohex
00065Ar 1  AD rr rr       lda HI_DIGIT
00065Dr 1  20 rr rr       jsr print_char
000660r 1  AD rr rr       lda LO_DIGIT
000663r 1  20 rr rr       jsr print_char
000666r 1  B1 rr          lda (DUMP_POINTER),y
000668r 1  C8             iny
000669r 1  C0 08          cpy #$08
00066Br 1  D0 E8          bne loop1
00066Dr 1  A9 20          lda #' '
00066Fr 1  20 rr rr       jsr print_char
000672r 1  A9 48          lda #'H'
000674r 1  20 rr rr       jsr print_char
000677r 1  A9 65          lda #'e'
000679r 1  20 rr rr       jsr print_char
00067Cr 1  A9 78          lda #'x'
00067Er 1  20 rr rr       jsr print_char
000681r 1  20 rr rr       jsr lcd_line_4
000684r 1  A0 00          ldy #$00
000686r 1               loop2:
000686r 1  A9 20          lda #$20
000688r 1  20 rr rr       jsr print_char
00068Br 1  B1 rr          lda (DUMP_POINTER),y
00068Dr 1                 ;jsr bintohex
00068Dr 1                 ;lda HI_DIGIT
00068Dr 1  20 rr rr       jsr print_char
000690r 1                 ;lda LO_DIGIT
000690r 1                 ;jsr print_char
000690r 1                 ;lda (DUMP_POINTER),y
000690r 1  C8             iny
000691r 1  C0 08          cpy #$08
000693r 1  D0 F1          bne loop2
000695r 1  A9 20          lda #' '
000697r 1  20 rr rr       jsr print_char
00069Ar 1  A9 43          lda #'C'
00069Cr 1  20 rr rr       jsr print_char
00069Fr 1  A9 68          lda #'h'
0006A1r 1  20 rr rr       jsr print_char
0006A4r 1  A9 72          lda #'r'
0006A6r 1  20 rr rr       jsr print_char
0006A9r 1  60             rts
0006AAr 1               
0006AAr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006AAr 1               ;;
0006AAr 1               ;;            print on line 1 or line 2
0006AAr 1               ;;
0006AAr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006AAr 1               
0006AAr 1               
0006AAr 1               
0006AAr 1               print1:
0006AAr 1  20 rr rr       jsr lcd_line_1
0006ADr 1  A0 00          ldy #0
0006AFr 1  4C rr rr       jmp line
0006B2r 1               print2:
0006B2r 1  20 rr rr       jsr lcd_line_2
0006B5r 1  A0 00          ldy #0
0006B7r 1  4C rr rr       jmp line
0006BAr 1               print3:
0006BAr 1  20 rr rr       jsr lcd_line_3
0006BDr 1  A0 00          ldy #0
0006BFr 1  4C rr rr       jmp line
0006C2r 1               print4:
0006C2r 1  20 rr rr       jsr lcd_line_4
0006C5r 1  A0 00          ldy #0
0006C7r 1  4C rr rr       jmp line
0006CAr 1               
0006CAr 1               print2_2:
0006CAr 1  20 rr rr       jsr lcd_2_line_2
0006CDr 1  A0 00          ldy #0
0006CFr 1  4C rr rr       jmp line2
0006D2r 1               
0006D2r 1               line:
0006D2r 1  B1 rr          lda (MESSAGE_POINTER),y
0006D4r 1  F0 07          beq @exit
0006D6r 1  20 rr rr       jsr print_char
0006D9r 1  C8             iny
0006DAr 1  4C rr rr       jmp line
0006DDr 1               @exit:
0006DDr 1  60             rts
0006DEr 1               
0006DEr 1               line2:
0006DEr 1  B1 rr          lda (MESSAGE_POINTER),y
0006E0r 1  F0 07          beq @exit
0006E2r 1  20 rr rr       jsr print_2_char
0006E5r 1  C8             iny
0006E6r 1  4C rr rr       jmp line2
0006E9r 1               @exit:
0006E9r 1  60             rts
0006EAr 1               
0006EAr 1               
0006EAr 1               
0006EAr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006EAr 1               ;;
0006EAr 1               ;;      Monitor function - decrement the selected address
0006EAr 1               ;;
0006EAr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006EAr 1               
0006EAr 1               decrement_address:
0006EAr 1               
0006EAr 1  38             sec
0006EBr 1  A5 rr          lda DUMP_POINTER
0006EDr 1  E9 01          sbc #$01
0006EFr 1  85 rr          sta DUMP_POINTER
0006F1r 1  8D rr rr       sta BYTE
0006F4r 1  A5 rr          lda DUMP_POINTER + 1
0006F6r 1  E9 00          sbc #$00
0006F8r 1  85 rr          sta DUMP_POINTER + 1
0006FAr 1  8D rr rr       sta BYTE + 1
0006FDr 1  60             rts
0006FEr 1               
0006FEr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006FEr 1               ;;
0006FEr 1               ;;      Monitor function - increment the selected address
0006FEr 1               ;;
0006FEr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006FEr 1               
0006FEr 1               increment_address:
0006FEr 1               
0006FEr 1  18             clc
0006FFr 1  A5 rr          lda DUMP_POINTER
000701r 1  69 01          adc #$01
000703r 1  85 rr          sta DUMP_POINTER
000705r 1  8D rr rr       sta BYTE
000708r 1  A5 rr          lda DUMP_POINTER + 1
00070Ar 1  69 00          adc #$00
00070Cr 1  85 rr          sta DUMP_POINTER + 1
00070Er 1  8D rr rr       sta BYTE + 1
000711r 1  60             rts
000712r 1               
000712r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000712r 1               ;;
000712r 1               ;;      Monitor function - increment the selected block of  addresses by 8
000712r 1               ;;
000712r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000712r 1               
000712r 1               increment_block:
000712r 1               
000712r 1  18             clc
000713r 1  A5 rr          lda DUMP_POINTER
000715r 1  69 08          adc #$08
000717r 1  85 rr          sta DUMP_POINTER
000719r 1  8D rr rr       sta BYTE
00071Cr 1  A5 rr          lda DUMP_POINTER + 1
00071Er 1  69 00          adc #$00
000720r 1  85 rr          sta DUMP_POINTER + 1
000722r 1  8D rr rr       sta BYTE + 1
000725r 1  60             rts
000726r 1               
000726r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000726r 1               ;;
000726r 1               ;;      Monitor function - decrement the selected block of  addresses by 8
000726r 1               ;;
000726r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000726r 1               
000726r 1               decrement_block:
000726r 1               
000726r 1  38             sec
000727r 1  A5 rr          lda DUMP_POINTER
000729r 1  E9 08          sbc #$08
00072Br 1  85 rr          sta DUMP_POINTER
00072Dr 1  8D rr rr       sta BYTE
000730r 1  A5 rr          lda DUMP_POINTER + 1
000732r 1  E9 00          sbc #$00
000734r 1  85 rr          sta DUMP_POINTER + 1
000736r 1  8D rr rr       sta BYTE + 1
000739r 1  60             rts
00073Ar 1               
00073Ar 1               
00073Ar 1               
00073Ar 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00073Ar 1               ;;
00073Ar 1               ;; use last 4 key presses (as hex bytes) to fill two BYTES
00073Ar 1               ;;
00073Ar 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00073Ar 1               
00073Ar 1               keys_byte:
00073Ar 1               
00073Ar 1  AD rr rr       lda KEY_PRESS + 1
00073Dr 1  0A             asl
00073Er 1  0A             asl
00073Fr 1  0A             asl
000740r 1  0A             asl
000741r 1  8D rr rr       sta BYTE
000744r 1  AD rr rr       lda KEY_PRESS
000747r 1  0D rr rr       ora BYTE
00074Ar 1  8D rr rr       sta BYTE
00074Dr 1  AD rr rr       lda KEY_PRESS + 3
000750r 1  0A             asl
000751r 1  0A             asl
000752r 1  0A             asl
000753r 1  0A             asl
000754r 1  8D rr rr       sta BYTE + 1
000757r 1  AD rr rr       lda KEY_PRESS + 2
00075Ar 1  0D rr rr       ora BYTE + 1
00075Dr 1  8D rr rr       sta BYTE + 1
000760r 1  60             rts
000761r 1               
000761r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000761r 1               ;;
000761r 1               ;;    toggle the display/update of Clock on each appropriate keypress
000761r 1               ;;
000761r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000761r 1               
000761r 1               show_clock:
000761r 1               
000761r 1  DF rr 10       bbs5 FLAGS, reset_bit5
000764r 1  D7 rr          smb5 FLAGS
000766r 1  A9 rr          lda #<emt
000768r 1  85 rr          sta MESSAGE_POINTER
00076Ar 1  A9 rr          lda #>emt
00076Cr 1  85 rr          sta MESSAGE_POINTER + 1
00076Er 1  20 rr rr       jsr print2_2
000771r 1  4C rr rr       jmp exit_show_clock
000774r 1               reset_bit5:
000774r 1  57 rr          rmb5 FLAGS
000776r 1  A9 rr          lda #<pause_msg
000778r 1  85 rr          sta MESSAGE_POINTER
00077Ar 1  A9 rr          lda #>pause_msg
00077Cr 1  85 rr          sta MESSAGE_POINTER + 1
00077Er 1  20 rr rr       jsr print2_2
000781r 1               
000781r 1               exit_show_clock:
000781r 1  60             rts
000782r 1               
000782r 1               
000782r 1               
000782r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000782r 1               ;;
000782r 1               ;;    toggle the automatic update view of the "8-byte memory block"
000782r 1               ;;
000782r 1               
000782r 1               show_block:
000782r 1               
000782r 1  8F rr 05       bbs0 FLAGS, reset_bit0
000785r 1  87 rr          smb0 FLAGS
000787r 1  4C rr rr       jmp exit_show_block
00078Ar 1               reset_bit0:
00078Ar 1  07 rr          rmb0 FLAGS
00078Cr 1               exit_show_block:
00078Cr 1  60             rts
00078Dr 1               
00078Dr 1               
00078Dr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00078Dr 1               ;;
00078Dr 1               ;;     toggle the scanning LED routine on VIA_3 Port B
00078Dr 1               ;;
00078Dr 1               
00078Dr 1               show_kitt:
00078Dr 1               
00078Dr 1  AF rr 05       bbs2 FLAGS, reset_bit2
000790r 1  A7 rr          smb2 FLAGS
000792r 1  4C rr rr       jmp exit_show_kitt
000795r 1               reset_bit2:
000795r 1  27 rr          rmb2 FLAGS
000797r 1               exit_show_kitt:
000797r 1  60             rts
000798r 1               
000798r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000798r 1               ;;
000798r 1               ;;                     INTERRUPT HANDLERS
000798r 1               ;;
000798r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000798r 1               
000798r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000798r 1               ;;
000798r 1               ;;                 CB1 : reset & restart timer
000798r 1               ;;
000798r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000798r 1               
000798r 1               cb1_handler:
000798r 1               
000798r 1  64 rr          stz HUNDRED_HRS
00079Ar 1  64 rr          stz TEN_HRS
00079Cr 1  64 rr          stz TEN_MINUTES
00079Er 1  64 rr          stz TEN_SECONDS
0007A0r 1  64 rr          stz HRS
0007A2r 1  64 rr          stz MINUTES
0007A4r 1  64 rr          stz SECONDS
0007A6r 1  60             rts
0007A7r 1               
0007A7r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007A7r 1               ;;
0007A7r 1               ;;                CB2 : show/hide KITT scanning LEDs
0007A7r 1               ;;
0007A7r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007A7r 1               
0007A7r 1               cb2_handler:
0007A7r 1               
0007A7r 1  20 rr rr       jsr show_clock
0007AAr 1  60             rts
0007ABr 1               
0007ABr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007ABr 1               ;;
0007ABr 1               ;;                    MONITOR / KEYPAD
0007ABr 1               ;;
0007ABr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007ABr 1               
0007ABr 1               keypad_handler:
0007ABr 1               
0007ABr 1  20 rr rr       jsr get_key     ; READs from PORTA which also re-sets VIA's Interrupt flag
0007AEr 1  8D rr rr       sta INKEY       ; put the byte value of input into RAM ( $00 )
0007B1r 1  AD 00 60       lda PORTB_1       ; check for SHIFT/INSTRUCTION button, 0=pressed, 1=not pressed
0007B4r 1  29 80          and #%10000000    ; zero (eq) when button pressed -> check_keypress, otherwise it's not zero, jmp to handle_new_char
0007B6r 1  F0 03          beq check_keypress ; done this way to get around the limit in size of branch jumps....
0007B8r 1  4C rr rr       jmp handle_new_char
0007BBr 1               
0007BBr 1               check_keypress:
0007BBr 1               
0007BBr 1  AD rr rr       lda INKEY
0007BEr 1                 ;jsr bintohex  ; convert BYTE value of keypress to its ASCII HEX equivalent "0" -> "A"
0007BEr 1                                ; could perhaps not do this conversion, and checks below made against
0007BEr 1                                ; actual BYTE values?
0007BEr 1               
0007BEr 1               
0007BEr 1               ; choose action of "SHIFTed" key-press
0007BEr 1               
0007BEr 1               check_a:
0007BEr 1               
0007BEr 1                 ;cmp #'A'
0007BEr 1  C9 0A          cmp #$0A
0007C0r 1                 ; move up one memory address and display contents
0007C0r 1  D0 09          bne check_b
0007C2r 1  20 rr rr       jsr increment_address
0007C5r 1  20 rr rr       jsr new_address
0007C8r 1  4C rr rr       jmp exit_key_irq
0007CBr 1               
0007CBr 1               check_b:
0007CBr 1               
0007CBr 1                 ;cmp #'B'
0007CBr 1  C9 0B          cmp #$0B
0007CDr 1                 ; move down one memory address and display contents
0007CDr 1  D0 09          bne check_c
0007CFr 1  20 rr rr       jsr decrement_address
0007D2r 1  20 rr rr       jsr new_address
0007D5r 1  4C rr rr       jmp exit_key_irq
0007D8r 1               
0007D8r 1               check_c:
0007D8r 1               
0007D8r 1                 ;cmp #'C'
0007D8r 1  C9 0C          cmp #$0C
0007DAr 1                 ; return to MONITOR
0007DAr 1  D0 13          bne check_d
0007DCr 1                 ;rmb5 FLAGS
0007DCr 1  07 rr          rmb0 FLAGS
0007DEr 1  20 rr rr       jsr lcd_clear
0007E1r 1  A9 rr          lda #<splash
0007E3r 1  85 rr          sta MESSAGE_POINTER
0007E5r 1  A9 rr          lda #>splash
0007E7r 1  85 rr          sta MESSAGE_POINTER + 1
0007E9r 1  20 rr rr       jsr new_address
0007ECr 1  4C rr rr       jmp exit_key_irq
0007EFr 1               
0007EFr 1               check_d:
0007EFr 1               
0007EFr 1                 ;cmp #'D'
0007EFr 1  C9 0D          cmp #$0D
0007F1r 1                 ; move monitor to entered 4-digit memory address
0007F1r 1  D0 10          bne check_e
0007F3r 1  AD rr rr       lda BYTE
0007F6r 1  85 rr          sta DUMP_POINTER
0007F8r 1  AD rr rr       lda BYTE + 1
0007FBr 1  85 rr          sta DUMP_POINTER + 1
0007FDr 1  20 rr rr       jsr new_address
000800r 1                 ;jsr print2
000800r 1  4C rr rr       jmp exit_key_irq
000803r 1               
000803r 1               check_e:
000803r 1               
000803r 1                 ;cmp #'E'
000803r 1  C9 0E          cmp #$0E
000805r 1                 ; insert (POKE) byte of data in to current memory address, then increment to next address
000805r 1  D0 0D          bne check_f
000807r 1  AD rr rr       lda BYTE
00080Ar 1  A0 00          ldy #$00
00080Cr 1  91 rr          sta (DUMP_POINTER),y
00080Er 1                 ;jsr increment_address
00080Er 1  20 rr rr       jsr new_address
000811r 1                 ;jsr print2
000811r 1  4C rr rr       jmp exit_key_irq
000814r 1               
000814r 1               check_f:
000814r 1               
000814r 1                 ;cmp #'F'
000814r 1  C9 0F          cmp #$0F
000816r 1                 ; show 8-byte wide block of memory
000816r 1  D0 12          bne check_1
000818r 1  A0 00          ldy #$00
00081Ar 1  AD rr rr       lda BYTE
00081Dr 1  85 rr          sta DUMP_POINTER
00081Fr 1  AD rr rr       lda BYTE + 1
000822r 1  85 rr          sta DUMP_POINTER + 1
000824r 1  20 rr rr       jsr block_address
000827r 1  4C rr rr       jmp exit_key_irq
00082Ar 1               
00082Ar 1               check_1:
00082Ar 1               
00082Ar 1                 ;cmp #'1'
00082Ar 1  C9 01          cmp #$01
00082Cr 1  D0 03          bne check_3
00082Er 1  4C rr rr       jmp exit_key_irq
000831r 1               
000831r 1               check_3:
000831r 1               
000831r 1                 ;cmp #'3'
000831r 1  C9 03          cmp #$03
000833r 1  D0 0B          bne check_6
000835r 1  A0 00          ldy #$00
000837r 1  20 rr rr       jsr increment_block
00083Ar 1  20 rr rr       jsr block_address
00083Dr 1  4C rr rr       jmp exit_key_irq
000840r 1               
000840r 1               check_6:
000840r 1               
000840r 1                 ;cmp #'6'
000840r 1  C9 06          cmp #$06
000842r 1  D0 0B          bne check_9
000844r 1  A0 00          ldy #$00
000846r 1  20 rr rr       jsr decrement_block
000849r 1  20 rr rr       jsr block_address
00084Cr 1  4C rr rr       jmp exit_key_irq
00084Fr 1               
00084Fr 1               check_9:
00084Fr 1               
00084Fr 1                 ;cmp #'9'
00084Fr 1  C9 09          cmp #$09
000851r 1  D0 06          bne check_4
000853r 1  20 rr rr       jsr show_block
000856r 1  4C rr rr       jmp exit_key_irq
000859r 1               
000859r 1               check_4:
000859r 1               
000859r 1                 ;cmp #'4'
000859r 1  C9 04          cmp #$04
00085Br 1  D0 06          bne check_5
00085Dr 1  20 rr rr       jsr show_kitt
000860r 1  4C rr rr       jmp exit_key_irq
000863r 1               
000863r 1               check_5:
000863r 1               
000863r 1                 ;cmp #'5'
000863r 1  C9 05          cmp #$05
000865r 1  D0 27          bne exit_key_irq
000867r 1  20 00 3F       jsr $3F00
00086Ar 1  4C rr rr       jmp exit_key_irq
00086Dr 1               
00086Dr 1               
00086Dr 1               handle_new_char:
00086Dr 1               
00086Dr 1  AD rr rr       lda KEY_PRESS + 2
000870r 1  8D rr rr       sta KEY_PRESS + 3
000873r 1  AD rr rr       lda KEY_PRESS + 1
000876r 1  8D rr rr       sta KEY_PRESS + 2
000879r 1  AD rr rr       lda KEY_PRESS
00087Cr 1  8D rr rr       sta KEY_PRESS + 1
00087Fr 1  AD rr rr       lda INKEY       ; get the new keypress value and...
000882r 1  8D rr rr       sta KEY_PRESS
000885r 1  20 rr rr       jsr bintohex
000888r 1  20 rr rr       jsr print_char  ; and print it on LCD
00088Br 1  20 rr rr       jsr keys_byte
00088Er 1               
00088Er 1               exit_key_irq:
00088Er 1               
00088Er 1  20 rr rr       jsr scan  ; re-enable keypad
000891r 1  60             rts
000892r 1               
000892r 1               
000892r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000892r 1               
000892r 1               nmi:
000892r 1  48             pha
000893r 1  DA             phx
000894r 1  5A             phy
000895r 1               
000895r 1  2C 04 48       bit T1CL_3      ; reset interrupt flag
000898r 1  20 rr rr       jsr rtc
00089Br 1  4C rr rr       jmp exit_nmi
00089Er 1               
00089Er 1               exit_nmi:
00089Er 1  7A             ply
00089Fr 1  FA             plx
0008A0r 1  68             pla
0008A1r 1  40             rti
0008A2r 1               
0008A2r 1  40             rti
0008A3r 1               
0008A3r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008A3r 1               ;;
0008A3r 1               ;;    interrupt is triggered by HIGH edge on VIA CA1 pin
0008A3r 1               ;;     PORTA low nibble (keypad columns) inputs are diode ORed to CA1
0008A3r 1               ;;
0008A3r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008A3r 1               
0008A3r 1               irq:
0008A3r 1               
0008A3r 1               ; put registers on the stack while handling the IRQ
0008A3r 1  48             pha
0008A4r 1  DA             phx
0008A5r 1  5A             phy
0008A6r 1               
0008A6r 1               ;  find responsible hardware
0008A6r 1               
0008A6r 1               ;  Is it VIA_1?
0008A6r 1               
0008A6r 1  AD 0D 60       lda IFR_1   ; if IFR_1 has Bit7 set (ie sign=NEGATIVE) then it IS the source of the interrupt
0008A9r 1  10 25          bpl next_device ; if it's not set (ie sign=POSITIVE) then branch to test the next possible device
0008ABr 1               
0008ABr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008ABr 1               ;;
0008ABr 1               ;; IFR Flags
0008ABr 1               ;; B7  B6  B5  B4  B3  B2  B1  B0
0008ABr 1               ;; IRQ TI1 TI2 CB1 CB2 SR CA1 CA2
0008ABr 1               ;;
0008ABr 1               ;; Interrupt source is found by sequentially shifting IFR bit left to put bit-of-interest into the CARRY place
0008ABr 1               ;; and then branching based on whether CARRY is SET or not
0008ABr 1               ;;
0008ABr 1               ;; Only add tests for IRQ sources in use, and adjust the ASLs in each test as necessary
0008ABr 1               ;;
0008ABr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008ABr 1               
0008ABr 1               ;test_timer1:
0008ABr 1               
0008ABr 1               ;  asl           ; shift IFR left twice puts the TI1 bit into CARRY....
0008ABr 1               ;  asl
0008ABr 1               ;  bcc test_cb1  ; carry clear = next test
0008ABr 1               ;  bit T1CL_1      ; clear not clear = handle the TIMER interrupt
0008ABr 1               ;  jsr rtc
0008ABr 1               ;  jmp exit_irq
0008ABr 1               
0008ABr 1               test_cb1:
0008ABr 1               
0008ABr 1  0A             asl
0008ACr 1  0A             asl
0008ADr 1  0A             asl
0008AEr 1  0A             asl
0008AFr 1  90 09          bcc test_cb2
0008B1r 1  2C 00 60       bit PORTB_1
0008B4r 1  20 rr rr       jsr cb1_handler
0008B7r 1  4C rr rr       jmp exit_irq
0008BAr 1               
0008BAr 1               test_cb2:
0008BAr 1               
0008BAr 1  0A             asl
0008BBr 1  90 09          bcc test_ca1
0008BDr 1  2C 00 60       bit PORTB_1
0008C0r 1  20 rr rr       jsr cb2_handler
0008C3r 1  4C rr rr       jmp exit_irq
0008C6r 1               
0008C6r 1               test_ca1:
0008C6r 1               
0008C6r 1  0A             asl           ; shift CA1 bit into the CARRY bit & test
0008C7r 1  0A             asl
0008C8r 1  90 06          bcc exit_irq        ; carry clear = leave
0008CAr 1  20 rr rr       jsr keypad_handler  ; carry not clear = handle the CA1 interrupt (keypad)
0008CDr 1  4C rr rr       jmp exit_irq
0008D0r 1               
0008D0r 1               
0008D0r 1               next_device:
0008D0r 1               
0008D0r 1               exit_irq:
0008D0r 1               
0008D0r 1  7A             ply
0008D1r 1  FA             plx
0008D2r 1  68             pla
0008D3r 1  40             rti
0008D4r 1               
0008D4r 1  4D 61 72 6B  pause_msg: .asciiz "Mark Time     "
0008D8r 1  20 54 69 6D  
0008DCr 1  65 20 20 20  
0008E3r 1  3C 73 68 69  start_msg: .asciiz "<shift>+C to start"
0008E7r 1  66 74 3E 2B  
0008EBr 1  43 20 74 6F  
0008F6r 1  56 69 65 77  new_address_msg: .asciiz "View/Edit Memory"
0008FAr 1  2F 45 64 69  
0008FEr 1  74 20 4D 65  
000907r 1  38 20 42 79  block_address_msg: .asciiz "8 Byte view"
00090Br 1  74 65 20 76  
00090Fr 1  69 65 77 00  
000913r 1  2E 2E 2E 53  title: .asciiz "...Shed Brain v1..."
000917r 1  68 65 64 20  
00091Br 1  42 72 61 69  
000927r 1  53 68 65 64  emt: .asciiz "Shed Time  MET"
00092Br 1  20 54 69 6D  
00092Fr 1  65 20 20 4D  
000936r 1  73 68 65 64  splash: .asciiz "shed> "
00093Ar 1  3E 20 00     
00093Dr 1               ;error_message: .asciiz "Not Decimal"
00093Dr 1  42 65 67 69  mem_start_msg: .asciiz "Begin RAM Test"
000941r 1  6E 20 52 41  
000945r 1  4D 20 54 65  
00094Cr 1  52 41 4D 20  mem_pass_msg: .asciiz "RAM Test Pass"
000950r 1  54 65 73 74  
000954r 1  20 50 61 73  
00095Ar 1  52 41 4D 20  mem_fail_msg_1: .asciiz "RAM Test 1 Fail"
00095Er 1  54 65 73 74  
000962r 1  20 31 20 46  
00096Ar 1  52 41 4D 20  mem_fail_msg_2: .asciiz "RAM Test 2 Fail"
00096Er 1  54 65 73 74  
000972r 1  20 32 20 46  
00097Ar 1  54 68 69 73  userPrompt: .asciiz "This is shed"
00097Er 1  20 69 73 20  
000982r 1  73 68 65 64  
000987r 1  64 05 A9 20  userProg: .byte $64, $05, $A9, $20, $85, $06, $20, <print4, >print4, $60, $00
00098Br 1  85 06 20 rr  
00098Fr 1  rr 60 00     
000992r 1               
000992r 1  01 03 06 0C  kitLeds: .byte $01, $03, $06, $0C, $18, $30, $60, $C0, $80, $C0, $60, $30, $18, $0C, $06, $03, $01
000996r 1  18 30 60 C0  
00099Ar 1  80 C0 60 30  
0009A3r 1               ; Reset/IRQ vectors
0009A3r 1               
0009A3r 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr          .word nmi
000002r 1  rr rr          .word reset
000004r 1  rr rr          .word irq
000004r 1               
