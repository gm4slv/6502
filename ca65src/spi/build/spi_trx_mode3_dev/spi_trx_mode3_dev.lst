ca65 V2.18 - Debian 2.19-1
Main file   : spi_trx_mode3_dev.s
Current file: spi_trx_mode3_dev.s

000000r 1               ;;
000000r 1               
000000r 1               
000000r 1               .zeropage
000000r 1               
000000r 1  xx xx        BEEP_POINTER:     .res 2
000002r 1  xx xx        DUMP_POINTER:     .res 2
000004r 1  xx           FLAGS:            .res 1
000005r 1  xx           TOGGLE_TIME:      .res 1
000006r 1  xx           CLOCK_LAST:       .res 1
000007r 1  xx xx        MESSAGE_POINTER:  .res 2
000009r 1  xx xx xx xx  TICKS:            .res 4
00000Dr 1  xx           CENTISEC:         .res 1
00000Er 1  xx           HUNDRED_HRS:      .res 1
00000Fr 1  xx           TEN_HRS:          .res 1
000010r 1  xx           HRS:              .res 1
000011r 1  xx           TEN_MINUTES:      .res 1
000012r 1  xx           MINUTES:          .res 1
000013r 1  xx           TEN_SECONDS:      .res 1
000014r 1  xx           SECONDS:          .res 1
000015r 1  xx xx        MEM_POINTER:      .res 2
000017r 1  xx           LED2_LAST:        .res 1
000018r 1  xx           SPI_LAST:         .res 1
000019r 1  xx           BEEP_ON_TIME:     .res 1
00001Ar 1  xx           BEEP_DELAY_TIME:  .res 1 ; $01 = 1 tick ~10ms, $FF = 255 ticks ~2.5 seconds
00001Br 1  xx xx        SPI_BYTE:         .res 2
00001Dr 1  xx xx        MAX_PAGE:         .res 2
00001Fr 1               
00001Fr 1               .bss
000000r 1               
000000r 1  xx           INKEY:            .res 1
000001r 1  xx xx xx xx  KEY_PRESS:        .res 4
000005r 1  xx xx        BYTE:             .res 2
000007r 1  xx           TENS:             .res 1
000008r 1  xx           HUNDREDS:         .res 1
000009r 1  xx xx        TEMP:             .res 2 ; 2 byte scratchpad
00000Br 1  xx xx        TEMP2:            .res 2 ; 2 byte scratchpad
00000Dr 1  xx           HI_DIGIT:         .res 1
00000Er 1  xx           LO_DIGIT:         .res 1
00000Fr 1  xx xx        VALUE:            .res 2
000011r 1  xx xx        MOD10:            .res 2
000013r 1  xx xx xx xx  num_message:      .res 6
000017r 1  xx xx        
000019r 1  xx           SPIIN:            .res 1
00001Ar 1  xx           SPIOUT:           .res 1
00001Br 1  xx xx        SPI_TX_BYTE:      .res 2
00001Dr 1  xx xx        SPI_RX_BYTE:      .res 2
00001Fr 1               
00001Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00001Fr 1               ;;
00001Fr 1               ;;        INCLUDES
00001Fr 1               ;;
00001Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00001Fr 1               
00001Fr 1               
00001Fr 1               .include "../includes/ioports.inc"
00001Fr 2               
00001Fr 2                 .code
000000r 2               
000000r 2               ; VIA_1 Port addresses
000000r 2               VIA_1     = $6000
000000r 2               PORTB_1   = VIA_1
000000r 2               PORTA_1   = VIA_1 + 1
000000r 2               DDRB_1    = VIA_1 + 2
000000r 2               DDRA_1    = VIA_1 + 3
000000r 2               T1CL_1    = VIA_1 + 4
000000r 2               T1CH_1    = VIA_1 + 5
000000r 2               T1LL_1    = VIA_1 + 6
000000r 2               T1LH_1    = VIA_1 + 7
000000r 2               T2CL_1    = VIA_1 + 8
000000r 2               T2CH_1    = VIA_1 + 9
000000r 2               SR_1      = VIA_1 + 10
000000r 2               ACR_1     = VIA_1 + 11
000000r 2               PCR_1     = VIA_1 + 12
000000r 2               IFR_1     = VIA_1 + 13
000000r 2               IER_1     = VIA_1 + 14
000000r 2               PORTA_NO_HS_1 = VIA_1 + 15
000000r 2               
000000r 2               ; VIA_2 Port addresses
000000r 2               VIA_2     = $5000
000000r 2               
000000r 2               PORTB_2   = VIA_2
000000r 2               
000000r 2               SPI_PORT  = PORTB_2
000000r 2               
000000r 2               PORTA_2   = VIA_2 + 1
000000r 2               DDRB_2    = VIA_2 + 2
000000r 2               DDRA_2    = VIA_2 + 3
000000r 2               T1CL_2    = VIA_2 + 4
000000r 2               T1CH_2    = VIA_2 + 5
000000r 2               T1LL_2    = VIA_2 + 6
000000r 2               T1LH_2    = VIA_2 + 7
000000r 2               T2CL_2    = VIA_2 + 8
000000r 2               T2CH_2    = VIA_2 + 9
000000r 2               SR_2      = VIA_2 + 10
000000r 2               ACR_2     = VIA_2 + 11
000000r 2               PCR_2     = VIA_2 + 12
000000r 2               IFR_2     = VIA_2 + 13
000000r 2               IER_2     = VIA_2 + 14
000000r 2               PORTA_NO_HS_2 = VIA_2 + 15
000000r 2               
000000r 2               ; VIA_3 Port addresses
000000r 2               VIA_3     = $4800
000000r 2               PORTB_3   = VIA_3
000000r 2               PORTA_3   = VIA_3 + 1
000000r 2               DDRB_3    = VIA_3 + 2
000000r 2               DDRA_3    = VIA_3 + 3
000000r 2               T1CL_3    = VIA_3 + 4
000000r 2               T1CH_3    = VIA_3 + 5
000000r 2               T1LL_3    = VIA_3 + 6
000000r 2               T1LH_3    = VIA_3 + 7
000000r 2               T2CL_3    = VIA_3 + 8
000000r 2               T2CH_3    = VIA_3 + 9
000000r 2               SR_3      = VIA_3 + 10
000000r 2               ACR_3     = VIA_3 + 11
000000r 2               PCR_3     = VIA_3 + 12
000000r 2               IFR_3     = VIA_3 + 13
000000r 2               IER_3     = VIA_3 + 14
000000r 2               PORTA_NO_HS_3 = VIA_3 + 15
000000r 2               
000000r 2               ; ACIA_1 Port Addresses
000000r 2               ACIA_1    = $4400
000000r 2               S_TXRX_1  = ACIA_1      ; TXD / RXD
000000r 2               S_STA_1   = ACIA_1 + 1  ; Status
000000r 2               S_COM_1   = ACIA_1 + 2  ; Command
000000r 2               S_CON_1   = ACIA_1 + 3  ; Control
000000r 2               
000000r 2               
000000r 2               via_1_init:
000000r 2               
000000r 2  A9 9A          lda #%10011010  ; CB2, CA1 active
000002r 2  8D 0E 60       sta IER_1
000005r 2               
000005r 2  A9 51          lda #%01010001  ;  CA1 active high-transition, CB2 low
000007r 2  8D 0C 60       sta PCR_1
00000Ar 2               
00000Ar 2  A9 7F          lda #%01111111 ; Set all pins on port B to output except BIT 7 which is used for "SHIFT/INSTRUCTION"  button
00000Cr 2  8D 02 60       sta DDRB_1
00000Fr 2  A9 F0          lda #%11110000 ; Set low-nibble pins on port A to input and high-nibble pins to output, for keypad
000011r 2  8D 03 60       sta DDRA_1
000014r 2               
000014r 2  60             rts
000015r 2               
000015r 2               via_2_init:
000015r 2               
000015r 2               ;; TIMER T1 is set up in functions.inc to act as source of beep tones
000015r 2               
000015r 2  A9 87          lda #%10000111 ; set all pins on port A & B to output
000017r 2               
000017r 2  8D 02 50       sta DDRB_2
00001Ar 2               
00001Ar 2  A9 FF          lda #%11111111
00001Cr 2  8D 03 50       sta DDRA_2
00001Fr 2               
00001Fr 2  A9 00          lda #%00000000
000021r 2  8D 0E 50       sta IER_2
000024r 2  60             rts
000025r 2               
000025r 2               via_3_init:
000025r 2               
000025r 2               ;; TIMER T1 used as TICK source for RTC - set for 10ms per tick
000025r 2               ;; $270E = 9998d = count 10,000 phi2 cycles @ 1MHz = 10ms per interrupt
000025r 2               
000025r 2  A9 40          lda #%01000000 ; DON'T use PB7 as a T1 pulse timer clock output (ACR b7 = 0)
000027r 2                                ; Use T1 Timer in continuous reset-interrupt mode (ACR b6 = 1)
000027r 2  8D 0B 48       sta ACR_3
00002Ar 2               
00002Ar 2                 ; set T1 delay for 10ms interrupts
00002Ar 2  A9 0E          lda #$0E
00002Cr 2  8D 04 48       sta T1CL_3
00002Fr 2  A9 27          lda #$27
000031r 2  8D 05 48       sta T1CH_3
000034r 2               
000034r 2  A9 C0          lda #%11000000  ; Interrupt / T1 interrupt active
000036r 2  8D 0E 48       sta IER_3
000039r 2               
000039r 2  A9 FF          lda #%11111111 ; set all pins on port A & B to output for now
00003Br 2  8D 03 48       sta DDRA_3
00003Er 2  8D 02 48       sta DDRB_3
000041r 2               
000041r 2  60             rts
000042r 2               
000042r 2               
000042r 2               
000042r 2               
000042r 1               .include "../includes/lcd.inc"
000042r 2               
000042r 2               .SEGMENT "DISPLAY"
000000r 2               
000000r 2               ;.code
000000r 2               
000000r 2               ; LCD Command masks
000000r 2               E  = %01000000
000000r 2               RW = %00100000
000000r 2               RS = %00010000
000000r 2               
000000r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000000r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000000r 2               ;;
000000r 2               ;;
000000r 2               ;;                              LCD Functions
000000r 2               ;;
000000r 2               ;;
000000r 2               ;;
000000r 2               
000000r 2               lcd_start:
000000r 2               
000000r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000002r 2  20 rr rr       jsr lcd_instruction
000005r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000007r 2  20 rr rr       jsr lcd_instruction
00000Ar 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00000Cr 2  20 rr rr       jsr lcd_instruction
00000Fr 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000011r 2  20 rr rr       jsr lcd_instruction
000014r 2  20 rr rr       jsr lcd_entry_mode
000017r 2  20 rr rr       jsr lcd_cursor_off
00001Ar 2                 ;jsr lcd_clear
00001Ar 2                 ; CONSIDER CHANGE
00001Ar 2  4C rr rr       jmp lcd_clear
00001Dr 2                 ;rts
00001Dr 2               
00001Dr 2               lcd_entry_mode:
00001Dr 2               
00001Dr 2  A9 06          lda #%00000110 ; Increment and shift cursor; don't shift display
00001Fr 2  4C rr rr       jmp lcd_instruction   ; (jsr/rts)
000022r 2               
000022r 2               
000022r 2               lcd_home:
000022r 2               
000022r 2  A9 02          lda #%00000010 ; cursor HOME
000024r 2  4C rr rr       jmp lcd_instruction ; (jsr/rts)
000027r 2               
000027r 2               
000027r 2               lcd_add0:
000027r 2               
000027r 2  A9 80          lda #%10000000 ; back to zero position
000029r 2  4C rr rr       jmp lcd_instruction     ; (jsr/rts)
00002Cr 2               
00002Cr 2               
00002Cr 2               lcd_clear:
00002Cr 2               
00002Cr 2  A9 01          lda #%00000001 ; Clear display
00002Er 2  4C rr rr       jmp lcd_instruction   ; (jsr/rts)
000031r 2               
000031r 2               
000031r 2               lcd_cursor_off:
000031r 2               
000031r 2  A9 0C          lda #%00001100 ; Display on; cursor off; blink off
000033r 2  4C rr rr       jmp lcd_instruction   ; (jsr/rts)
000036r 2               
000036r 2               
000036r 2               lcd_cursor_on:
000036r 2               
000036r 2  A9 0F          lda #%00001111 ; Display on; cursor on; blink on
000038r 2  4C rr rr       jmp lcd_instruction   ; (jsr/rts)
00003Br 2               
00003Br 2               
00003Br 2               lcd_line_1:
00003Br 2               
00003Br 2  A9 80          lda #($80)
00003Dr 2  4C rr rr       jmp lcd_instruction   ; (jsr/rts)
000040r 2               
000040r 2               
000040r 2               lcd_line_2:
000040r 2               
000040r 2  A9 C0          lda #($80 + $40)
000042r 2  4C rr rr       jmp lcd_instruction   ; (jsr/rts)
000045r 2               
000045r 2               
000045r 2               lcd_line_3:
000045r 2  A9 94          lda #($80 + $14)
000047r 2  4C rr rr       jmp lcd_instruction
00004Ar 2                 ;jsr lcd_instruction
00004Ar 2                 ;rts
00004Ar 2               
00004Ar 2               lcd_line_4:
00004Ar 2  A9 D4          lda #($80 + $54)
00004Cr 2  4C rr rr       jmp lcd_instruction
00004Fr 2                 ;jsr lcd_instruction
00004Fr 2                 ;rts
00004Fr 2               
00004Fr 2               lcd_wait:
00004Fr 2  48             pha
000050r 2  A9 70          lda #%01110000  ; LCD data is input (don't change MSB BIT7, it has to stay ZERO for SHIFT Button input)
000052r 2  8D 02 60       sta DDRB_1
000055r 2               lcdbusy:
000055r 2  A9 20          lda #RW
000057r 2  8D 00 60       sta PORTB_1
00005Ar 2  A9 60          lda #(RW | E)
00005Cr 2  8D 00 60       sta PORTB_1
00005Fr 2  AD 00 60       lda PORTB_1     ; Read high nibble
000062r 2  48             pha             ; and put on stack since it has the busy flag
000063r 2  A9 20          lda #RW
000065r 2  8D 00 60       sta PORTB_1
000068r 2  A9 60          lda #(RW | E)
00006Ar 2  8D 00 60       sta PORTB_1
00006Dr 2  AD 00 60       lda PORTB_1       ; Read low nibble
000070r 2  68             pla             ; Get high nibble off stack
000071r 2  29 08          and #%00001000
000073r 2  D0 E0          bne lcdbusy
000075r 2               
000075r 2  A9 20          lda #RW
000077r 2  8D 00 60       sta PORTB_1
00007Ar 2  A9 7F          lda #%01111111  ; LCD data is output (don't change MSB BIT7, it has to stay ZERO for SHIFT Buttion input)
00007Cr 2  8D 02 60       sta DDRB_1
00007Fr 2  68             pla
000080r 2  60             rts
000081r 2               
000081r 2               lcd_init:
000081r 2  A9 02          lda #%00000010 ; Set 4-bit mode : DO ONCE AT POWER UP
000083r 2  8D 00 60       sta PORTB_1
000086r 2  09 40          ora #E
000088r 2  8D 00 60       sta PORTB_1
00008Br 2  29 0F          and #%00001111
00008Dr 2  8D 00 60       sta PORTB_1
000090r 2  60             rts
000091r 2               
000091r 2               lcd_instruction:
000091r 2  20 rr rr       jsr lcd_wait
000094r 2  48             pha
000095r 2  4A             lsr
000096r 2  4A             lsr
000097r 2  4A             lsr
000098r 2  4A             lsr            ; Send high 4 bits
000099r 2  8D 00 60       sta PORTB_1
00009Cr 2  09 40          ora #E         ; Set E bit to send instruction
00009Er 2  8D 00 60       sta PORTB_1
0000A1r 2  49 40          eor #E         ; Clear E bit
0000A3r 2  8D 00 60       sta PORTB_1
0000A6r 2  68             pla
0000A7r 2  29 0F          and #%00001111 ; Send low 4 bits
0000A9r 2  8D 00 60       sta PORTB_1
0000ACr 2  09 40          ora #E         ; Set E bit to send instruction
0000AEr 2  8D 00 60       sta PORTB_1
0000B1r 2  49 40          eor #E         ; Clear E bit
0000B3r 2  8D 00 60       sta PORTB_1
0000B6r 2  60             rts
0000B7r 2               
0000B7r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000B7r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000B7r 2               ;;
0000B7r 2               ;;
0000B7r 2               ;;                              LCD 2 Functions
0000B7r 2               ;;
0000B7r 2               ;;
0000B7r 2               ;;
0000B7r 2               
0000B7r 2               lcd_2_start:
0000B7r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
0000B9r 2  20 rr rr       jsr lcd_2_instruction
0000BCr 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
0000BEr 2  20 rr rr       jsr lcd_2_instruction
0000C1r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
0000C3r 2  20 rr rr       jsr lcd_2_instruction
0000C6r 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
0000C8r 2  20 rr rr       jsr lcd_2_instruction
0000CBr 2  20 rr rr       jsr lcd_2_entry_mode
0000CEr 2  20 rr rr       jsr lcd_2_cursor_off
0000D1r 2  4C rr rr       jmp lcd_2_clear
0000D4r 2                 ;jsr lcd_2_clear
0000D4r 2                 ;rts
0000D4r 2               
0000D4r 2               lcd_2_entry_mode:
0000D4r 2  A9 06          lda #%00000110 ; Increment and shift cursor; don't shift display
0000D6r 2  4C rr rr       jmp lcd_2_instruction
0000D9r 2                 ;jsr lcd_2_instruction
0000D9r 2                 ;rts
0000D9r 2               
0000D9r 2               lcd_2_home:
0000D9r 2  A9 02          lda #%00000010 ; cursor HOME
0000DBr 2  4C rr rr       jmp lcd_2_instruction
0000DEr 2                 ;jsr lcd_2_instruction
0000DEr 2                 ;rts
0000DEr 2               
0000DEr 2               lcd_2_add0:
0000DEr 2  A9 80          lda #%10000000 ; back to zero position
0000E0r 2  4C rr rr       jmp lcd_2_instruction
0000E3r 2                 ;jsr lcd_2_instruction
0000E3r 2                 ;rts
0000E3r 2               
0000E3r 2               lcd_2_clear:
0000E3r 2  A9 01          lda #%00000001 ; Clear display
0000E5r 2  4C rr rr       jmp lcd_2_instruction
0000E8r 2                 ;jsr lcd_2_instruction
0000E8r 2                 ;rts
0000E8r 2               
0000E8r 2               lcd_2_cursor_off:
0000E8r 2  A9 0C          lda #%00001100 ; Display on; cursor off; blink off
0000EAr 2  4C rr rr       jmp lcd_2_instruction
0000EDr 2                 ;jsr lcd_2_instruction
0000EDr 2                 ;rts
0000EDr 2               
0000EDr 2               lcd_2_cursor_on:
0000EDr 2  A9 0F          lda #%00001111 ; Display on; cursor on; blink on
0000EFr 2  4C rr rr       jmp lcd_2_instruction
0000F2r 2                 ;jsr lcd_2_instruction
0000F2r 2                 ;rts
0000F2r 2               
0000F2r 2               lcd_2_line_1:
0000F2r 2  A9 80          lda #($80)
0000F4r 2  4C rr rr       jmp lcd_2_instruction
0000F7r 2                 ;jsr lcd_2_instruction
0000F7r 2                 ;rts
0000F7r 2               
0000F7r 2               lcd_2_line_2:
0000F7r 2  A9 C0          lda #($80 + $40)
0000F9r 2  4C rr rr       jmp lcd_2_instruction
0000FCr 2                 ;jsr lcd_2_instruction
0000FCr 2                 ;rts
0000FCr 2               
0000FCr 2               lcd_2_wait:
0000FCr 2  48             pha
0000FDr 2  A9 70          lda #%01110000  ; LCD data is input (don't change MSB BIT7, it has to stay ZERO for SHIFT Button input)
0000FFr 2  8D 03 48       sta DDRA_3
000102r 2               
000102r 2               lcdbusy2:
000102r 2  A9 20          lda #RW
000104r 2  8D 01 48       sta PORTA_3
000107r 2  A9 60          lda #(RW | E)
000109r 2  8D 01 48       sta PORTA_3
00010Cr 2  AD 01 48       lda PORTA_3     ; Read high nibble
00010Fr 2  48             pha             ; and put on stack since it has the busy flag
000110r 2  A9 20          lda #RW
000112r 2  8D 01 48       sta PORTA_3
000115r 2  A9 60          lda #(RW | E)
000117r 2  8D 01 48       sta PORTA_3
00011Ar 2  AD 01 48       lda PORTA_3       ; Read low nibble
00011Dr 2  68             pla             ; Get high nibble off stack
00011Er 2  29 08          and #%00001000
000120r 2  D0 E0          bne lcdbusy2
000122r 2               
000122r 2  A9 20          lda #RW
000124r 2  8D 01 48       sta PORTA_3
000127r 2  A9 7F          lda #%01111111  ; LCD data is output (don't change MSB BIT7, it has to stay ZERO for SHIFT Buttion input)
000129r 2  8D 03 48       sta DDRA_3
00012Cr 2  68             pla
00012Dr 2  60             rts
00012Er 2               
00012Er 2               lcd_2_init:
00012Er 2  A9 02          lda #%00000010 ; Set 4-bit mode : DO ONCE AT POWER UP
000130r 2  8D 01 48       sta PORTA_3
000133r 2  09 40          ora #E
000135r 2  8D 01 48       sta PORTA_3
000138r 2  29 0F          and #%00001111
00013Ar 2  8D 01 48       sta PORTA_3
00013Dr 2  60             rts
00013Er 2               
00013Er 2               lcd_2_instruction:
00013Er 2  20 rr rr       jsr lcd_2_wait
000141r 2  48             pha
000142r 2  4A             lsr
000143r 2  4A             lsr
000144r 2  4A             lsr
000145r 2  4A             lsr            ; Send high 4 bits
000146r 2  8D 01 48       sta PORTA_3
000149r 2  09 40          ora #E         ; Set E bit to send instruction
00014Br 2  8D 01 48       sta PORTA_3
00014Er 2  49 40          eor #E         ; Clear E bit
000150r 2  8D 01 48       sta PORTA_3
000153r 2  68             pla
000154r 2  29 0F          and #%00001111 ; Send low 4 bits
000156r 2  8D 01 48       sta PORTA_3
000159r 2  09 40          ora #E         ; Set E bit to send instruction
00015Br 2  8D 01 48       sta PORTA_3
00015Er 2  49 40          eor #E         ; Clear E bit
000160r 2  8D 01 48       sta PORTA_3
000163r 2  60             rts
000164r 2               
000164r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000164r 2               ;;
000164r 2               ;;        PRINT Characters on LCD 2 - an ASCII value in Accumulator
000164r 2               ;;        is printed on the display
000164r 2               ;;
000164r 2               
000164r 2               print_2_char:
000164r 2  20 rr rr       jsr lcd_2_wait
000167r 2  48             pha
000168r 2  4A             lsr
000169r 2  4A             lsr
00016Ar 2  4A             lsr
00016Br 2  4A             lsr             ; Send high 4 bits
00016Cr 2  09 10          ora #RS         ; Set RS
00016Er 2  8D 01 48       sta PORTA_3
000171r 2  09 40          ora #E          ; Set E bit to send instruction
000173r 2  8D 01 48       sta PORTA_3
000176r 2  49 40          eor #E          ; Clear E bit
000178r 2  8D 01 48       sta PORTA_3
00017Br 2  68             pla
00017Cr 2  29 0F          and #%00001111  ; Send low 4 bits
00017Er 2  09 10          ora #RS         ; Set RS
000180r 2  8D 01 48       sta PORTA_3
000183r 2  09 40          ora #E          ; Set E bit to send instruction
000185r 2  8D 01 48       sta PORTA_3
000188r 2  49 40          eor #E          ; Clear E bit
00018Ar 2  8D 01 48       sta PORTA_3
00018Dr 2  60             rts
00018Er 2               
00018Er 2               
00018Er 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00018Er 2               ;;
00018Er 2               ;;        PRINT Characters on LCD - an ASCII value in Accumulator
00018Er 2               ;;        is printed on the display
00018Er 2               ;;
00018Er 2               
00018Er 2               print_char:
00018Er 2  20 rr rr       jsr lcd_wait
000191r 2  48             pha
000192r 2  4A             lsr
000193r 2  4A             lsr
000194r 2  4A             lsr
000195r 2  4A             lsr             ; Send high 4 bits
000196r 2  09 10          ora #RS         ; Set RS
000198r 2  8D 00 60       sta PORTB_1
00019Br 2  09 40          ora #E          ; Set E bit to send instruction
00019Dr 2  8D 00 60       sta PORTB_1
0001A0r 2  49 40          eor #E          ; Clear E bit
0001A2r 2  8D 00 60       sta PORTB_1
0001A5r 2  68             pla
0001A6r 2  29 0F          and #%00001111  ; Send low 4 bits
0001A8r 2  09 10          ora #RS         ; Set RS
0001AAr 2  8D 00 60       sta PORTB_1
0001ADr 2  09 40          ora #E          ; Set E bit to send instruction
0001AFr 2  8D 00 60       sta PORTB_1
0001B2r 2  49 40          eor #E          ; Clear E bit
0001B4r 2  8D 00 60       sta PORTB_1
0001B7r 2  60             rts
0001B8r 2               
0001B8r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0001B8r 2               ;;
0001B8r 2               ;;            print on line 1 or line 2 of LCD 1 or 2
0001B8r 2               ;;
0001B8r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0001B8r 2               
0001B8r 2               
0001B8r 2               
0001B8r 2               print1:
0001B8r 2  20 rr rr       jsr lcd_line_1
0001BBr 2  A0 00          ldy #0
0001BDr 2  4C rr rr       jmp line
0001C0r 2               print2:
0001C0r 2  20 rr rr       jsr lcd_line_2
0001C3r 2  A0 00          ldy #0
0001C5r 2  4C rr rr       jmp line
0001C8r 2               print3:
0001C8r 2  20 rr rr       jsr lcd_line_3
0001CBr 2  A0 00          ldy #0
0001CDr 2  4C rr rr       jmp line
0001D0r 2               print4:
0001D0r 2  20 rr rr       jsr lcd_line_4
0001D3r 2  A0 00          ldy #0
0001D5r 2  4C rr rr       jmp line
0001D8r 2               
0001D8r 2               print2_2:
0001D8r 2  20 rr rr       jsr lcd_2_line_2
0001DBr 2  A0 00          ldy #0
0001DDr 2  4C rr rr       jmp line2
0001E0r 2               
0001E0r 2               line:
0001E0r 2  B1 rr          lda (MESSAGE_POINTER),y
0001E2r 2  F0 07          beq @exit
0001E4r 2  20 rr rr       jsr print_char
0001E7r 2  C8             iny
0001E8r 2  4C rr rr       jmp line
0001EBr 2               @exit:
0001EBr 2  60             rts
0001ECr 2               
0001ECr 2               line2:
0001ECr 2  B1 rr          lda (MESSAGE_POINTER),y
0001EEr 2  F0 07          beq @exit
0001F0r 2  20 rr rr       jsr print_2_char
0001F3r 2  C8             iny
0001F4r 2  4C rr rr       jmp line2
0001F7r 2               @exit:
0001F7r 2  60             rts
0001F8r 2               
0001F8r 2               
0001F8r 2               
0001F8r 1               .include "../includes/getkey.inc"
0001F8r 2               
0001F8r 2                 .code
000042r 2               
000042r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000042r 2               ;;
000042r 2               ;;
000042r 2               ;;      READ THE 4x4 keypad using  VIA_1 PORTA
000042r 2               ;;
000042r 2               ;;      Accumulator holds the ASCII value of the pressed key when it returns
000042r 2               ;;
000042r 2               
000042r 2               get_key:
000042r 2               readKeypad:
000042r 2  A2 04          ldx #$04        ; Row 4 - counting down
000044r 2  A0 80          ldy #%10000000  ;
000046r 2               ScanRow:
000046r 2  8C 01 60       sty PORTA_1
000049r 2  AD 01 60       lda PORTA_1
00004Cr 2  29 0F          and #$0F  ; mask off keypad input - only low 4 (keypad column) bits are read
00004Er 2  C9 00          cmp #$00
000050r 2  D0 0B          bne Row_Found   ; non-zero means a row output has been connected via a switch to a column input
000052r 2  CA             dex             ; zero means it hasn't been found, so check next row down
000053r 2  98             tya
000054r 2  4A             lsr
000055r 2  A8             tay
000056r 2  C9 08          cmp #%00001000
000058r 2  D0 EC          bne ScanRow
00005Ar 2  A9 FF          lda #$ff
00005Cr 2  60             rts
00005Dr 2               Row_Found:
00005Dr 2  8E rr rr       stx TEMP ; store row
000060r 2  A0 FF          ldy #$ff
000062r 2               FindCol:
000062r 2  C8             iny
000063r 2  4A             lsr
000064r 2  90 FC          bcc FindCol
000066r 2  98             tya
000067r 2  0A             asl
000068r 2  0A             asl  ; col * 4
000069r 2  18             clc
00006Ar 2  6D rr rr       adc TEMP ; add row
00006Dr 2  AA             tax
00006Er 2  BD rr rr       lda keypad_array,x
000071r 2  60             rts
000072r 2               
000072r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000072r 2               ;;
000072r 2               ;;       key = <INDEX> ; pressing a key returns a 4-bit number
000072r 2               ;;       calculated as (Column * 4 ) + Row, in the range
000072r 2               ;;       1 - 16 which acts as an index to a lookup-table.
000072r 2               ;;       The lookup table returns a byte value equal to the key's
000072r 2               ;;       numerical value
000072r 2               ;;       e.g.
000072r 2               ;;       button 1 returns byte $01 / 00000001
000072r 2               ;;       button F returns byte $0f / 00001111
000072r 2               ;;    ____________________________________________________
000072r 2               ;;   |     1 = <16> | 2 = <12> |    3 = <8> | A(10) = <4> |
000072r 2               ;;   |______________|__________|____________|_____________|
000072r 2               ;;   |     4 = <15> | 5 = <11> |    6 = <7> | B(11) = <3> |
000072r 2               ;;   |______________|__________|____________|_____________|
000072r 2               ;;   |     7 = <14> | 8 = <10> |    9 = <6> | C(12) = <2> |
000072r 2               ;;   |______________|__________|____________|_____________|
000072r 2               ;;   | E(14) = <13> | 0 = <9>  | F(15)= <5> | D(13) = <1> |
000072r 2               ;;   |______________|__________|____________|_____________|
000072r 2               ;;
000072r 2               ;;            Button  ..   D    C    B    A    F    9    6    3    0    8    5    2    E    7    4    1
000072r 2               ;;            <INDEX> 0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16
000072r 2  00 0D 0C 0B  keypad_array: .byte $00, $0D, $0C, $0B, $0A, $0F, $09, $06, $03, $00, $08, $05, $02, $0E, $07, $04, $01
000076r 2  0A 0F 09 06  
00007Ar 2  03 00 08 05  
000083r 2               
000083r 2               
000083r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000083r 2               ;;
000083r 2               ;;  set ROW keypad outputs high as a source for triggering interrupt when a key is pressed
000083r 2               ;;
000083r 2               ;;
000083r 2               scan:
000083r 2  A0 F0          ldy #%11110000
000085r 2  8C 01 60       sty PORTA_1
000088r 2  60             rts
000089r 2               
000089r 2               
000089r 1               .include "../includes/functions.inc"
000089r 2               
000089r 2                 .code
000089r 2               
000089r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000089r 2               ;;
000089r 2               ;;        Use T1 Timer in free-run mode to put pulse
000089r 2               ;;        train on PB7 at rate determined by
000089r 2               ;;        the chosen delay. Tone output is enabled by
000089r 2               ;;        setting bit7 of ACR register and disabled by
000089r 2               ;;        resetting it. This should really be done by or'ing
000089r 2               ;;        %10000000 with the current value of ACR, to preserve
000089r 2               ;;        the other bit-values. At the moment it's just a two
000089r 2               ;;        state setting: 11000000 = Tone On, 01000000 = Tone off.
000089r 2               ;;        bit6 of ACR sets T1 in free-run repeat mode and stays set
000089r 2               ;;
000089r 2               
000089r 2               ;; T1 Timer values:
000089r 2               
000089r 2               ;; (Phi2 / (2 * f) ) - 2
000089r 2               ;;
000089r 2               ;;  Phi2 = 1MHz = 1,000,000
000089r 2               ;;
000089r 2               ;;    f  = count => Hex    => Counter Low : Counter High
000089r 2               ;; =========================================================
000089r 2               ;;  50Hz = 9998d => $270E  => T1CL = $0E  : T1CH = $27
000089r 2               ;; 100Hz = 4998d => $1386  => T1CL = $86  : T1CH = $13
000089r 2               ;; 200Hz = 2498d => $09C2  => T1CL = $C2  : T1CH = $09
000089r 2               ;; 500Hz =  998d => $03E6  => T1CL = $E6  : T1CH = $03
000089r 2               ;; 800Hz =  623d => $026F  => T1CL = $6F  : T1CH = $02
000089r 2               ;; 1kHz  =  498d => $01F2  => T1CL = $F2  : T1CH = $01
000089r 2               ;; 2kHz  =  248d => $00F8  => T1CL = $F8  : T1CH = $00
000089r 2               ;;
000089r 2               ;; USING VIA_2 for the beep Timer/output
000089r 2               ;;
000089r 2               ;; DO NOT CONFIGURE T1 TIMER settings in ioports.inc
000089r 2               ;; They are set here whenever the beep is needed
000089r 2               ;;
000089r 2               
000089r 2               count_50 = $270E
000089r 2               count_100 = $1386
000089r 2               count_200 = $09C2
000089r 2               count_500 = $03E6
000089r 2               count_800 = $026F
000089r 2               count_1k = $01F2
000089r 2               count_2k = $00F8
000089r 2               
000089r 2               ;;               50Hz, 100Hz, 200Hz, 500Hz, 800Hz, 1kHz, 2kHz
000089r 2  0E 27 86 13  beepList: .word $270E, $1386, $09C2, $03E6, $026F, $01F2, $00F8
00008Dr 2  C2 09 E6 03  
000091r 2  6F 02 F2 01  
000097r 2               
000097r 2               ;; Load A with the required index and call beep_from_list
000097r 2               
000097r 2               beep_from_list:
000097r 2               
000097r 2  0A             asl
000098r 2  A8             tay
000099r 2  B9 rr rr       lda beepList,y
00009Cr 2  8D 04 50       sta T1CL_2
00009Fr 2  C8             iny
0000A0r 2  B9 rr rr       lda beepList,y
0000A3r 2  8D 05 50       sta T1CH_2
0000A6r 2               
0000A6r 2  A9 C0          lda #%11000000
0000A8r 2  8D 0B 50       sta ACR_2
0000ABr 2               
0000ABr 2  4C rr rr       jmp beep_on   ; (jsr/rts)
0000AEr 2               
0000AEr 2               
0000AEr 2               beep:
0000AEr 2               
0000AEr 2               ;; 800Hz keybeep
0000AEr 2               
0000AEr 2  A9 6F          lda #<count_800
0000B0r 2  8D 04 50       sta T1CL_2
0000B3r 2  A9 02          lda #>count_800
0000B5r 2  8D 05 50       sta T1CH_2
0000B8r 2               
0000B8r 2  4C rr rr       jmp beep_on   ; (jsr/rts)
0000BBr 2               
0000BBr 2               beep_on:
0000BBr 2               
0000BBr 2  A5 rr            lda TICKS
0000BDr 2  85 rr            sta BEEP_ON_TIME
0000BFr 2  A9 C0            lda #%11000000
0000C1r 2  8D 0B 50         sta ACR_2
0000C4r 2  F7 rr            smb7 FLAGS
0000C6r 2  60               rts
0000C7r 2               
0000C7r 2               beep_off:
0000C7r 2               
0000C7r 2  77 rr          rmb7 FLAGS
0000C9r 2  A9 40          lda #%01000000
0000CBr 2  8D 0B 50       sta ACR_2
0000CEr 2  A9 0A          lda #$0A              ; restore standard 0.1s Beep length in case the caller had set a
0000D0r 2  85 rr          sta BEEP_DELAY_TIME   ; new BEEP_DELAY_TIME
0000D2r 2  60             rts
0000D3r 2               
0000D3r 2               beep_from_pointer:  ; put the 2 bytes for the required count into BEEP_POINTER and BEEP_POINTER + 1 and then
0000D3r 2                                   ; call beep_from_pointer
0000D3r 2               
0000D3r 2  A5 rr          lda BEEP_POINTER
0000D5r 2  8D 04 50       sta T1CL_2
0000D8r 2  A5 rr          lda BEEP_POINTER + 1
0000DAr 2  8D 05 50       sta T1CH_2
0000DDr 2               
0000DDr 2  4C rr rr       jmp beep_on   ; (jsr/rts)
0000E0r 2               
0000E0r 2               beep2: ; high/low beep for boot-up success notification
0000E0r 2               
0000E0r 2               ; 1kHz
0000E0r 2  A9 F2          lda #<count_1k
0000E2r 2  8D 04 50       sta T1CL_2
0000E5r 2  A9 01          lda #>count_1k
0000E7r 2  8D 05 50       sta T1CH_2
0000EAr 2               
0000EAr 2  A9 C0          lda #%11000000
0000ECr 2  8D 0B 50       sta ACR_2
0000EFr 2               
0000EFr 2  20 rr rr       jsr beep_delay
0000F2r 2               
0000F2r 2               ; 800Hz
0000F2r 2  A9 6F          lda #<count_800
0000F4r 2  8D 04 50       sta T1CL_2
0000F7r 2  A9 02          lda #>count_800
0000F9r 2  8D 05 50       sta T1CH_2
0000FCr 2               
0000FCr 2  20 rr rr       jsr beep_delay
0000FFr 2               
0000FFr 2  A9 40          lda #%01000000
000101r 2  8D 0B 50       sta ACR_2
000104r 2  60             rts
000105r 2               
000105r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000105r 2               ;;
000105r 2               ;;      basic loop delay to make the beep
000105r 2               ;;
000105r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000105r 2               
000105r 2               beep_delay:
000105r 2               
000105r 2  A2 FF          ldx #$ff
000107r 2  A0 38          ldy #$38  ; <= set here to adjust the beep length
000109r 2               @loop:
000109r 2  EA             nop
00010Ar 2  CA             dex
00010Br 2  D0 FC          bne @loop
00010Dr 2  88             dey
00010Er 2  D0 F9          bne @loop
000110r 2  60             rts
000111r 2               
000111r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000111r 2               ;;
000111r 2               ;;          convert an 8-bit binary number from Accumulator, in range 00000000 -> 11111111 ($00 to $FF)
000111r 2               ;;          to its HEX number encode as ASCII -  using a simple lookup table. Store each digit in RAM. Accumulator
000111r 2               ;;          holds the last/low digit on return.
000111r 2               ;;
000111r 2               
000111r 2               
000111r 2               bintohex:
000111r 2               
000111r 2  48             pha
000112r 2  4A             lsr
000113r 2  4A             lsr
000114r 2  4A             lsr
000115r 2  4A             lsr
000116r 2  AA             tax
000117r 2  BD rr rr       lda hexascii,x
00011Ar 2  8D rr rr       sta HI_DIGIT
00011Dr 2  68             pla
00011Er 2  29 0F          and #$0f
000120r 2  AA             tax
000121r 2  BD rr rr       lda hexascii,x
000124r 2  8D rr rr       sta LO_DIGIT
000127r 2  60             rts
000128r 2               
000128r 2  30 31 32 33  hexascii: .byte "0123456789ABCDEF"
00012Cr 2  34 35 36 37  
000130r 2  38 39 41 42  
000138r 2               
000138r 2               bintohex_2:
000138r 2               
000138r 2  48             pha
000139r 2  4A             lsr
00013Ar 2  4A             lsr
00013Br 2  4A             lsr
00013Cr 2  4A             lsr
00013Dr 2  AA             tax
00013Er 2  BD rr rr       lda hexascii,x
000141r 2  20 rr rr       jsr print_2_char
000144r 2  68             pla
000145r 2  29 0F          and #$0f
000147r 2  AA             tax
000148r 2  BD rr rr       lda hexascii,x
00014Br 2               
00014Br 2  4C rr rr       jmp print_2_char  ; (jsr/rts)
00014Er 2               
00014Er 2               
00014Er 2               
00014Er 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00014Er 2               ;;
00014Er 2               ;;    convert a binary (hex) value in Accumulator into
00014Er 2               ;;    its ASCII equivalent character in decimal 0-99 and print it
00014Er 2               ;;    this converts hex/binary numbers from the RTC into human readable
00014Er 2               ;;    decimal for display on clock
00014Er 2               
00014Er 2               bintoascii:
00014Er 2               
00014Er 2  C9 0A          cmp #10
000150r 2  30 0F          bmi single_figure
000152r 2  0A             asl
000153r 2  AA             tax
000154r 2  BD rr rr       lda binascii,x
000157r 2  20 rr rr       jsr print_char
00015Ar 2               
00015Ar 2  E8             inx
00015Br 2               
00015Br 2  BD rr rr       lda binascii,x
00015Er 2               
00015Er 2  4C rr rr       jmp print_char    ; (jsr/rts)
000161r 2               
000161r 2               
000161r 2               single_figure:
000161r 2               
000161r 2  0A             asl
000162r 2  AA             tax
000163r 2  E8             inx
000164r 2  BD rr rr       lda binascii,x
000167r 2  4C rr rr       jmp print_char    ; (jsr/rts)
00016Ar 2               
00016Ar 2               
00016Ar 2               bintoascii_2:
00016Ar 2               
00016Ar 2  C9 0A          cmp #10
00016Cr 2  30 0F          bmi single_figure_2
00016Er 2  0A             asl
00016Fr 2  AA             tax
000170r 2  BD rr rr       lda binascii,x
000173r 2  20 rr rr       jsr print_2_char
000176r 2               
000176r 2  E8             inx
000177r 2               
000177r 2  BD rr rr       lda binascii,x
00017Ar 2               
00017Ar 2  4C rr rr       jmp print_2_char    ; (jsr/rts)
00017Dr 2               
00017Dr 2               single_figure_2:
00017Dr 2               
00017Dr 2  0A             asl
00017Er 2  AA             tax
00017Fr 2  E8             inx
000180r 2  BD rr rr       lda binascii,x
000183r 2               
000183r 2  4C rr rr       jmp print_2_char    ; (jsr/rts)
000186r 2               
000186r 2               
000186r 2  30 30 30 31  binascii: .byte "00010203040506070809"
00018Ar 2  30 32 30 33  
00018Er 2  30 34 30 35  
00019Ar 2  31 30 31 31            .byte "10111213141516171819"
00019Er 2  31 32 31 33  
0001A2r 2  31 34 31 35  
0001AEr 2  32 30 32 31            .byte "20212223242526272829"
0001B2r 2  32 32 32 33  
0001B6r 2  32 34 32 35  
0001C2r 2  33 30 33 31            .byte "30313233343536373839"
0001C6r 2  33 32 33 33  
0001CAr 2  33 34 33 35  
0001D6r 2  34 30 34 31            .byte "40414243444546474849"
0001DAr 2  34 32 34 33  
0001DEr 2  34 34 34 35  
0001EAr 2  35 30 35 31            .byte "50515253545556575859"
0001EEr 2  35 32 35 33  
0001F2r 2  35 34 35 35  
0001FEr 2  36 30 36 31            .byte "60616263646566676869"
000202r 2  36 32 36 33  
000206r 2  36 34 36 35  
000212r 2  37 30 37 31            .byte "70717273747576777879"
000216r 2  37 32 37 33  
00021Ar 2  37 34 37 35  
000226r 2  38 30 38 31            .byte "80818283848586878889"
00022Ar 2  38 32 38 33  
00022Er 2  38 34 38 35  
00023Ar 2  39 30 39 31            .byte "90919293949596979899"
00023Er 2  39 32 39 33  
000242r 2  39 34 39 35  
00024Er 2               
00024Er 2               
00024Er 2               
00024Er 2               
00024Er 1               .include "../includes/rtc.inc"
00024Er 2               
00024Er 2               
00024Er 2               
00024Er 2               
00024Er 2                 .code
00024Er 2               
00024Er 2               
00024Er 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00024Er 2               ;;
00024Er 2               ;;                          RTC / Jiffy Tick
00024Er 2               ;;
00024Er 2               
00024Er 2               
00024Er 2               
00024Er 2               rtc:
00024Er 2               
00024Er 2               
00024Er 2               ;;  RTC stores ticks at 10ms intervals into a 4-byte (32 bit) value
00024Er 2               ;;
00024Er 2               ;;  as each byte rolls over the next one is incremented
00024Er 2               ;;  on a tick that doesn't roll over the TIME OF DAY
00024Er 2               ;;  is updated
00024Er 2               
00024Er 2  E6 rr          inc TICKS
000250r 2  D0 0A          bne inc_MET
000252r 2  E6 rr          inc TICKS + 1
000254r 2  D0 06          bne inc_MET
000256r 2  E6 rr          inc TICKS + 2
000258r 2  D0 02          bne inc_MET
00025Ar 2  E6 rr          inc TICKS + 3
00025Cr 2               
00025Cr 2               ;;
00025Cr 2               ;;  Every time it's called we increment the "hundredths of a second" byte
00025Cr 2               ;;
00025Cr 2               ;;  When there's been 100 x 10ms (i.e. 1 second) we increment the seconds
00025Cr 2               ;;
00025Cr 2               ;; We keep the times in single digits, SECONDS, TEN_SECONDS, MINUTES,
00025Cr 2               ;; TEN_MINUTES etc.... to make it easy to display
00025Cr 2               ;; The values are stored in RAM as binary values, and need to be converted to
00025Cr 2               ;; ASCII characters when they are displayed on LCD
00025Cr 2               ;;
00025Cr 2               ;;  The basis of this routine comes from http://wilsonminesco.com/6502interrupts/#2.1
00025Cr 2               ;;
00025Cr 2               inc_MET:
00025Cr 2  E6 rr          inc CENTISEC
00025Er 2  A5 rr          lda CENTISEC
000260r 2  C9 64          cmp #100
000262r 2  30 40          bmi end_MET
000264r 2  64 rr          stz CENTISEC
000266r 2               
000266r 2  E6 rr          inc SECONDS
000268r 2  A5 rr          lda SECONDS
00026Ar 2  C9 0A          cmp #10
00026Cr 2  30 36          bmi end_MET
00026Er 2  64 rr          stz SECONDS
000270r 2  E6 rr          inc TEN_SECONDS
000272r 2               
000272r 2  A5 rr          lda TEN_SECONDS
000274r 2  C9 06          cmp #6
000276r 2  30 2C          bmi end_MET
000278r 2  64 rr          stz TEN_SECONDS
00027Ar 2               
00027Ar 2  E6 rr          inc MINUTES
00027Cr 2  A5 rr          lda MINUTES
00027Er 2  C9 0A          cmp #10
000280r 2  30 22          bmi end_MET
000282r 2  64 rr          stz MINUTES
000284r 2               
000284r 2  E6 rr          inc TEN_MINUTES
000286r 2  A5 rr          lda TEN_MINUTES
000288r 2  C9 06          cmp #6
00028Ar 2  30 18          bmi end_MET
00028Cr 2  64 rr          stz TEN_MINUTES
00028Er 2               
00028Er 2  E6 rr          inc HRS
000290r 2  A5 rr          lda HRS
000292r 2  C9 0A          cmp #10
000294r 2  30 0E          bmi end_MET
000296r 2  64 rr          stz HRS
000298r 2               
000298r 2  E6 rr          inc TEN_HRS
00029Ar 2  A5 rr          lda TEN_HRS
00029Cr 2  C9 0A          cmp #10
00029Er 2  30 04          bmi end_MET
0002A0r 2  64 rr          stz TEN_HRS
0002A2r 2               ;
0002A2r 2  E6 rr          inc HUNDRED_HRS
0002A4r 2               
0002A4r 2               end_MET:
0002A4r 2  60             rts
0002A5r 2               
0002A5r 2               
0002A5r 1               .include "../includes/spi_trx_mode3.inc"
0002A5r 2               ;;;;;;;;;;;;;;;;;;;
0002A5r 2               ;;
0002A5r 2               ;;    from Ben Eater's video
0002A5r 2               ;;
0002A5r 2               
0002A5r 2               .code
0002A5r 2               
0002A5r 2               
0002A5r 2               SCK   = %00000001
0002A5r 2               MOSI  = %00000010
0002A5r 2               CS    = %00000100
0002A5r 2               MISO  = %01000000
0002A5r 2               
0002A5r 2               spi_transceive:
0002A5r 2               
0002A5r 2  9C rr rr       stz SPIIN
0002A8r 2  8D rr rr       sta SPIOUT
0002ABr 2               
0002ABr 2  A0 08          ldy #08
0002ADr 2               
0002ADr 2  A9 02          lda #MOSI
0002AFr 2               
0002AFr 2               spi_loop:
0002AFr 2               
0002AFr 2  18             clc
0002B0r 2  0E rr rr       asl SPIOUT
0002B3r 2  B0 06          bcs spi_1
0002B5r 2  1C 00 50       trb SPI_PORT
0002B8r 2  4C rr rr       jmp spi_2
0002BBr 2               
0002BBr 2               spi_1:
0002BBr 2               
0002BBr 2  0C 00 50       tsb SPI_PORT
0002BEr 2               
0002BEr 2               spi_2:
0002BEr 2               
0002BEr 2                 ;; MODE 1 & Mode 3
0002BEr 2                 ;; CPHA 1 = read on falling edge
0002BEr 2                 ;; PUT A BRANCH HERE TO MAKE SWAPPING MODES EASIER?
0002BEr 2               
0002BEr 2  CE 00 50       dec SPI_PORT
0002C1r 2               
0002C1r 2  2C 00 50       bit SPI_PORT
0002C4r 2  18             clc
0002C5r 2  50 01          bvc spi_3
0002C7r 2  38             sec
0002C8r 2               
0002C8r 2               spi_3:
0002C8r 2               
0002C8r 2  2E rr rr       rol SPIIN
0002CBr 2               
0002CBr 2                 ;; MODE 1 & MODE 3
0002CBr 2                 ;; CPHA 1 = shif new data outon rising edge
0002CBr 2                 ;; PUT A BRANCH HERE TO MAKE SWAPPING MODES EASIER?
0002CBr 2               
0002CBr 2  EE 00 50       inc SPI_PORT
0002CEr 2               
0002CEr 2  88             dey
0002CFr 2  D0 DE          bne spi_loop
0002D1r 2  AD rr rr       lda SPIIN
0002D4r 2  18             clc
0002D5r 2               
0002D5r 2  8D 01 50       sta PORTA_2   ; show on LEDs just for fun
0002D8r 2               
0002D8r 2  60             rts
0002D9r 2               
0002D9r 2               
0002D9r 2               
0002D9r 1               .include "../includes/printval.inc"
0002D9r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002D9r 2               ;;
0002D9r 2               ;;     Ben Eater's "Binary to decimal number" routine
0002D9r 2               ;;
0002D9r 2               ;;     https://www.youtube.com/watch?v=v3-a-zqKfgA
0002D9r 2               ;;
0002D9r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002D9r 2               
0002D9r 2               ;; We need caller to set VALUE and VALUE + 1 with the low and high bytes of the number to
0002D9r 2               ;; be printed.
0002D9r 2               
0002D9r 2               ;; When we return we leave the number converted to an ascii string that can be printed
0002D9r 2               
0002D9r 2               print_value:
0002D9r 2               
0002D9r 2  9C rr rr       stz num_message
0002DCr 2               
0002DCr 2                  ; clear the string to hold the result
0002DCr 2               
0002DCr 2               divide:
0002DCr 2               
0002DCr 2               ; initialize remainder to  be zero
0002DCr 2  9C rr rr       stz MOD10
0002DFr 2  9C rr rr       stz MOD10 + 1
0002E2r 2               
0002E2r 2  18             clc
0002E3r 2  A2 10          ldx #16    ; index for looping through the 16 bits of VALUE and VALUE+1
0002E5r 2               
0002E5r 2               div_loop:
0002E5r 2               
0002E5r 2               ; rotate QUOTIENT and REMAINDER
0002E5r 2               ; this effectively moved the point that we're subtracting
0002E5r 2               ; 10 (to divide-by-ten) bit-by-bit through the VALUE
0002E5r 2               ; checking ast each bit-place if we find a point where the subtraction of 10
0002E5r 2               ; leaves a positive remainder
0002E5r 2               
0002E5r 2  2E rr rr       rol VALUE       ; rotate each bit of VALUE into MOD10 in turn
0002E8r 2  2E rr rr       rol VALUE + 1
0002EBr 2  2E rr rr       rol MOD10
0002EEr 2  2E rr rr       rol MOD10 + 1
0002F1r 2               
0002F1r 2               ; a, y = DIVIDEND minus DIVISOR
0002F1r 2  38             sec            ; subtract 10d from MOD10 and test the remainder
0002F2r 2  AD rr rr       lda MOD10
0002F5r 2  E9 0A          sbc #10
0002F7r 2  A8             tay           ; save low BYTE of the subtraction in Y
0002F8r 2  AD rr rr       lda MOD10 + 1 ; load the high BYTE into A
0002FBr 2  E9 00          sbc #0        ; finish the 16-bit two step "subtract 10" and leave the HIGH byte result in A
0002FDr 2               
0002FDr 2  90 06          bcc ignore_result ; REMAINDER is negative, we borrowed from CARRY, therefore DIVIDEND was LESS THAN the DIVISOR so we
0002FFr 2                                   ; skip past the next 2 instructions, we need to find a situation where the REMAINDER was POSITIVE
0002FFr 2                                   ; i.e. CARRY was left alone
0002FFr 2               
0002FFr 2               
0002FFr 2               
0002FFr 2               ; DIVIDEND was > DIVISOR, REMAINDER is POSITIVE so we put the REMAINDER (held in y and a) back to
0002FFr 2               ; MOD10 and MOD10 + 1
0002FFr 2               
0002FFr 2  8C rr rr       sty MOD10
000302r 2  8D rr rr       sta MOD10 + 1
000305r 2               
000305r 2               ; we now go around again...
000305r 2               
000305r 2               ignore_result:
000305r 2               
000305r 2  CA             dex          ; we need to process the next bit of VALUE using the new MOD10/MOD10+1
000306r 2  D0 DD          bne div_loop ; until all 16 bits have been processed
000308r 2               
000308r 2               ; MOD10 now finally holds the required binary number of the (n'th) decimal digit of VALUE
000308r 2               
000308r 2               
000308r 2               ; need to rotate the VALUE to put carry back at the beginning and set it up for the next digit calculation
000308r 2  2E rr rr       rol VALUE     ;
00030Br 2  2E rr rr       rol VALUE + 1 ;  VALUE/VALUE + 1 now holds previous VALUE divided by 10, ignoring the remainder ready for the
00030Er 2                               ;  next digit calculation
00030Er 2               
00030Er 2  AD rr rr       lda MOD10     ;  put calculated (n'th) digit into A to send to the ouptut string
000311r 2               
000311r 2  18             clc
000312r 2  69 30          adc #$30     ; add $30 to convert the number into its ASCII encoded version
000314r 2               
000314r 2  20 rr rr       jsr push_char ; send the new digit to be added to the output num_message string, in the
000317r 2                               ; correct place (at the far end)
000317r 2               
000317r 2               ; check if VALUE/VALUE + 1 is ZERO (we've done all the decimal digits of the initial VALUE/VALUE+1)
000317r 2               ; If not, go back round and check the next digit
000317r 2               
000317r 2  AD rr rr       lda VALUE
00031Ar 2  0D rr rr       ora VALUE + 1
00031Dr 2  D0 BD          bne divide
00031Fr 2               
00031Fr 2               ;; our result is that "num_message" now holds an ASCII string,
00031Fr 2               ;; zero terminated, representing the input 16 bit VALUE
00031Fr 2               ;;
00031Fr 2               ;; we don't print it from here.
00031Fr 2               ;;
00031Fr 2               ;; to print it we use the normal method
00031Fr 2               ;;
00031Fr 2               ;; lda #<num_message
00031Fr 2               ;; sta MESSAGE_POINTER
00031Fr 2               ;; lda #>num_message
00031Fr 2               ;; sta MESSAGE_POINTER + 1
00031Fr 2               ;; jsr 'print' (i.e. whichever print function we need to put the number on the correct LCD line)
00031Fr 2               
00031Fr 2  60             rts
000320r 2               
000320r 2               ;
000320r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000320r 2               ;;
000320r 2               ;; put each digit onto the num_message string at the end - the string is shuffled
000320r 2               ;; each time to build it "backwards"
000320r 2               
000320r 2               push_char:
000320r 2               
000320r 2  48             pha
000321r 2  A0 00          ldy #0
000323r 2               
000323r 2               char_loop:
000323r 2               
000323r 2  B9 rr rr       lda num_message,y
000326r 2  AA             tax
000327r 2  68             pla
000328r 2  99 rr rr       sta num_message,y
00032Br 2  C8             iny
00032Cr 2  8A             txa
00032Dr 2  48             pha
00032Er 2  D0 F3          bne char_loop
000330r 2  68             pla
000331r 2  99 rr rr       sta num_message,y
000334r 2  60             rts
000335r 2               
000335r 1               
000335r 1               
000335r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000335r 1               ;;
000335r 1               ;;         START HERE
000335r 1               ;;
000335r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000335r 1               
000335r 1               .code
000335r 1               
000335r 1               reset:
000335r 1               
000335r 1  A2 FF          ldx #$ff
000337r 1  9A             txs
000338r 1  58             cli      ; interrupts ON
000339r 1               
000339r 1  20 rr rr       jsr via_1_init
00033Cr 1  A9 00          lda #%00000000  ;
00033Er 1  8D 0E 60       sta IER_1       ; stop Keypad or buttons triggering interrupts until we're ready for them
000341r 1               
000341r 1  A9 00          lda #%00000000  ;
000343r 1  8D 03 60       sta DDRA_1      ; disable keypad until we're ready for it
000346r 1               
000346r 1  A9 00          lda #%00000000
000348r 1  8D 0B 50       sta ACR_2       ; disable VIA T1 driven beep noises until we're ready for them
00034Br 1               
00034Br 1               
00034Br 1  20 rr rr       jsr lcd_start ; set-up various features of lcd
00034Er 1  20 rr rr       jsr lcd_2_start ; set-up various features of lcd
000351r 1               
000351r 1               
000351r 1               init_variables:
000351r 1               
000351r 1  64 rr          stz TICKS
000353r 1  64 rr          stz TICKS + 1
000355r 1  64 rr          stz TICKS + 2
000357r 1  64 rr          stz TICKS + 3
000359r 1  64 rr          stz DUMP_POINTER
00035Br 1  64 rr          stz DUMP_POINTER + 1
00035Dr 1  64 rr          stz MESSAGE_POINTER
00035Fr 1  64 rr          stz MESSAGE_POINTER + 1
000361r 1  A9 3F          lda #$3F
000363r 1  85 rr          sta BEEP_POINTER
000365r 1  A9 03          lda #$03
000367r 1  85 rr          sta BEEP_POINTER + 1
000369r 1  A9 0A          lda #$0A              ; standard BEEP = 10 ticks, ~100mS
00036Br 1  85 rr          sta BEEP_DELAY_TIME
00036Dr 1  64 rr          stz TOGGLE_TIME
00036Fr 1  64 rr          stz CLOCK_LAST
000371r 1  64 rr          stz LED2_LAST
000373r 1  64 rr          stz SPI_LAST
000375r 1  64 rr          stz CENTISEC
000377r 1  64 rr          stz FLAGS
000379r 1  64 rr          stz SECONDS
00037Br 1  64 rr          stz TEN_SECONDS
00037Dr 1  64 rr          stz MINUTES
00037Fr 1  64 rr          stz HRS
000381r 1  64 rr          stz TEN_HRS
000383r 1  64 rr          stz TEN_MINUTES
000385r 1  64 rr          stz HUNDRED_HRS
000387r 1  9C rr rr       stz TEMP
00038Ar 1  9C rr rr       stz TEMP2
00038Dr 1  9C rr rr       stz TENS
000390r 1  64 rr          stz MEM_POINTER
000392r 1  64 rr          stz MEM_POINTER + 1
000394r 1  9C rr rr       stz HI_DIGIT
000397r 1  9C rr rr       stz LO_DIGIT
00039Ar 1  9C rr rr       stz MOD10
00039Dr 1  9C rr rr       stz MOD10 + 1
0003A0r 1  9C rr rr       stz VALUE
0003A3r 1  9C rr rr       stz VALUE + 1
0003A6r 1               
0003A6r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003A6r 1               ;;
0003A6r 1               ;;    First Signs of Life
0003A6r 1               ;;
0003A6r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003A6r 1               
0003A6r 1  A9 rr          lda #<title
0003A8r 1  85 rr          sta MESSAGE_POINTER
0003AAr 1  A9 rr          lda #>title
0003ACr 1  85 rr          sta MESSAGE_POINTER + 1
0003AEr 1  20 rr rr       jsr print1
0003B1r 1               
0003B1r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003B1r 1               ;;
0003B1r 1               ;;  Find extent of usable RAM
0003B1r 1               ;;
0003B1r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003B1r 1               
0003B1r 1               memory_count:
0003B1r 1               
0003B1r 1  A9 rr          lda #<mem_start_msg
0003B3r 1  85 rr          sta MESSAGE_POINTER
0003B5r 1  A9 rr          lda #>mem_start_msg
0003B7r 1  85 rr          sta MESSAGE_POINTER + 1
0003B9r 1  20 rr rr       jsr print2
0003BCr 1               
0003BCr 1               
0003BCr 1               ;; Write $55 to each memory location until it fails
0003BCr 1               ;; to be read correctly = top of RAM area
0003BCr 1               
0003BCr 1               ;; Test between $0200 and $FFFF
0003BCr 1               
0003BCr 1  A9 02          lda #$02            ; start at $0200
0003BEr 1  85 rr          sta MEM_POINTER + 1
0003C0r 1  A0 00          ldy #$00
0003C2r 1               
0003C2r 1               count_loop_ram:
0003C2r 1               
0003C2r 1  A9 55          lda #$55              ; test with 01010101
0003C4r 1  91 rr          sta (MEM_POINTER),y   ; write test value to RAM
0003C6r 1  A9 FF          lda #$FF              ; remove test value from A
0003C8r 1  B1 rr          lda (MEM_POINTER),y   ; read RAM contents into A
0003CAr 1  C9 55          cmp #$55
0003CCr 1  D0 12          bne count_done_ram    ; FAILS at first address after top of RAM
0003CEr 1               
0003CEr 1  C8             iny
0003CFr 1  F0 03          beq count_next_page
0003D1r 1               
0003D1r 1  4C rr rr       jmp count_loop_ram
0003D4r 1               
0003D4r 1               count_next_page:
0003D4r 1               
0003D4r 1  A5 rr          lda MEM_POINTER + 1
0003D6r 1  1A             inc
0003D7r 1  C9 FF          cmp #$FF            ; endstop page = top of 6502 Address Space!
0003D9r 1  F0 05          beq count_done_ram
0003DBr 1               
0003DBr 1  85 rr          sta MEM_POINTER + 1
0003DDr 1  4C rr rr       jmp count_loop_ram
0003E0r 1               
0003E0r 1               count_done_ram:
0003E0r 1               
0003E0r 1  85 rr          sta MAX_PAGE        ; last successful RAM Page stored for
0003E2r 1                                     ; subsequent RAM clear end point
0003E2r 1               
0003E2r 1                ;; calculate total number of usable bytes in RAM ($0000 -> $[MEM_POINTER+1 MEM_POINTER] + y )
0003E2r 1               
0003E2r 1  98             tya
0003E3r 1  18             clc
0003E4r 1  65 rr          adc MEM_POINTER
0003E6r 1  8D rr rr       sta VALUE           ; store for print_value function
0003E9r 1  85 rr          sta MEM_POINTER     ; store for later
0003EBr 1  A5 rr          lda MEM_POINTER + 1
0003EDr 1  69 00          adc #0
0003EFr 1  8D rr rr       sta VALUE + 1       ; store for print_value function
0003F2r 1  85 rr          sta MEM_POINTER + 1 ; store for later
0003F4r 1  18             clc
0003F5r 1               
0003F5r 1  20 rr rr       jsr print_value     ; convert 2-bytes of VALUE into a decimal number of useable RAM bytes
0003F8r 1               
0003F8r 1  A9 rr          lda #<num_message   ; and print it
0003FAr 1  85 rr          sta MESSAGE_POINTER
0003FCr 1  A9 rr          lda #>num_message
0003FEr 1  85 rr          sta MESSAGE_POINTER + 1
000400r 1  20 rr rr       jsr print4
000403r 1               
000403r 1  A9 20          lda #' '
000405r 1  20 rr rr       jsr print_char
000408r 1  A9 42          lda #'B'
00040Ar 1  20 rr rr       jsr print_char
00040Dr 1  A9 79          lda #'y'
00040Fr 1  20 rr rr       jsr print_char
000412r 1  A9 74          lda #'t'
000414r 1  20 rr rr       jsr print_char
000417r 1  A9 65          lda #'e'
000419r 1  20 rr rr       jsr print_char
00041Cr 1  A9 73          lda #'s'
00041Er 1  20 rr rr       jsr print_char
000421r 1               
000421r 1  A9 20          lda #' '
000423r 1  20 rr rr       jsr print_char
000426r 1  A9 28          lda #'('
000428r 1  20 rr rr       jsr print_char
00042Br 1  A9 24          lda #'$'
00042Dr 1  20 rr rr       jsr print_char
000430r 1               
000430r 1  38             sec               ; the actual "Top of RAM" found is the first UNusable byte, so we
000431r 1  A5 rr          lda MEM_POINTER   ; want the "one before that" to show where the real "Top of RAM"
000433r 1  E9 01          sbc #$01          ; is, so subtract 1 from the 2-byte MEM_POINTER just arrived at above
000435r 1  8D rr rr       sta TEMP
000438r 1  A5 rr          lda MEM_POINTER + 1
00043Ar 1  E9 00          sbc #$0
00043Cr 1  8D rr rr       sta TEMP + 1
00043Fr 1               
00043Fr 1  AD rr rr       lda TEMP + 1
000442r 1  20 rr rr       jsr bintohex
000445r 1  AD rr rr       lda HI_DIGIT
000448r 1  20 rr rr       jsr print_char
00044Br 1  AD rr rr       lda LO_DIGIT
00044Er 1  20 rr rr       jsr print_char
000451r 1               
000451r 1  AD rr rr       lda TEMP
000454r 1  20 rr rr       jsr bintohex
000457r 1  AD rr rr       lda HI_DIGIT
00045Ar 1  20 rr rr       jsr print_char
00045Dr 1  AD rr rr       lda LO_DIGIT
000460r 1  20 rr rr       jsr print_char
000463r 1               
000463r 1  A9 29          lda #')'
000465r 1  20 rr rr       jsr print_char
000468r 1               
000468r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000468r 1               ;;
000468r 1               ;; Clear RAM of the "$55" put in duing the Mem Count above.
000468r 1               ;;
000468r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000468r 1               
000468r 1               memory_zero:
000468r 1               
000468r 1               ;; test then clear RAM between
000468r 1               ;; $0200 - $3FFF - avoids the ZP and STACK areas
000468r 1               
000468r 1  A9 02          lda #$02            ; start at $0200
00046Ar 1  85 rr          sta MEM_POINTER + 1
00046Cr 1               
00046Cr 1  A0 00          ldy #$00
00046Er 1               
00046Er 1               loop_ram:
00046Er 1               
00046Er 1  A9 00          lda #$00              ; clear RAM with 00000000
000470r 1  91 rr          sta (MEM_POINTER),y
000472r 1  C8             iny
000473r 1  F0 03          beq next_page
000475r 1               
000475r 1  4C rr rr       jmp loop_ram
000478r 1               
000478r 1               next_page:
000478r 1               
000478r 1  A5 rr          lda MEM_POINTER + 1
00047Ar 1  1A             inc
00047Br 1  C5 rr          cmp MAX_PAGE
00047Dr 1  F0 05          beq done_ram
00047Fr 1               
00047Fr 1  85 rr          sta MEM_POINTER + 1
000481r 1  4C rr rr       jmp loop_ram
000484r 1               
000484r 1               done_ram:
000484r 1               
000484r 1  A9 rr          lda #<mem_complete_msg
000486r 1  85 rr          sta MESSAGE_POINTER
000488r 1  A9 rr          lda #>mem_complete_msg
00048Ar 1  85 rr          sta MESSAGE_POINTER + 1
00048Cr 1  20 rr rr       jsr print3
00048Fr 1               
00048Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00048Fr 1               ;;
00048Fr 1               ;;      IOPORTS - re-initialize after MEM check.
00048Fr 1               ;;
00048Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00048Fr 1               
00048Fr 1  20 rr rr       jsr via_1_init
000492r 1  20 rr rr       jsr via_2_init ; set-up VIA_2 for general I/O
000495r 1  20 rr rr       jsr via_3_init ; set-up VIA_3 for general I/O
000498r 1               
000498r 1                 ;; now make a beep-boop
000498r 1  20 rr rr       jsr beep2
00049Br 1               
00049Br 1  D7 rr          smb5 FLAGS ; show Mission Time Clock on LCD2
00049Dr 1  A7 rr          smb2 FLAGS ; start SPI TX/RX from VIA_2 port A
00049Fr 1               
00049Fr 1  20 rr rr       jsr lcd_2_clear
0004A2r 1  A9 rr          lda #<emt
0004A4r 1  85 rr          sta MESSAGE_POINTER
0004A6r 1  A9 rr          lda #>emt
0004A8r 1  85 rr          sta MESSAGE_POINTER + 1
0004AAr 1  20 rr rr       jsr print2_2
0004ADr 1               
0004ADr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004ADr 1               ;;
0004ADr 1               ;;  Put a sample program into "User Ram" at $3F00
0004ADr 1               ;;
0004ADr 1               ;;  Load the User RAM area at $3F00-> with the bytes
0004ADr 1               ;;  set in "userProg" - currently a small routine that
0004ADr 1               ;;  changes the contents of MESSAGE_POINTER (+1) to point
0004ADr 1               ;;  to $2000 instead. Then a string from "userPrompt" is stored
0004ADr 1               ;;  at $2000. Running the user sub-routine (<shift>5) will now show
0004ADr 1               ;;  the "userPrompt" string on line4 of the main LCD
0004ADr 1               ;;  The user prog at $3F00 can be edited at will
0004ADr 1               ;;
0004ADr 1               ;;
0004ADr 1               ;;
0004ADr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004ADr 1               
0004ADr 1               user_ram:
0004ADr 1               
0004ADr 1  A0 00          ldy #$00
0004AFr 1               @loop:
0004AFr 1  B9 rr rr       lda userProg,y
0004B2r 1  F0 07          beq @exit
0004B4r 1  99 00 3F       sta $3F00,y
0004B7r 1  C8             iny
0004B8r 1  4C rr rr       jmp @loop
0004BBr 1               @exit:
0004BBr 1               
0004BBr 1               ;; Put a sample text string @ $2000->
0004BBr 1               
0004BBr 1               user_prompt:
0004BBr 1               
0004BBr 1  A0 00          ldy #$00
0004BDr 1               @loop:
0004BDr 1  B9 rr rr       lda userPrompt,y
0004C0r 1  F0 07          beq @exit
0004C2r 1  99 00 20       sta $2000,y
0004C5r 1  C8             iny
0004C6r 1  4C rr rr       jmp @loop
0004C9r 1               @exit:
0004C9r 1  A9 00          lda #$00      ; plus a trailing NULL just in case....
0004CBr 1  99 00 20       sta $2000,y
0004CEr 1               
0004CEr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004CEr 1               ;;
0004CEr 1               ;;                 Main Loop
0004CEr 1               ;;
0004CEr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004CEr 1               
0004CEr 1               loop:
0004CEr 1               
0004CEr 1  CB             wai
0004CFr 1  20 rr rr       jsr check_flags
0004D2r 1  4C rr rr       jmp loop
0004D5r 1               
0004D5r 1               
0004D5r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004D5r 1               ;;
0004D5r 1               ;;                  FUNCTIONS
0004D5r 1               ;;
0004D5r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004D5r 1               
0004D5r 1               
0004D5r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004D5r 1               ;;
0004D5r 1               ;;     FLAGS - for control of background tasks
0004D5r 1               ;;
0004D5r 1               ;;   bit7    | bit6   | bit5    |  bit4 | bit3 | bit2   | bit1 | bit0
0004D5r 1               ;; ==========|========|=========|=======|======|========|======|===========
0004D5r 1               ;;   beep    |        | spi(0)  |       |      | spi    |      | mem block
0004D5r 1               ;;   sound   |        | or      |       |      | tx/rx  |      | view
0004D5r 1               ;;   started |        | clock(1)|       |      | active |      | update
0004D5r 1               ;;
0004D5r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004D5r 1               
0004D5r 1               check_flags:
0004D5r 1               
0004D5r 1                 ;; show FLAGS on LEDs, just for fun
0004D5r 1  A5 rr          lda FLAGS
0004D7r 1  8D 00 48       sta PORTB_3
0004DAr 1               
0004DAr 1               flag_zero:
0004DAr 1               
0004DAr 1  0F rr 03       bbr0 FLAGS, flag_one
0004DDr 1  20 rr rr       jsr update_block_address
0004E0r 1               
0004E0r 1               flag_one:
0004E0r 1               
0004E0r 1               flag_two:
0004E0r 1               
0004E0r 1  2F rr 03       bbr2 FLAGS, flag_three
0004E3r 1  20 rr rr       jsr spi_portb_2
0004E6r 1               
0004E6r 1               flag_three:
0004E6r 1               
0004E6r 1               flag_four:
0004E6r 1               
0004E6r 1               flag_six:
0004E6r 1               
0004E6r 1               flag_seven:
0004E6r 1               
0004E6r 1  7F rr 03       bbr7 FLAGS, flag_five
0004E9r 1  20 rr rr       jsr check_beep
0004ECr 1               
0004ECr 1               flag_five:
0004ECr 1               
0004ECr 1  5F rr 03       bbr5 FLAGS, no_flag_five
0004EFr 1  4C rr rr       jmp clock_time            ; (jsr/rts)
0004F2r 1                 ;rts
0004F2r 1               
0004F2r 1               no_flag_five:
0004F2r 1               
0004F2r 1  4C rr rr       jmp update_spi_monitor    ; (jsr/rts)
0004F5r 1                 ;rts
0004F5r 1               
0004F5r 1               ;;;;;;;;;;
0004F5r 1               ;;;;;;;;;;
0004F5r 1               ;;;
0004F5r 1               check_beep:
0004F5r 1               
0004F5r 1  38             sec
0004F6r 1  A5 rr          lda TICKS
0004F8r 1  E5 rr          sbc BEEP_ON_TIME
0004FAr 1  C5 rr          cmp BEEP_DELAY_TIME
0004FCr 1  90 03          bcc @exit
0004FEr 1  20 rr rr       jsr beep_off
000501r 1               @exit:
000501r 1  60             rts
000502r 1               
000502r 1               spi_portb_2:
000502r 1               
000502r 1  38             sec
000503r 1  A5 rr          lda TICKS
000505r 1  E5 rr          sbc SPI_LAST
000507r 1  C9 32          cmp #50
000509r 1  B0 01          bcs @spi_tx_rx
00050Br 1  60             rts
00050Cr 1               
00050Cr 1               @spi_tx_rx:
00050Cr 1               
00050Cr 1                 ;; CLOCK HIGH IDLE CPOL = 1
00050Cr 1                 ;; MODE 2 and MODE 3
00050Cr 1                 ;; PUT A BRANCH HERE TO MAKE SWAPPING MODES EASIER?
00050Cr 1                 ;;
00050Cr 1               
00050Cr 1  A9 01          lda #SCK
00050Er 1  0C 00 50       tsb SPI_PORT
000511r 1               
000511r 1               ;;;;;;;;;; CS Signal -> ACTIVE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000511r 1               
000511r 1                 ;; for ds1306 rtc - CS is HIGH for active - unusual - is this correct?
000511r 1                 ;;
000511r 1               
000511r 1  A9 04          lda #CS
000513r 1  0C 00 50       tsb SPI_PORT
000516r 1               
000516r 1               ;;;;;;;;; First Byte ;;;;;;;;;;;;;;;;;
000516r 1               
000516r 1  A5 rr          lda SPI_BYTE
000518r 1  8D rr rr       sta SPI_TX_BYTE
00051Br 1  20 rr rr       jsr spi_transceive
00051Er 1  8D rr rr       sta SPI_RX_BYTE
000521r 1               
000521r 1               ;;;;;;;;;; Second Byte  ;;;;;;;;;;;;;;;
000521r 1               
000521r 1  A5 rr          lda SPI_BYTE + 1
000523r 1  8D rr rr       sta SPI_TX_BYTE + 1
000526r 1  20 rr rr       jsr spi_transceive
000529r 1  8D rr rr       sta SPI_RX_BYTE + 1
00052Cr 1               
00052Cr 1               ;;;;; CS signal -> IDLE ;;;;;;;;;;;;;;;;;
00052Cr 1               
00052Cr 1                 ;;; for ds1306 CS is low for idle
00052Cr 1               
00052Cr 1  A9 04          lda #CS
00052Er 1  1C 00 50       trb SPI_PORT
000531r 1               
000531r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000531r 1               
000531r 1  A5 rr          lda TICKS
000533r 1  85 rr          sta SPI_LAST
000535r 1               
000535r 1  60             rts
000536r 1               
000536r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000536r 1               ;;
000536r 1               ;;
000536r 1               
000536r 1               update_spi_monitor:
000536r 1  38             sec
000537r 1  A5 rr          lda TICKS
000539r 1  E5 rr          sbc CLOCK_LAST
00053Br 1  C9 64          cmp #100
00053Dr 1  B0 01          bcs @do_update
00053Fr 1  60             rts
000540r 1               @do_update:
000540r 1  20 rr rr       jsr lcd_2_cursor_off
000543r 1  20 rr rr       jsr lcd_2_clear
000546r 1               
000546r 1  20 rr rr       jsr lcd_2_line_1
000549r 1               
000549r 1  A9 54          lda #'T'
00054Br 1  20 rr rr       jsr print_2_char
00054Er 1  A9 58          lda #'X'
000550r 1  20 rr rr       jsr print_2_char
000553r 1               
000553r 1  A9 20          lda #' '
000555r 1  20 rr rr       jsr print_2_char
000558r 1               
000558r 1  A9 24          lda #'$'
00055Ar 1  20 rr rr       jsr print_2_char
00055Dr 1               
00055Dr 1  AD rr rr       lda SPI_TX_BYTE
000560r 1  20 rr rr       jsr bintohex_2
000563r 1               
000563r 1  A9 20          lda #' '
000565r 1  20 rr rr       jsr print_2_char
000568r 1               
000568r 1  A9 24          lda #'$'
00056Ar 1  20 rr rr       jsr print_2_char
00056Dr 1               
00056Dr 1  AD rr rr       lda SPI_TX_BYTE + 1
000570r 1  20 rr rr       jsr bintohex_2
000573r 1               
000573r 1  A9 20          lda #' '
000575r 1  20 rr rr       jsr print_2_char
000578r 1  A9 7F          lda #$7F
00057Ar 1  20 rr rr       jsr print_2_char
00057Dr 1  A9 53          lda #'S'
00057Fr 1  20 rr rr       jsr print_2_char
000582r 1  A9 50          lda #'P'
000584r 1  20 rr rr       jsr print_2_char
000587r 1  A9 49          lda #'I'
000589r 1  20 rr rr       jsr print_2_char
00058Cr 1               
00058Cr 1  A9 7E          lda #$7E
00058Er 1  20 rr rr       jsr print_2_char
000591r 1               
000591r 1  20 rr rr       jsr lcd_2_line_2
000594r 1               
000594r 1  A9 52          lda #'R'
000596r 1  20 rr rr       jsr print_2_char
000599r 1  A9 58          lda #'X'
00059Br 1  20 rr rr       jsr print_2_char
00059Er 1               
00059Er 1  A9 20          lda #' '
0005A0r 1  20 rr rr       jsr print_2_char
0005A3r 1               
0005A3r 1  A9 24          lda #'$'
0005A5r 1  20 rr rr       jsr print_2_char
0005A8r 1               
0005A8r 1  AD rr rr       lda SPI_RX_BYTE
0005ABr 1  20 rr rr       jsr bintohex_2
0005AEr 1               
0005AEr 1  A9 20          lda #' '
0005B0r 1  20 rr rr       jsr print_2_char
0005B3r 1               
0005B3r 1  A9 24          lda #'$'
0005B5r 1  20 rr rr       jsr print_2_char
0005B8r 1               
0005B8r 1  AD rr rr       lda SPI_RX_BYTE + 1
0005BBr 1  20 rr rr       jsr bintohex_2
0005BEr 1               
0005BEr 1  A9 20          lda #' '
0005C0r 1  20 rr rr       jsr print_2_char
0005C3r 1               
0005C3r 1  AD rr rr       lda SPI_RX_BYTE + 1
0005C6r 1  8D rr rr       sta VALUE
0005C9r 1  AD rr rr       lda SPI_RX_BYTE
0005CCr 1  8D rr rr       sta VALUE + 1
0005CFr 1  20 rr rr       jsr print_value
0005D2r 1               
0005D2r 1               
0005D2r 1  A9 rr          lda #<num_message
0005D4r 1  85 rr          sta MESSAGE_POINTER
0005D6r 1  A9 rr          lda #>num_message
0005D8r 1  85 rr          sta MESSAGE_POINTER + 1
0005DAr 1  A0 00          ldy #0
0005DCr 1  20 rr rr       jsr line2
0005DFr 1               
0005DFr 1  A5 rr          lda TICKS
0005E1r 1  85 rr          sta CLOCK_LAST
0005E3r 1  60             rts
0005E4r 1               
0005E4r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005E4r 1               ;;
0005E4r 1               ;;
0005E4r 1               ;;
0005E4r 1               
0005E4r 1               update_block_address:
0005E4r 1               
0005E4r 1  20 rr rr       jsr lcd_line_2
0005E7r 1  38             sec
0005E8r 1  A5 rr          lda TICKS
0005EAr 1  E5 rr          sbc TOGGLE_TIME
0005ECr 1  C9 64          cmp #100
0005EEr 1  90 07          bcc @exit
0005F0r 1  20 rr rr       jsr block_address
0005F3r 1  A5 rr          lda TICKS
0005F5r 1  85 rr          sta TOGGLE_TIME
0005F7r 1               @exit:
0005F7r 1  60             rts
0005F8r 1               
0005F8r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005F8r 1               ;;
0005F8r 1               ;;
0005F8r 1               ;;
0005F8r 1               
0005F8r 1               clock_time:
0005F8r 1               
0005F8r 1  38             sec
0005F9r 1  A5 rr          lda TICKS
0005FBr 1  E5 rr          sbc CLOCK_LAST
0005FDr 1  C9 32          cmp #50
0005FFr 1  90 5A          bcc @exit
000601r 1               
000601r 1  20 rr rr       jsr lcd_2_cursor_off
000604r 1  20 rr rr       jsr lcd_2_line_1
000607r 1  A5 rr          lda HUNDRED_HRS
000609r 1  20 rr rr       jsr bintoascii_2
00060Cr 1  A5 rr          lda TEN_HRS
00060Er 1  20 rr rr       jsr bintoascii_2
000611r 1  A5 rr          lda HRS
000613r 1  20 rr rr       jsr bintoascii_2
000616r 1  A9 3A          lda #':'
000618r 1  20 rr rr       jsr print_2_char
00061Br 1  A5 rr          lda TEN_MINUTES
00061Dr 1  20 rr rr       jsr bintoascii_2
000620r 1  A5 rr          lda MINUTES
000622r 1  20 rr rr       jsr bintoascii_2
000625r 1  A9 3A          lda #':'
000627r 1  20 rr rr       jsr print_2_char
00062Ar 1  A5 rr          lda TEN_SECONDS
00062Cr 1  20 rr rr       jsr bintoascii_2
00062Fr 1  A5 rr          lda SECONDS
000631r 1  20 rr rr       jsr bintoascii_2
000634r 1  A9 20          lda #' '
000636r 1  20 rr rr       jsr print_2_char
000639r 1  A9 20          lda #' '
00063Br 1  20 rr rr       jsr print_2_char
00063Er 1  A9 20          lda #' '
000640r 1  20 rr rr       jsr print_2_char
000643r 1  A9 20          lda #' '
000645r 1  20 rr rr       jsr print_2_char
000648r 1  A9 20          lda #' '
00064Ar 1  20 rr rr       jsr print_2_char
00064Dr 1  A9 20          lda #' '
00064Fr 1  20 rr rr       jsr print_2_char
000652r 1  A9 20          lda #' '
000654r 1  20 rr rr       jsr print_2_char
000657r 1  A5 rr          lda TICKS
000659r 1  85 rr          sta CLOCK_LAST
00065Br 1               @exit:
00065Br 1  60             rts
00065Cr 1               
00065Cr 1               
00065Cr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00065Cr 1               ;;
00065Cr 1               ;;      update screen when new memory location is selected
00065Cr 1               ;;
00065Cr 1               ;;
00065Cr 1               
00065Cr 1               new_address:
00065Cr 1               
00065Cr 1  20 rr rr       jsr lcd_clear
00065Fr 1  20 rr rr       jsr lcd_cursor_on
000662r 1  A9 rr          lda #<new_address_msg
000664r 1  85 rr          sta MESSAGE_POINTER
000666r 1  A9 rr          lda #>new_address_msg
000668r 1  85 rr          sta MESSAGE_POINTER + 1
00066Ar 1  20 rr rr       jsr print1
00066Dr 1  20 rr rr       jsr lcd_line_2
000670r 1               
000670r 1               print_address:
000670r 1               
000670r 1  A9 24          lda #'$'
000672r 1  20 rr rr       jsr print_char
000675r 1  A5 rr          lda DUMP_POINTER + 1
000677r 1  20 rr rr       jsr bintohex
00067Ar 1  AD rr rr       lda HI_DIGIT
00067Dr 1  20 rr rr       jsr print_char
000680r 1  AD rr rr       lda LO_DIGIT
000683r 1  20 rr rr       jsr print_char
000686r 1  A5 rr          lda DUMP_POINTER
000688r 1  20 rr rr       jsr bintohex
00068Br 1  AD rr rr       lda HI_DIGIT
00068Er 1  20 rr rr       jsr print_char
000691r 1  AD rr rr       lda LO_DIGIT
000694r 1  20 rr rr       jsr print_char
000697r 1  A9 20          lda #' '
000699r 1  20 rr rr       jsr print_char
00069Cr 1  A9 24          lda #'$'
00069Er 1  20 rr rr       jsr print_char
0006A1r 1  A0 00          ldy #$00
0006A3r 1  B1 rr          lda (DUMP_POINTER),y
0006A5r 1  20 rr rr       jsr bintohex
0006A8r 1  AD rr rr       lda HI_DIGIT
0006ABr 1  20 rr rr       jsr print_char
0006AEr 1  AD rr rr       lda LO_DIGIT
0006B1r 1  20 rr rr       jsr print_char
0006B4r 1  A9 20          lda #' '
0006B6r 1  20 rr rr       jsr print_char
0006B9r 1  B1 rr          lda (DUMP_POINTER),y
0006BBr 1  20 rr rr       jsr print_char
0006BEr 1               
0006BEr 1  A9 20          lda #' '
0006C0r 1  20 rr rr       jsr print_char
0006C3r 1               
0006C3r 1                 ;;;;;;;;;;;;;;
0006C3r 1                 ;;
0006C3r 1               
0006C3r 1  B1 rr          lda (DUMP_POINTER),y
0006C5r 1  8D rr rr       sta VALUE
0006C8r 1  9C rr rr       stz VALUE + 1
0006CBr 1  20 rr rr       jsr print_value
0006CEr 1  A9 rr          lda #<num_message
0006D0r 1  85 rr          sta MESSAGE_POINTER
0006D2r 1  A9 rr          lda #>num_message
0006D4r 1  85 rr          sta MESSAGE_POINTER + 1
0006D6r 1  A0 00          ldy #0
0006D8r 1  20 rr rr       jsr line
0006DBr 1               
0006DBr 1                 ;;;;;;;;;;;;;;;;;;;;;
0006DBr 1               
0006DBr 1               new_cursor:
0006DBr 1               
0006DBr 1  A9 rr          lda #<splash
0006DDr 1  85 rr          sta MESSAGE_POINTER
0006DFr 1  A9 rr          lda #>splash
0006E1r 1  85 rr          sta MESSAGE_POINTER + 1
0006E3r 1  4C rr rr       jmp print4   ; (jsr / rts)
0006E6r 1               
0006E6r 1               
0006E6r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006E6r 1               ;;
0006E6r 1               ;;      display 8 bytes of data for a "block" of memory
0006E6r 1               ;;
0006E6r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006E6r 1               
0006E6r 1               block_address:
0006E6r 1               
0006E6r 1  20 rr rr       jsr lcd_clear
0006E9r 1  20 rr rr       jsr lcd_cursor_off
0006ECr 1  A9 rr          lda #<block_address_msg
0006EEr 1  85 rr          sta MESSAGE_POINTER
0006F0r 1  A9 rr          lda #>block_address_msg
0006F2r 1  85 rr          sta MESSAGE_POINTER + 1
0006F4r 1  20 rr rr       jsr print1
0006F7r 1  20 rr rr       jsr lcd_line_2
0006FAr 1  A0 00          ldy #$00
0006FCr 1  A9 24          lda #'$'
0006FEr 1  20 rr rr       jsr print_char
000701r 1  A5 rr          lda DUMP_POINTER + 1
000703r 1  20 rr rr       jsr bintohex
000706r 1  AD rr rr       lda HI_DIGIT
000709r 1  20 rr rr       jsr print_char
00070Cr 1  AD rr rr       lda LO_DIGIT
00070Fr 1  20 rr rr       jsr print_char
000712r 1  A5 rr          lda DUMP_POINTER
000714r 1  20 rr rr       jsr bintohex
000717r 1  AD rr rr       lda HI_DIGIT
00071Ar 1  20 rr rr       jsr print_char
00071Dr 1  AD rr rr       lda LO_DIGIT
000720r 1  20 rr rr       jsr print_char
000723r 1  20 rr rr       jsr lcd_line_3
000726r 1               loop1:
000726r 1  B1 rr          lda (DUMP_POINTER),y
000728r 1  20 rr rr       jsr bintohex
00072Br 1  AD rr rr       lda HI_DIGIT
00072Er 1  20 rr rr       jsr print_char
000731r 1  AD rr rr       lda LO_DIGIT
000734r 1  20 rr rr       jsr print_char
000737r 1  B1 rr          lda (DUMP_POINTER),y
000739r 1  C8             iny
00073Ar 1  C0 08          cpy #$08
00073Cr 1  D0 E8          bne loop1
00073Er 1  A9 20          lda #' '
000740r 1  20 rr rr       jsr print_char
000743r 1  A9 48          lda #'H'
000745r 1  20 rr rr       jsr print_char
000748r 1  A9 65          lda #'e'
00074Ar 1  20 rr rr       jsr print_char
00074Dr 1  A9 78          lda #'x'
00074Fr 1  20 rr rr       jsr print_char
000752r 1  20 rr rr       jsr lcd_line_4
000755r 1  A0 00          ldy #$00
000757r 1               loop2:
000757r 1  A9 20          lda #$20
000759r 1  20 rr rr       jsr print_char
00075Cr 1  B1 rr          lda (DUMP_POINTER),y
00075Er 1  20 rr rr       jsr print_char
000761r 1  C8             iny
000762r 1  C0 08          cpy #$08
000764r 1  D0 F1          bne loop2
000766r 1  A9 20          lda #' '
000768r 1  20 rr rr       jsr print_char
00076Br 1  A9 43          lda #'C'
00076Dr 1  20 rr rr       jsr print_char
000770r 1  A9 68          lda #'h'
000772r 1  20 rr rr       jsr print_char
000775r 1  A9 72          lda #'r'
000777r 1               
000777r 1  4C rr rr       jmp print_char  ; (jsr / rts)
00077Ar 1               
00077Ar 1                 ;jsr print_char
00077Ar 1                 ;rts
00077Ar 1               
00077Ar 1               
00077Ar 1               
00077Ar 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00077Ar 1               ;;
00077Ar 1               ;;      Monitor function - decrement the selected address
00077Ar 1               ;;
00077Ar 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00077Ar 1               
00077Ar 1               decrement_address:
00077Ar 1               
00077Ar 1  38             sec
00077Br 1  A5 rr          lda DUMP_POINTER
00077Dr 1  E9 01          sbc #$01
00077Fr 1  85 rr          sta DUMP_POINTER
000781r 1  8D rr rr       sta BYTE
000784r 1  A5 rr          lda DUMP_POINTER + 1
000786r 1  E9 00          sbc #$00
000788r 1  85 rr          sta DUMP_POINTER + 1
00078Ar 1  8D rr rr       sta BYTE + 1
00078Dr 1  60             rts
00078Er 1               
00078Er 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00078Er 1               ;;
00078Er 1               ;;      Monitor function - increment the selected address
00078Er 1               ;;
00078Er 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00078Er 1               
00078Er 1               increment_address:
00078Er 1               
00078Er 1  18             clc
00078Fr 1  A5 rr          lda DUMP_POINTER
000791r 1  69 01          adc #$01
000793r 1  85 rr          sta DUMP_POINTER
000795r 1  8D rr rr       sta BYTE
000798r 1  A5 rr          lda DUMP_POINTER + 1
00079Ar 1  69 00          adc #$00
00079Cr 1  85 rr          sta DUMP_POINTER + 1
00079Er 1  8D rr rr       sta BYTE + 1
0007A1r 1  60             rts
0007A2r 1               
0007A2r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007A2r 1               ;;
0007A2r 1               ;;      Monitor function - increment the selected block of  addresses by 8
0007A2r 1               ;;
0007A2r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007A2r 1               
0007A2r 1               increment_block:
0007A2r 1               
0007A2r 1  18             clc
0007A3r 1  A5 rr          lda DUMP_POINTER
0007A5r 1  69 08          adc #$08
0007A7r 1  85 rr          sta DUMP_POINTER
0007A9r 1  8D rr rr       sta BYTE
0007ACr 1  A5 rr          lda DUMP_POINTER + 1
0007AEr 1  69 00          adc #$00
0007B0r 1  85 rr          sta DUMP_POINTER + 1
0007B2r 1  8D rr rr       sta BYTE + 1
0007B5r 1  60             rts
0007B6r 1               
0007B6r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007B6r 1               ;;
0007B6r 1               ;;      Monitor function - decrement the selected block of  addresses by 8
0007B6r 1               ;;
0007B6r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007B6r 1               
0007B6r 1               decrement_block:
0007B6r 1               
0007B6r 1  38             sec
0007B7r 1  A5 rr          lda DUMP_POINTER
0007B9r 1  E9 08          sbc #$08
0007BBr 1  85 rr          sta DUMP_POINTER
0007BDr 1  8D rr rr       sta BYTE
0007C0r 1  A5 rr          lda DUMP_POINTER + 1
0007C2r 1  E9 00          sbc #$00
0007C4r 1  85 rr          sta DUMP_POINTER + 1
0007C6r 1  8D rr rr       sta BYTE + 1
0007C9r 1  60             rts
0007CAr 1               
0007CAr 1               
0007CAr 1               
0007CAr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007CAr 1               ;;
0007CAr 1               ;; use last 4 key presses (as hex bytes) to fill two BYTES
0007CAr 1               ;;
0007CAr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007CAr 1               
0007CAr 1               keys_byte:
0007CAr 1               
0007CAr 1  AD rr rr       lda KEY_PRESS + 1
0007CDr 1  0A             asl
0007CEr 1  0A             asl
0007CFr 1  0A             asl
0007D0r 1  0A             asl
0007D1r 1  8D rr rr       sta BYTE
0007D4r 1  AD rr rr       lda KEY_PRESS
0007D7r 1  0D rr rr       ora BYTE
0007DAr 1  8D rr rr       sta BYTE
0007DDr 1  AD rr rr       lda KEY_PRESS + 3
0007E0r 1  0A             asl
0007E1r 1  0A             asl
0007E2r 1  0A             asl
0007E3r 1  0A             asl
0007E4r 1  8D rr rr       sta BYTE + 1
0007E7r 1  AD rr rr       lda KEY_PRESS + 2
0007EAr 1  0D rr rr       ora BYTE + 1
0007EDr 1  8D rr rr       sta BYTE + 1
0007F0r 1  60             rts
0007F1r 1               
0007F1r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007F1r 1               ;;
0007F1r 1               ;;    toggle the display/update of SPI Monitor on LCD2
0007F1r 1               ;;
0007F1r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007F1r 1               
0007F1r 1               clock_or_spi:
0007F1r 1               
0007F1r 1  DF rr 10       bbs5 FLAGS, reset_bit5
0007F4r 1  D7 rr          smb5 FLAGS
0007F6r 1  A9 rr          lda #<emt
0007F8r 1  85 rr          sta MESSAGE_POINTER
0007FAr 1  A9 rr          lda #>emt
0007FCr 1  85 rr          sta MESSAGE_POINTER + 1
0007FEr 1  20 rr rr       jsr print2_2
000801r 1  4C rr rr       jmp exit_clock_or_spi
000804r 1               
000804r 1               reset_bit5:
000804r 1               
000804r 1  57 rr          rmb5 FLAGS
000806r 1               
000806r 1               exit_clock_or_spi:
000806r 1               
000806r 1  60             rts
000807r 1               
000807r 1               
000807r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000807r 1               ;;
000807r 1               ;;    toggle the automatic update view of the "8-byte memory block"
000807r 1               ;;
000807r 1               
000807r 1               show_block:
000807r 1               
000807r 1  8F rr 05       bbs0 FLAGS, reset_bit0
00080Ar 1  87 rr          smb0 FLAGS
00080Cr 1  4C rr rr       jmp exit_show_block
00080Fr 1               
00080Fr 1               reset_bit0:
00080Fr 1               
00080Fr 1  07 rr          rmb0 FLAGS
000811r 1               
000811r 1               exit_show_block:
000811r 1               
000811r 1  60             rts
000812r 1               
000812r 1               
000812r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000812r 1               ;;
000812r 1               ;;     toggle the TX/RX of SPI on PORTB_2
000812r 1               ;;
000812r 1               
000812r 1               update_spi:
000812r 1               
000812r 1  AF rr 05       bbs2 FLAGS, reset_bit2
000815r 1  A7 rr          smb2 FLAGS
000817r 1  4C rr rr       jmp exit_update_spi
00081Ar 1               
00081Ar 1               reset_bit2:
00081Ar 1               
00081Ar 1  27 rr          rmb2 FLAGS
00081Cr 1  9C 01 50       stz PORTA_2
00081Fr 1               
00081Fr 1               exit_update_spi:
00081Fr 1               
00081Fr 1  60             rts
000820r 1               
000820r 1               
000820r 1               
000820r 1               
000820r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000820r 1               ;;
000820r 1               ;;                     INTERRUPT HANDLERS
000820r 1               ;;
000820r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000820r 1               
000820r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000820r 1               ;;
000820r 1               ;;         reset & restart timer
000820r 1               ;;
000820r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000820r 1               
000820r 1               
000820r 1               reset_met:
000820r 1               
000820r 1  64 rr          stz HUNDRED_HRS
000822r 1  64 rr          stz TEN_HRS
000824r 1  64 rr          stz TEN_MINUTES
000826r 1  64 rr          stz TEN_SECONDS
000828r 1  64 rr          stz HRS
00082Ar 1  64 rr          stz MINUTES
00082Cr 1  64 rr          stz SECONDS
00082Er 1  60             rts
00082Fr 1               
00082Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00082Fr 1               ;;
00082Fr 1               ;;                CB : TEST FUNCTIONS
00082Fr 1               ;;
00082Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00082Fr 1               cb1_handler:
00082Fr 1               
00082Fr 1  A9 05          lda #$05
000831r 1  85 rr          sta BEEP_DELAY_TIME
000833r 1               
000833r 1  4C rr rr       jmp beep_from_pointer  ; (jsr/rts)
000836r 1               
000836r 1               
000836r 1               cb2_handler:
000836r 1               
000836r 1  A9 40          lda #$40
000838r 1  85 rr          sta BEEP_DELAY_TIME
00083Ar 1  A9 02          lda #$02 ; tone # = 100Hz
00083Cr 1               
00083Cr 1  4C rr rr       jmp beep_from_list    ; (jsr/rts)
00083Fr 1               
00083Fr 1               
00083Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00083Fr 1               ;;
00083Fr 1               ;;                    MONITOR / KEYPAD
00083Fr 1               ;;
00083Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00083Fr 1               
00083Fr 1               keypad_handler:
00083Fr 1               
00083Fr 1  20 rr rr       jsr get_key     ; READs from PORTA which also re-sets VIA's Interrupt flag
000842r 1  8D rr rr       sta INKEY       ; put the byte value of input into RAM ( $00 )
000845r 1  AD 00 60       lda PORTB_1       ; check for SHIFT/INSTRUCTION button, 0=pressed, 1=not pressed
000848r 1  29 80          and #%10000000    ; zero (eq) when button pressed -> check_keypress, otherwise it's not zero, jmp to handle_new_char
00084Ar 1  F0 06          beq check_keypress; done this way to get around the limit in size of branch jumps....
00084Cr 1  20 rr rr       jsr beep_from_pointer
00084Fr 1  4C rr rr       jmp handle_new_char
000852r 1               
000852r 1               check_keypress:
000852r 1               
000852r 1  AD rr rr       lda INKEY
000855r 1               
000855r 1               ; choose action of "SHIFTed" key-press
000855r 1               
000855r 1               check_a:
000855r 1               
000855r 1  C9 0A          cmp #$0A
000857r 1                 ; move up one memory address and display contents
000857r 1  D0 0C          bne check_b
000859r 1  20 rr rr       jsr increment_address
00085Cr 1  20 rr rr       jsr beep
00085Fr 1  20 rr rr       jsr new_address
000862r 1  4C rr rr       jmp exit_key_irq
000865r 1               
000865r 1               check_b:
000865r 1               
000865r 1  C9 0B          cmp #$0B
000867r 1                 ; move down one memory address and display contents
000867r 1  D0 0C          bne check_c
000869r 1  20 rr rr       jsr decrement_address
00086Cr 1  20 rr rr       jsr beep
00086Fr 1  20 rr rr       jsr new_address
000872r 1  4C rr rr       jmp exit_key_irq
000875r 1               
000875r 1               check_c:
000875r 1               
000875r 1  C9 0C          cmp #$0C
000877r 1                 ; return to MONITOR
000877r 1  D0 0E          bne check_d
000879r 1  07 rr          rmb0 FLAGS
00087Br 1  20 rr rr       jsr lcd_clear
00087Er 1  20 rr rr       jsr beep
000881r 1  20 rr rr       jsr new_address
000884r 1  4C rr rr       jmp exit_key_irq
000887r 1               
000887r 1               check_d:
000887r 1               
000887r 1  C9 0D          cmp #$0D
000889r 1                 ; move monitor to entered 4-digit memory address
000889r 1  D0 13          bne check_e
00088Br 1  AD rr rr       lda BYTE
00088Er 1  85 rr          sta DUMP_POINTER
000890r 1  AD rr rr       lda BYTE + 1
000893r 1  85 rr          sta DUMP_POINTER + 1
000895r 1  20 rr rr       jsr beep
000898r 1  20 rr rr       jsr new_address
00089Br 1  4C rr rr       jmp exit_key_irq
00089Er 1               
00089Er 1               check_e:
00089Er 1               
00089Er 1  C9 0E          cmp #$0E
0008A0r 1                 ; insert (POKE) byte of data in to current memory address, then increment to next address
0008A0r 1  D0 10          bne check_f
0008A2r 1  AD rr rr       lda BYTE
0008A5r 1  A0 00          ldy #$00
0008A7r 1  91 rr          sta (DUMP_POINTER),y
0008A9r 1  20 rr rr       jsr beep
0008ACr 1  20 rr rr       jsr new_address
0008AFr 1  4C rr rr       jmp exit_key_irq
0008B2r 1               
0008B2r 1               check_f:
0008B2r 1               
0008B2r 1  C9 0F          cmp #$0F
0008B4r 1                 ; show 8-byte wide block of memory
0008B4r 1  D0 15          bne check_1
0008B6r 1  A0 00          ldy #$00
0008B8r 1  AD rr rr       lda BYTE
0008BBr 1  85 rr          sta DUMP_POINTER
0008BDr 1  AD rr rr       lda BYTE + 1
0008C0r 1  85 rr          sta DUMP_POINTER + 1
0008C2r 1  20 rr rr       jsr beep
0008C5r 1  20 rr rr       jsr block_address
0008C8r 1  4C rr rr       jmp exit_key_irq
0008CBr 1               
0008CBr 1               check_1:
0008CBr 1               
0008CBr 1  C9 01          cmp #$01
0008CDr 1                 ; pause SPI Monitor on LCD2
0008CDr 1  D0 09          bne check_2
0008CFr 1  20 rr rr       jsr beep
0008D2r 1  20 rr rr       jsr clock_or_spi
0008D5r 1  4C rr rr       jmp exit_key_irq
0008D8r 1               
0008D8r 1               check_2:
0008D8r 1               
0008D8r 1  C9 02          cmp #$02
0008DAr 1                 ; reset_clock
0008DAr 1  D0 09          bne check_3
0008DCr 1  20 rr rr       jsr beep
0008DFr 1  20 rr rr       jsr reset_met
0008E2r 1  4C rr rr       jmp exit_key_irq
0008E5r 1               
0008E5r 1               check_3:
0008E5r 1               
0008E5r 1  C9 03          cmp #$03
0008E7r 1                 ; move up a block of 8
0008E7r 1  D0 0E          bne check_6
0008E9r 1  A0 00          ldy #$00
0008EBr 1  20 rr rr       jsr increment_block
0008EEr 1  20 rr rr       jsr beep
0008F1r 1  20 rr rr       jsr block_address
0008F4r 1  4C rr rr       jmp exit_key_irq
0008F7r 1               
0008F7r 1               check_6:
0008F7r 1               
0008F7r 1  C9 06          cmp #$06
0008F9r 1                 ; move down a block of 8
0008F9r 1  D0 0E          bne check_9
0008FBr 1  A0 00          ldy #$00
0008FDr 1  20 rr rr       jsr decrement_block
000900r 1  20 rr rr       jsr beep
000903r 1  20 rr rr       jsr block_address
000906r 1  4C rr rr       jmp exit_key_irq
000909r 1               
000909r 1               check_9:
000909r 1               
000909r 1  C9 09          cmp #$09
00090Br 1                 ; show updating block of memory
00090Br 1  D0 09          bne check_4
00090Dr 1  20 rr rr       jsr beep
000910r 1  20 rr rr       jsr show_block
000913r 1  4C rr rr       jmp exit_key_irq
000916r 1               
000916r 1               check_4:
000916r 1               
000916r 1  C9 04          cmp #$04
000918r 1                 ; Input 2 new SPI TX Bytes
000918r 1  D0 13          bne check_5
00091Ar 1  AD rr rr       lda BYTE + 1  ; change from little-endian for SPI TX
00091Dr 1  85 rr          sta SPI_BYTE
00091Fr 1  AD rr rr       lda BYTE
000922r 1  85 rr          sta SPI_BYTE + 1
000924r 1  20 rr rr       jsr beep
000927r 1  20 rr rr       jsr new_address
00092Ar 1  4C rr rr       jmp exit_key_irq
00092Dr 1               
00092Dr 1               check_5:
00092Dr 1               
00092Dr 1  C9 05          cmp #$05
00092Fr 1                 ; run user code at $3F00
00092Fr 1  D0 09          bne check_0
000931r 1  20 rr rr       jsr beep
000934r 1  20 00 3F       jsr $3F00
000937r 1  4C rr rr       jmp exit_key_irq
00093Ar 1               
00093Ar 1               check_0:
00093Ar 1               
00093Ar 1  C9 00          cmp #$00
00093Cr 1                 ; run/pause SPI TX & RX
00093Cr 1  D0 2A          bne exit_key_irq
00093Er 1  20 rr rr       jsr beep
000941r 1  20 rr rr       jsr update_spi
000944r 1  4C rr rr       jmp exit_key_irq
000947r 1               
000947r 1               
000947r 1               
000947r 1               handle_new_char:
000947r 1               
000947r 1  AD rr rr       lda KEY_PRESS + 2
00094Ar 1  8D rr rr       sta KEY_PRESS + 3
00094Dr 1  AD rr rr       lda KEY_PRESS + 1
000950r 1  8D rr rr       sta KEY_PRESS + 2
000953r 1  AD rr rr       lda KEY_PRESS
000956r 1  8D rr rr       sta KEY_PRESS + 1
000959r 1  AD rr rr       lda INKEY       ; get the new keypress value and...
00095Cr 1  8D rr rr       sta KEY_PRESS
00095Fr 1  20 rr rr       jsr bintohex
000962r 1  20 rr rr       jsr print_char  ; and print it on LCD
000965r 1  20 rr rr       jsr keys_byte
000968r 1               
000968r 1               exit_key_irq:
000968r 1               
000968r 1  4C rr rr       jmp scan    ; (jsr/rts)
00096Br 1               
00096Br 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00096Br 1               
00096Br 1               nmi:
00096Br 1               
00096Br 1  48             pha
00096Cr 1  DA             phx
00096Dr 1  5A             phy
00096Er 1               
00096Er 1  2C 04 48       bit T1CL_3      ; reset interrupt flag
000971r 1  20 rr rr       jsr rtc
000974r 1  4C rr rr       jmp exit_nmi
000977r 1               
000977r 1               exit_nmi:
000977r 1               
000977r 1  7A             ply
000978r 1  FA             plx
000979r 1  68             pla
00097Ar 1  40             rti
00097Br 1               
00097Br 1               
00097Br 1               
00097Br 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00097Br 1               ;;
00097Br 1               ;;    interrupt is triggered by HIGH edge on VIA CA1 pin
00097Br 1               ;;     PORTA low nibble (keypad columns) inputs are diode ORed to CA1
00097Br 1               ;;
00097Br 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00097Br 1               
00097Br 1               irq:
00097Br 1               
00097Br 1               ; put registers on the stack while handling the IRQ
00097Br 1               
00097Br 1  48             pha
00097Cr 1  DA             phx
00097Dr 1  5A             phy
00097Er 1               
00097Er 1               ;  find responsible hardware
00097Er 1               
00097Er 1               ;  Is it VIA_1?
00097Er 1               
00097Er 1  AD 0D 60       lda IFR_1       ; if IFR_1 has Bit7 set (ie sign=NEGATIVE) then it IS the source of the interrupt
000981r 1  10 25          bpl next_device ; if it's not set (ie sign=POSITIVE) then branch to test the next possible device
000983r 1               
000983r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000983r 1               ;;
000983r 1               ;; IFR Flags
000983r 1               ;; B7  B6  B5  B4  B3  B2  B1  B0
000983r 1               ;; IRQ TI1 TI2 CB1 CB2 SR CA1 CA2
000983r 1               ;;
000983r 1               ;; Interrupt source is found by sequentially shifting IFR bit left to put bit-of-interest into the CARRY place
000983r 1               ;; and then branching based on whether CARRY is SET or not
000983r 1               ;;
000983r 1               ;; Only add tests for IRQ sources in use, and adjust the ASLs in each test as necessary
000983r 1               ;;
000983r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000983r 1               
000983r 1               test_cb1:
000983r 1               
000983r 1  0A             asl
000984r 1  0A             asl
000985r 1  0A             asl
000986r 1  0A             asl
000987r 1  90 09          bcc test_cb2
000989r 1  2C 00 60       bit PORTB_1
00098Cr 1  20 rr rr       jsr cb1_handler
00098Fr 1  4C rr rr       jmp exit_irq
000992r 1               
000992r 1               test_cb2:
000992r 1  0A             asl
000993r 1  90 09          bcc test_ca1
000995r 1  2C 00 60       bit PORTB_1
000998r 1  20 rr rr       jsr cb2_handler
00099Br 1  4C rr rr       jmp exit_irq
00099Er 1               
00099Er 1               test_ca1:
00099Er 1               
00099Er 1  0A             asl           ; shift CA1 bit into the CARRY bit & test
00099Fr 1  0A             asl
0009A0r 1  90 06          bcc exit_irq        ; carry clear = leave
0009A2r 1  20 rr rr       jsr keypad_handler  ; carry not clear = handle the CA1 interrupt (keypad)
0009A5r 1  4C rr rr       jmp exit_irq
0009A8r 1               
0009A8r 1               
0009A8r 1               next_device:
0009A8r 1               
0009A8r 1               exit_irq:
0009A8r 1               
0009A8r 1  7A             ply
0009A9r 1  FA             plx
0009AAr 1  68             pla
0009ABr 1  40             rti
0009ACr 1               
0009ACr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0009ACr 1               ;;
0009ACr 1               ;;      String and data byte variables
0009ACr 1               ;;
0009ACr 1               ;;
0009ACr 1               ;;
0009ACr 1               
0009ACr 1               ;pause_msg: .asciiz "Mark Time     "
0009ACr 1  3C 73 68 69  start_msg: .asciiz "<shift>+C to start"
0009B0r 1  66 74 3E 2B  
0009B4r 1  43 20 74 6F  
0009BFr 1  24 61 64 64  new_address_msg: .asciiz "$addr $dd C Dec"
0009C3r 1  72 20 24 64  
0009C7r 1  64 20 43 20  
0009CFr 1               ;new_address_msg: .asciiz "View/Edit Memory"
0009CFr 1  38 20 42 79  block_address_msg: .asciiz "8 Byte view"
0009D3r 1  74 65 20 76  
0009D7r 1  69 65 77 00  
0009DBr 1  2E 2E 2E 53  title: .asciiz "...Shed Brain v1..."
0009DFr 1  68 65 64 20  
0009E3r 1  42 72 61 69  
0009EFr 1  4D 69 73 73  emt: .asciiz "Mission Time    "
0009F3r 1  69 6F 6E 20  
0009F7r 1  54 69 6D 65  
000A00r 1  73 68 65 64  splash: .asciiz "shed> "
000A04r 1  3E 20 00     
000A07r 1  42 65 67 69  mem_start_msg: .asciiz "Begin RAM Test"
000A0Br 1  6E 20 52 41  
000A0Fr 1  4D 20 54 65  
000A16r 1  52 41 4D 20  mem_pass_msg: .asciiz "RAM Test Pass"
000A1Ar 1  54 65 73 74  
000A1Er 1  20 50 61 73  
000A24r 1  4D 65 6D 6F  mem_complete_msg: .asciiz "Memory Test Complete"
000A28r 1  72 79 20 54  
000A2Cr 1  65 73 74 20  
000A39r 1               
000A39r 1               
000A39r 1               
000A39r 1  54 68 69 73  userPrompt: .asciiz "This is shed! "
000A3Dr 1  20 69 73 20  
000A41r 1  73 68 65 64  
000A48r 1               
000A48r 1  64 rr A9 20  userProg: .byte $64, MESSAGE_POINTER, $A9, $20, $85, MESSAGE_POINTER + 1, $20, <print4, >print4, $60, $00
000A4Cr 1  85 rr 20 rr  
000A50r 1  rr 60 00     
000A53r 1               
000A53r 1  01 03 06 0C  kitLeds: .byte $01, $03, $06, $0C, $18, $30, $60, $C0, $80, $C0, $60, $30, $18, $0C, $06, $03, $01
000A57r 1  18 30 60 C0  
000A5Br 1  80 C0 60 30  
000A64r 1               
000A64r 1               
000A64r 1               ; Reset/IRQ vectors
000A64r 1               
000A64r 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr          .word nmi
000002r 1  rr rr          .word reset
000004r 1  rr rr          .word irq
000004r 1               
