ca65 V2.18 - Debian 2.19-1
Main file   : monitor_dev.s
Current file: monitor_dev.s

000000r 1               
000000r 1               
000000r 1               .include "6522.inc"
000000r 2               
000000r 2               ; VIA Port addresses
000000r 2               PORTB = $6000
000000r 2               PORTA = $6001
000000r 2               DDRB = $6002
000000r 2               DDRA = $6003
000000r 2               
000000r 2               T1CL = $6004
000000r 2               T1CH = $6005
000000r 2               
000000r 2               ACR = $600b
000000r 2               PCR = $600c
000000r 2               IFR_1 = $600d
000000r 2               IER = $600e
000000r 2               
000000r 2               ; LCD Command masks
000000r 2               E  = %01000000
000000r 2               RW = %00100000
000000r 2               RS = %00010000
000000r 2               
000000r 2               
000000r 1               .include "rtc.inc"
000000r 2               
000000r 2               
000000r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000000r 2               ;;
000000r 2               ;;                          RTC / Jiffy Tick
000000r 2               ;;
000000r 2               
000000r 2               
000000r 2               
000000r 2               rtc:
000000r 2               
000000r 2               
000000r 2               ;;  RTC stores ticks at 10ms intervals into a 4-byte (32 bit) value
000000r 2               ;;
000000r 2               ;;  as each byte rolls over the next one is incremented
000000r 2               ;;  on a tick that doesn't roll over the TIME OF DAY
000000r 2               ;;  is updated
000000r 2               
000000r 2  EE rr rr       inc TICKS
000003r 2  D0 0D          bne inc_MET
000005r 2  EE rr rr       inc TICKS + 1
000008r 2  D0 08          bne inc_MET
00000Ar 2  EE rr rr       inc TICKS + 2
00000Dr 2  D0 03          bne inc_MET
00000Fr 2  EE rr rr       inc TICKS + 3
000012r 2               
000012r 2               ;;
000012r 2               ;;  Every time it's called we increment the "hundredths of a second" byte
000012r 2               ;;
000012r 2               ;;  When there's been 100 x 10ms (i.e. 1 second) we increment the seconds
000012r 2               ;;
000012r 2               ;;  When SECONDS reaches 60 we increment MINUTES and reset SECONDS to zero...
000012r 2               ;;  etc... for HOURS, DAYS etc.
000012r 2               ;;
000012r 2               ;;  days/months years are handled too - although probably moot
000012r 2               ;;
000012r 2               ;;  this routine comes from http://wilsonminesco.com/6502interrupts/#2.1
000012r 2               ;;
000012r 2               inc_MET:
000012r 2  EE rr rr       inc CENTISEC
000015r 2  AD rr rr       lda CENTISEC
000018r 2  C9 64          cmp #100
00001Ar 2  30 54          bmi end_MET
00001Cr 2  9C rr rr       stz CENTISEC
00001Fr 2               
00001Fr 2  EE rr rr       inc SECONDS
000022r 2  AD rr rr       lda SECONDS
000025r 2  C9 0A          cmp #10
000027r 2  30 47          bmi end_MET
000029r 2  9C rr rr       stz SECONDS
00002Cr 2  EE rr rr       inc TEN_SECONDS
00002Fr 2               
00002Fr 2  AD rr rr       lda TEN_SECONDS
000032r 2  C9 06          cmp #6
000034r 2  30 3A          bmi end_MET
000036r 2  9C rr rr       stz TEN_SECONDS
000039r 2               
000039r 2  EE rr rr       inc MINUTES
00003Cr 2  AD rr rr       lda MINUTES
00003Fr 2  C9 0A          cmp #10
000041r 2  30 2D          bmi end_MET
000043r 2  9C rr rr       stz MINUTES
000046r 2               
000046r 2  EE rr rr       inc TEN_MINUTES
000049r 2  AD rr rr       lda TEN_MINUTES
00004Cr 2  C9 06          cmp #6
00004Er 2  30 20          bmi end_MET
000050r 2  9C rr rr       stz TEN_MINUTES
000053r 2               
000053r 2  EE rr rr       inc HRS
000056r 2  AD rr rr       lda HRS
000059r 2  C9 0A          cmp #10
00005Br 2  30 13          bmi end_MET
00005Dr 2  9C rr rr       stz HRS
000060r 2               
000060r 2  EE rr rr       inc TEN_HRS
000063r 2  AD rr rr       lda TEN_HRS
000066r 2  C9 0A          cmp #10
000068r 2  30 06          bmi end_MET
00006Ar 2  9C rr rr       stz TEN_HRS
00006Dr 2               
00006Dr 2  EE rr rr       inc HUNDRED_HRS
000070r 2               
000070r 2               end_MET:
000070r 2  60             rts
000071r 2               
000071r 2               
000071r 1               .include "lcd.inc"
000071r 2               
000071r 2               
000071r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000071r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000071r 2               ;;
000071r 2               ;;
000071r 2               ;;                              LCD Functions
000071r 2               ;;
000071r 2               ;;
000071r 2               ;;
000071r 2               lcd_wait:
000071r 2  48             pha
000072r 2  A9 70          lda #%01110000  ; LCD data is input (don't change MSB BIT7, it has to stay ZERO for SHIFT Button input)
000074r 2  8D 02 60       sta DDRB
000077r 2               lcdbusy:
000077r 2  A9 20          lda #RW
000079r 2  8D 00 60       sta PORTB
00007Cr 2  A9 60          lda #(RW | E)
00007Er 2  8D 00 60       sta PORTB
000081r 2  AD 00 60       lda PORTB       ; Read high nibble
000084r 2  48             pha             ; and put on stack since it has the busy flag
000085r 2  A9 20          lda #RW
000087r 2  8D 00 60       sta PORTB
00008Ar 2  A9 60          lda #(RW | E)
00008Cr 2  8D 00 60       sta PORTB
00008Fr 2  AD 00 60       lda PORTB       ; Read low nibble
000092r 2  68             pla             ; Get high nibble off stack
000093r 2  29 08          and #%00001000
000095r 2  D0 E0          bne lcdbusy
000097r 2               
000097r 2  A9 20          lda #RW
000099r 2  8D 00 60       sta PORTB
00009Cr 2  A9 7F          lda #%01111111  ; LCD data is output (don't change MSB BIT7, it has to stay ZERO for SHIFT Buttion input)
00009Er 2  8D 02 60       sta DDRB
0000A1r 2  68             pla
0000A2r 2  60             rts
0000A3r 2               
0000A3r 2               lcd_init:
0000A3r 2  A9 02          lda #%00000010 ; Set 4-bit mode
0000A5r 2  8D 00 60       sta PORTB
0000A8r 2  09 40          ora #E
0000AAr 2  8D 00 60       sta PORTB
0000ADr 2  29 0F          and #%00001111
0000AFr 2  8D 00 60       sta PORTB
0000B2r 2  60             rts
0000B3r 2               
0000B3r 2               lcd_instruction:
0000B3r 2  20 rr rr       jsr lcd_wait
0000B6r 2  48             pha
0000B7r 2  4A             lsr
0000B8r 2  4A             lsr
0000B9r 2  4A             lsr
0000BAr 2  4A             lsr            ; Send high 4 bits
0000BBr 2  8D 00 60       sta PORTB
0000BEr 2  09 40          ora #E         ; Set E bit to send instruction
0000C0r 2  8D 00 60       sta PORTB
0000C3r 2  49 40          eor #E         ; Clear E bit
0000C5r 2  8D 00 60       sta PORTB
0000C8r 2  68             pla
0000C9r 2  29 0F          and #%00001111 ; Send low 4 bits
0000CBr 2  8D 00 60       sta PORTB
0000CEr 2  09 40          ora #E         ; Set E bit to send instruction
0000D0r 2  8D 00 60       sta PORTB
0000D3r 2  49 40          eor #E         ; Clear E bit
0000D5r 2  8D 00 60       sta PORTB
0000D8r 2  60             rts
0000D9r 2               
0000D9r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000D9r 2               ;;
0000D9r 2               ;;        PRINT Characters on LCD - an ASCII value in Accumulator
0000D9r 2               ;;        is printed on the display
0000D9r 2               ;;
0000D9r 2               
0000D9r 2               print_char:
0000D9r 2  20 rr rr       jsr lcd_wait
0000DCr 2  48             pha
0000DDr 2  4A             lsr
0000DEr 2  4A             lsr
0000DFr 2  4A             lsr
0000E0r 2  4A             lsr             ; Send high 4 bits
0000E1r 2  09 10          ora #RS         ; Set RS
0000E3r 2  8D 00 60       sta PORTB
0000E6r 2  09 40          ora #E          ; Set E bit to send instruction
0000E8r 2  8D 00 60       sta PORTB
0000EBr 2  49 40          eor #E          ; Clear E bit
0000EDr 2  8D 00 60       sta PORTB
0000F0r 2  68             pla
0000F1r 2  29 0F          and #%00001111  ; Send low 4 bits
0000F3r 2  09 10          ora #RS         ; Set RS
0000F5r 2  8D 00 60       sta PORTB
0000F8r 2  09 40          ora #E          ; Set E bit to send instruction
0000FAr 2  8D 00 60       sta PORTB
0000FDr 2  49 40          eor #E          ; Clear E bit
0000FFr 2  8D 00 60       sta PORTB
000102r 2  60             rts
000103r 2               
000103r 2               
000103r 1               .include "getkey.inc"
000103r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000103r 2               ;;
000103r 2               ;;
000103r 2               ;;      READ THE 4x4 keypad using  VIA_1 PORTA
000103r 2               ;;
000103r 2               ;;      Accumulator holds the ASCII value of the pressed key when it returns
000103r 2               ;;
000103r 2               
000103r 2               get_key:
000103r 2               readKeypad:
000103r 2  A2 04          ldx #$04        ; Row 4 - counting down
000105r 2  A0 80          ldy #%10000000  ;
000107r 2               ScanRow:
000107r 2  8C 01 60       sty PORTA
00010Ar 2  AD 01 60       lda PORTA
00010Dr 2  29 0F          and #%00001111  ; mask off keypad input - only low 4 (keypad column) bits are read
00010Fr 2  C9 00          cmp #$00
000111r 2  D0 0B          bne Row_Found   ; non-zero means a row output has been connected via a switch to a column input
000113r 2  CA             dex             ; zero means it hasn't been found, so check next row down
000114r 2  98             tya
000115r 2  4A             lsr
000116r 2  A8             tay
000117r 2  C9 08          cmp #%00001000
000119r 2  D0 EC          bne ScanRow
00011Br 2  A9 FF          lda #$ff
00011Dr 2  60             rts
00011Er 2               Row_Found:
00011Er 2  8E rr rr       stx TEMP ; store row
000121r 2  A0 FF          ldy #$ff
000123r 2               FindCol:
000123r 2  C8             iny
000124r 2  4A             lsr
000125r 2  90 FC          bcc FindCol
000127r 2  98             tya
000128r 2  0A             asl
000129r 2  0A             asl  ; col * 4
00012Ar 2  18             clc
00012Br 2  6D rr rr       adc TEMP ; add row
00012Er 2  AA             tax
00012Fr 2  BD rr rr       lda keypad_array,x
000132r 2  60             rts
000133r 2               
000133r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000133r 2               ;;
000133r 2               ;;  set ROW keypad outputs high as a source for triggering interrupt when a key is pressed
000133r 2               ;;
000133r 2               ;;
000133r 2               scan:
000133r 2  A0 F0          ldy #%11110000
000135r 2  8C 01 60       sty PORTA
000138r 2  60             rts
000139r 2               
000139r 2               
000139r 1               
000139r 1               
000139r 1               .SEGMENT "ZEROPAGE"
000000r 1               
000000r 1  xx xx        DUMP_POINTER:     .res 2
000002r 1  xx xx        MESSAGE_POINTER:  .res 2
000004r 1  xx           FLAGS:            .res 1
000005r 1               
000005r 1               
000005r 1               .SEGMENT "BSS"
000000r 1               
000000r 1  xx           INKEY:            .res 1
000001r 1  xx xx xx xx  ASCII:            .res 4
000005r 1  xx xx        BYTE:             .res 2
000007r 1  xx           TOGGLE_TIME:      .res 1
000008r 1  xx           CLOCK_LAST:       .res 1
000009r 1  xx           TENS:             .res 1
00000Ar 1  xx           HUNDREDS:         .res 1
00000Br 1  xx xx        HEX:              .res 2
00000Dr 1  xx xx        HEXB:             .res 2
00000Fr 1  xx xx xx xx  TICKS:            .res 4
000013r 1  xx           TEMP:             .res 1
000014r 1  xx           TEMP2:            .res 1
000015r 1  xx           CENTISEC:         .res 1
000016r 1  xx           SECONDS:          .res 1
000017r 1  xx           TEN_SECONDS:      .res 1
000018r 1  xx           MINUTES:          .res 1
000019r 1  xx           TEN_MINUTES:      .res 1
00001Ar 1  xx           HRS:              .res 1
00001Br 1  xx           TEN_HRS:          .res 1
00001Cr 1  xx           HUNDRED_HRS:      .res 1
00001Dr 1  xx           DAY:              .res 1
00001Er 1               
00001Er 1                 .code
000139r 1               
000139r 1               
000139r 1               reset:
000139r 1  A2 FF          ldx #$ff
00013Br 1  9A             txs
00013Cr 1               ;; IFR Flags
00013Cr 1               ;; B7  B6  B5  B4  B3  B2  B1  B0
00013Cr 1               ;; IRQ TI1 TI2 CB1 CB2 SR CA1 CA2
00013Cr 1               
00013Cr 1  A9 DA          lda #%11011010  ; T1, CA1 active
00013Er 1  8D 0E 60       sta IER
000141r 1               
000141r 1  A9 01          lda #$01  ;  CA1 active high-transition
000143r 1  8D 0C 60       sta PCR
000146r 1               
000146r 1  58             cli      ; interrupts ON
000147r 1               
000147r 1  A9 7F          lda #%01111111 ; Set all pins on port B to output except BIT 7 which is used for "SHIFT/INSTRUCTION"  button
000149r 1  8D 02 60       sta DDRB
00014Cr 1  A9 F0          lda #%11110000 ; Set low-nibble pins on port A to input and high-nibble pins to output, for keypad
00014Er 1  8D 03 60       sta DDRA
000151r 1               
000151r 1  20 rr rr       jsr lcd_init
000154r 1  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
000156r 1  20 rr rr       jsr lcd_instruction
000159r 1  A9 0E          lda #%00001110 ; Display on; cursor on; blink off
00015Br 1  20 rr rr       jsr lcd_instruction
00015Er 1  A9 06          lda #%00000110 ; Increment and shift cursor; don't shift display
000160r 1  20 rr rr       jsr lcd_instruction
000163r 1  A9 01          lda #%00000001 ; Clear display
000165r 1  20 rr rr       jsr lcd_instruction
000168r 1               
000168r 1  A9 rr          lda #<splash
00016Ar 1  85 rr          sta MESSAGE_POINTER
00016Cr 1  A9 rr          lda #>splash
00016Er 1  85 rr          sta MESSAGE_POINTER + 1
000170r 1               
000170r 1               
000170r 1               init_variables:
000170r 1  9C rr rr       stz TICKS
000173r 1  9C rr rr       stz TICKS + 1
000176r 1  9C rr rr       stz TICKS + 2
000179r 1  9C rr rr       stz TICKS + 3
00017Cr 1  64 rr          stz DUMP_POINTER
00017Er 1  64 rr          stz DUMP_POINTER + 1
000180r 1  9C rr rr       stz TOGGLE_TIME
000183r 1  64 rr          stz FLAGS
000185r 1  9C rr rr       stz SECONDS
000188r 1  9C rr rr       stz TEN_SECONDS
00018Br 1  9C rr rr       stz MINUTES
00018Er 1  9C rr rr       stz HRS
000191r 1  9C rr rr       stz TEN_HRS
000194r 1  9C rr rr       stz TEN_MINUTES
000197r 1  9C rr rr       stz HUNDRED_HRS
00019Ar 1  9C rr rr       stz DAY
00019Dr 1  9C rr rr       stz TEMP
0001A0r 1  9C rr rr       stz TEMP2
0001A3r 1  9C rr rr       stz TENS
0001A6r 1               
0001A6r 1               init_via:
0001A6r 1  A9 40          lda #%01000000
0001A8r 1  8D 0B 60       sta ACR
0001ABr 1  A9 0E          lda #$0E
0001ADr 1  8D 04 60       sta T1CL
0001B0r 1  A9 27          lda #$27
0001B2r 1  8D 05 60       sta T1CH
0001B5r 1               
0001B5r 1               user_ram_fill:
0001B5r 1  A9 EA          lda #$ea
0001B7r 1  A2 FF          ldx #$ff
0001B9r 1               fill:
0001B9r 1  9D 00 30       sta $3000,x
0001BCr 1  CA             dex
0001BDr 1  D0 FA          bne fill
0001BFr 1  9C 00 30       stz $3000
0001C2r 1  A9 60          lda #$60
0001C4r 1  8D FF 30       sta $30ff
0001C7r 1               
0001C7r 1               ; go straight to MONITOR at startup
0001C7r 1               
0001C7r 1  20 rr rr       jsr new_address
0001CAr 1               
0001CAr 1               ; main loop
0001CAr 1               loop:
0001CAr 1  20 rr rr       jsr check_flags
0001CDr 1  4C rr rr       jmp loop
0001D0r 1               
0001D0r 1               
0001D0r 1               ;;;;;;;;;;;;; FUNCTIONS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0001D0r 1               ;;
0001D0r 1               ;;
0001D0r 1               
0001D0r 1               check_flags:
0001D0r 1  8F rr 04       bbs0 FLAGS, update_block_address
0001D3r 1  DF rr 16       bbs5 FLAGS, clock_time
0001D6r 1                 ; check other flags... other actions....
0001D6r 1  60             rts
0001D7r 1               
0001D7r 1               update_block_address:
0001D7r 1  38             sec
0001D8r 1  AD rr rr       lda TICKS
0001DBr 1  ED rr rr       sbc TOGGLE_TIME
0001DEr 1  C9 32          cmp #$32
0001E0r 1  90 09          bcc exit_update_block
0001E2r 1  20 rr rr       jsr block_address
0001E5r 1  AD rr rr       lda TICKS
0001E8r 1  8D rr rr       sta TOGGLE_TIME
0001EBr 1               
0001EBr 1               exit_update_block:
0001EBr 1  60             rts
0001ECr 1               
0001ECr 1               
0001ECr 1               clock_time:
0001ECr 1               
0001ECr 1  38             sec
0001EDr 1  AD rr rr       lda TICKS
0001F0r 1  ED rr rr       sbc CLOCK_LAST
0001F3r 1  C9 32          cmp #$32
0001F5r 1  90 44          bcc exit_clock
0001F7r 1  A9 0C          lda #%00001100 ; Display on; cursor on; blink off
0001F9r 1  20 rr rr       jsr lcd_instruction
0001FCr 1               
0001FCr 1  A9 02          lda #%00000010 ; cursor HOME
0001FEr 1  20 rr rr       jsr lcd_instruction
000201r 1  AD rr rr       lda HUNDRED_HRS
000204r 1  20 rr rr       jsr bintoascii
000207r 1  AD rr rr       lda TEN_HRS
00020Ar 1  20 rr rr       jsr bintoascii
00020Dr 1  AD rr rr       lda HRS
000210r 1  20 rr rr       jsr bintoascii
000213r 1  A9 3A          lda #':'
000215r 1  20 rr rr       jsr print_char
000218r 1  AD rr rr       lda TEN_MINUTES
00021Br 1  20 rr rr       jsr bintoascii
00021Er 1  AD rr rr       lda MINUTES
000221r 1  20 rr rr       jsr bintoascii
000224r 1  A9 3A          lda #':'
000226r 1  20 rr rr       jsr print_char
000229r 1  AD rr rr       lda TEN_SECONDS
00022Cr 1  20 rr rr       jsr bintoascii
00022Fr 1  AD rr rr       lda SECONDS
000232r 1  20 rr rr       jsr bintoascii
000235r 1  AD rr rr       lda TICKS
000238r 1  8D rr rr       sta CLOCK_LAST
00023Br 1               exit_clock:
00023Br 1  60             rts
00023Cr 1               
00023Cr 1               
00023Cr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00023Cr 1               ;;
00023Cr 1               ;;      update screen when new memory location is selected
00023Cr 1               ;;
00023Cr 1               ;;
00023Cr 1               new_address:
00023Cr 1               
00023Cr 1  A9 01          lda #%00000001 ; Clear display
00023Er 1  20 rr rr       jsr lcd_instruction
000241r 1  A9 0F          lda #%00001111 ; Display on; cursor on; blink off
000243r 1  20 rr rr       jsr lcd_instruction
000246r 1               
000246r 1               
000246r 1               print_address:
000246r 1  A9 24          lda #'$'
000248r 1  20 rr rr       jsr print_char
00024Br 1  A5 rr          lda DUMP_POINTER + 1
00024Dr 1  20 rr rr       jsr bintohex
000250r 1  A5 rr          lda DUMP_POINTER
000252r 1  20 rr rr       jsr bintohex
000255r 1               
000255r 1  A9 20          lda #' '
000257r 1  20 rr rr       jsr print_char
00025Ar 1               
00025Ar 1               print_data:
00025Ar 1               
00025Ar 1  A0 00          ldy #$00
00025Cr 1               
00025Cr 1  B1 rr          lda (DUMP_POINTER),y
00025Er 1  20 rr rr       jsr bintohex
000261r 1  A9 20          lda #' '
000263r 1  20 rr rr       jsr print_char
000266r 1  B1 rr          lda (DUMP_POINTER),y
000268r 1  20 rr rr       jsr print_char
00026Br 1               
00026Br 1               message_end:
00026Br 1  20 rr rr       jsr print   ; add second line (cursor) after re-writing the top line
00026Er 1  60             rts
00026Fr 1               
00026Fr 1               
00026Fr 1               
00026Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00026Fr 1               ;;
00026Fr 1               ;; display 8 bytes of data for a "block" of memory
00026Fr 1               ;;
00026Fr 1               ;;
00026Fr 1               block_address:
00026Fr 1               
00026Fr 1  A9 01          lda #%00000001 ; Clear display
000271r 1  20 rr rr       jsr lcd_instruction
000274r 1               
000274r 1  A0 00          ldy #$00
000276r 1               
000276r 1               print_block_address:
000276r 1  A9 24          lda #'$'
000278r 1  20 rr rr       jsr print_char
00027Br 1  A5 rr          lda DUMP_POINTER + 1
00027Dr 1  20 rr rr       jsr bintohex
000280r 1  A5 rr          lda DUMP_POINTER
000282r 1  20 rr rr       jsr bintohex
000285r 1               
000285r 1  A9 A9          lda #%10101001
000287r 1  20 rr rr       jsr lcd_instruction
00028Ar 1               
00028Ar 1               print_block:
00028Ar 1               
00028Ar 1  B1 rr          lda (DUMP_POINTER),y
00028Cr 1  20 rr rr       jsr bintohex
00028Fr 1  B1 rr          lda (DUMP_POINTER),y
000291r 1  C8             iny
000292r 1  C0 08          cpy #$08
000294r 1  D0 F4          bne print_block
000296r 1               
000296r 1               
000296r 1               block_message_end:
000296r 1  60             rts
000297r 1               
000297r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000297r 1               ;;
000297r 1               ;; re-draw line 2 cursor
000297r 1               ;;
000297r 1               ;;
000297r 1               print:
000297r 1               
000297r 1  A9 A9          lda #%10101001
000299r 1  20 rr rr       jsr lcd_instruction
00029Cr 1               
00029Cr 1  A0 00          ldy #0
00029Er 1               line1:
00029Er 1  B1 rr          lda (MESSAGE_POINTER),y
0002A0r 1  F0 07          beq end_print
0002A2r 1  20 rr rr       jsr print_char
0002A5r 1  C8             iny
0002A6r 1  4C rr rr       jmp line1
0002A9r 1               
0002A9r 1               end_print:
0002A9r 1               
0002A9r 1  60             rts
0002AAr 1               
0002AAr 1               
0002AAr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002AAr 1               ;;
0002AAr 1               ;;      Convert a decimal number entered at keypad into its
0002AAr 1               ;;      HEX equivalent and display
0002AAr 1               ;;
0002AAr 1               byte_to_hex:
0002AAr 1               
0002AAr 1  A9 01          lda #%00000001 ; Clear display
0002ACr 1  20 rr rr       jsr lcd_instruction
0002AFr 1  AD rr rr       lda HEXB + 1
0002B2r 1  29 0F          and #$0f
0002B4r 1  20 rr rr       jsr bintohex
0002B7r 1  AD rr rr       lda HEXB
0002BAr 1  20 rr rr       jsr bintohex
0002BDr 1  A9 64          lda #'d'
0002BFr 1  20 rr rr       jsr print_char
0002C2r 1  A9 3D          lda #'='
0002C4r 1  20 rr rr       jsr print_char
0002C7r 1  A9 24          lda #'$'
0002C9r 1  20 rr rr       jsr print_char
0002CCr 1               
0002CCr 1  AD rr rr       lda HEXB ; lo byte
0002CFr 1  48             pha
0002D0r 1  4A             lsr
0002D1r 1  4A             lsr
0002D2r 1  4A             lsr
0002D3r 1  4A             lsr
0002D4r 1  20 rr rr       jsr mult10
0002D7r 1  8D rr rr       sta TENS
0002DAr 1  68             pla
0002DBr 1  29 0F          and #%00001111 ; UNITS
0002DDr 1               ;  jsr mult10
0002DDr 1  18             clc
0002DEr 1  6D rr rr       adc TENS
0002E1r 1  8D rr rr       sta HEX
0002E4r 1               
0002E4r 1  AD rr rr       lda HEXB + 1 ; hi byte
0002E7r 1  29 0F          and #%00001111
0002E9r 1  20 rr rr       jsr mult10
0002ECr 1  20 rr rr       jsr mult10 ; hundreds
0002EFr 1  6D rr rr       adc HEX
0002F2r 1               
0002F2r 1               
0002F2r 1  20 rr rr       jsr bintohex
0002F5r 1  A9 A9          lda #%10101001
0002F7r 1  20 rr rr       jsr lcd_instruction
0002FAr 1  60             rts
0002FBr 1               
0002FBr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002FBr 1               ;;
0002FBr 1               ;;  (A * 8) + (A * 2) = A * 10
0002FBr 1               
0002FBr 1               mult10:
0002FBr 1  48             pha
0002FCr 1  0A             asl
0002FDr 1  0A             asl
0002FEr 1  0A             asl
0002FFr 1  8D rr rr       sta TEMP2 ; A*8
000302r 1  68             pla
000303r 1  0A             asl      ; A*2
000304r 1  6D rr rr       adc TEMP2 ; A*10
000307r 1  60             rts
000308r 1               
000308r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000308r 1               ;;
000308r 1               ;;          convert a binary number from Accumulator, in range 00000000 -> 11111111 ($00 to $FF)
000308r 1               ;;          to its HEX number encode as ASCII -  using a simple lookup table and print it on LCD
000308r 1               ;;
000308r 1               bintohex:
000308r 1  48             pha
000309r 1  4A             lsr
00030Ar 1  4A             lsr
00030Br 1  4A             lsr
00030Cr 1  4A             lsr
00030Dr 1  AA             tax
00030Er 1  BD rr rr       lda hexascii,x
000311r 1  20 rr rr       jsr print_char
000314r 1  68             pla
000315r 1  29 0F          and #$0f
000317r 1  AA             tax
000318r 1  BD rr rr       lda hexascii,x
00031Br 1  20 rr rr       jsr print_char
00031Er 1  60             rts
00031Fr 1               
00031Fr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00031Fr 1               ;;
00031Fr 1               ;;    convert a binary (hex) value in Accumulator into
00031Fr 1               ;;    its ASCII equivalent character in decimal 0-99 and print it
00031Fr 1               ;;    this converts hex/binary numbers from the RTC into human readable
00031Fr 1               ;;    decimal for display on clock
00031Fr 1               
00031Fr 1               
00031Fr 1               bintoascii:
00031Fr 1               
00031Fr 1  C9 0A          cmp #10
000321r 1  30 10          bmi single_figure
000323r 1  0A             asl
000324r 1  AA             tax
000325r 1  BD rr rr       lda binascii,x
000328r 1  20 rr rr       jsr print_char
00032Br 1               
00032Br 1  E8             inx
00032Cr 1               
00032Cr 1  BD rr rr       lda binascii,x
00032Fr 1  20 rr rr       jsr print_char
000332r 1  60             rts
000333r 1               
000333r 1               single_figure:
000333r 1  0A             asl
000334r 1  AA             tax
000335r 1  E8             inx
000336r 1  BD rr rr       lda binascii,x
000339r 1  20 rr rr       jsr print_char
00033Cr 1  60             rts
00033Dr 1               
00033Dr 1               
00033Dr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00033Dr 1               ;;
00033Dr 1               ;;      Monitor function - decrement the selected address
00033Dr 1               ;;
00033Dr 1               ;;
00033Dr 1               decrement_address:
00033Dr 1               
00033Dr 1  38             sec
00033Er 1  A5 rr          lda DUMP_POINTER
000340r 1  E9 01          sbc #$01
000342r 1  85 rr          sta DUMP_POINTER
000344r 1  8D rr rr       sta BYTE
000347r 1  A5 rr          lda DUMP_POINTER + 1
000349r 1  E9 00          sbc #$00
00034Br 1  85 rr          sta DUMP_POINTER + 1
00034Dr 1  8D rr rr       sta BYTE + 1
000350r 1               dec_ok:
000350r 1  60             rts
000351r 1               
000351r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000351r 1               ;;
000351r 1               ;;      Monitor function - increment the selected address
000351r 1               ;;
000351r 1               ;;
000351r 1               
000351r 1               increment_address:
000351r 1               
000351r 1  18             clc
000352r 1  A5 rr          lda DUMP_POINTER
000354r 1  69 01          adc #$01
000356r 1  85 rr          sta DUMP_POINTER
000358r 1  8D rr rr       sta BYTE
00035Br 1  90 07          bcc inc_ok
00035Dr 1  E6 rr          inc DUMP_POINTER + 1
00035Fr 1  A5 rr          lda DUMP_POINTER + 1
000361r 1  8D rr rr       sta BYTE + 1
000364r 1               inc_ok:
000364r 1  60             rts
000365r 1               
000365r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000365r 1               ;;
000365r 1               ;;      Monitor function - increment the selected block of  addresses by 8
000365r 1               ;;
000365r 1               ;;
000365r 1               
000365r 1               increment_block:
000365r 1  18             clc
000366r 1  A5 rr          lda DUMP_POINTER
000368r 1  69 08          adc #$08
00036Ar 1  85 rr          sta DUMP_POINTER
00036Cr 1  8D rr rr       sta BYTE
00036Fr 1  A5 rr          lda DUMP_POINTER + 1
000371r 1  69 00          adc #$00
000373r 1  85 rr          sta DUMP_POINTER + 1
000375r 1  8D rr rr       sta BYTE + 1
000378r 1  60             rts
000379r 1               
000379r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000379r 1               ;;
000379r 1               ;;      Monitor function - decrement the selected block of  addresses by 8
000379r 1               ;;
000379r 1               ;;
000379r 1               
000379r 1               decrement_block:
000379r 1               
000379r 1  38             sec
00037Ar 1  A5 rr          lda DUMP_POINTER
00037Cr 1  E9 08          sbc #$08
00037Er 1  85 rr          sta DUMP_POINTER
000380r 1  8D rr rr       sta BYTE
000383r 1  A5 rr          lda DUMP_POINTER + 1
000385r 1  E9 00          sbc #$00
000387r 1  85 rr          sta DUMP_POINTER + 1
000389r 1  8D rr rr       sta BYTE + 1
00038Cr 1  60             rts
00038Dr 1               
00038Dr 1               
00038Dr 1               
00038Dr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00038Dr 1               ;;
00038Dr 1               ;;          use last 4 entered ASCII characters from the keypad and convert
00038Dr 1               ;;          them to TWO 8-bit binary bytes in RAM
00038Dr 1               ;;
00038Dr 1               ;;
00038Dr 1               ascii_byte:
00038Dr 1               
00038Dr 1  AD rr rr       lda ASCII + 1
000390r 1               
000390r 1  20 rr rr       jsr ascii_bin
000393r 1  18             clc
000394r 1  0A             asl
000395r 1  0A             asl
000396r 1  0A             asl
000397r 1  0A             asl
000398r 1  8D rr rr       sta BYTE
00039Br 1               
00039Br 1  AD rr rr       lda ASCII
00039Er 1               
00039Er 1  20 rr rr       jsr ascii_bin
0003A1r 1  0D rr rr       ora BYTE
0003A4r 1  8D rr rr       sta BYTE
0003A7r 1               
0003A7r 1  AD rr rr       lda ASCII + 3
0003AAr 1  20 rr rr       jsr ascii_bin
0003ADr 1  18             clc
0003AEr 1  0A             asl
0003AFr 1  0A             asl
0003B0r 1  0A             asl
0003B1r 1  0A             asl
0003B2r 1  8D rr rr       sta BYTE + 1
0003B5r 1               
0003B5r 1  AD rr rr       lda ASCII + 2
0003B8r 1               
0003B8r 1  20 rr rr       jsr ascii_bin
0003BBr 1  0D rr rr       ora BYTE + 1
0003BEr 1  8D rr rr       sta BYTE + 1
0003C1r 1  60             rts
0003C2r 1               
0003C2r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;
0003C2r 1               ;;
0003C2r 1               ;; Convert the encoded ASCII character representing a hex digit to its actual binary value.
0003C2r 1               ;;
0003C2r 1               ;; e.g. Letter "A" in ASCII is $41 (0100001) but its "numerical" value as a hex digit is
0003C2r 1               ;; 10 ($0A = 10d).
0003C2r 1               ;;
0003C2r 1               ;; We convert "A" in ASCII ($41) to a byte of numerical value 10 by subtracting $37
0003C2r 1               ;; $41 - $37 = $0A (in decimal 65 - 55 = 10) and the result is a byte 00001010
0003C2r 1               ;; The same is done for all characters representing upper case letters.
0003C2r 1               ;;
0003C2r 1               ;; Numbers are handled differently according to their place on the ASCII table.
0003C2r 1               ;;
0003C2r 1               ;; The ASCII representation of "9" is $39 (00111001) and to get a byte with a value of 9 we can simply
0003C2r 1               ;; AND it with a mask of 00001111 to save only the lower 4 bits.
0003C2r 1               ;;
0003C2r 1               
0003C2r 1               ascii_bin:
0003C2r 1  18             clc
0003C3r 1  C9 41          cmp #$41
0003C5r 1  30 07          bmi ascii_bin_num   ; a CMP with $41, from a number character ($30 - $39), will set the negative flag
0003C7r 1                                     ; and the conversion is done by ANDing with $0F
0003C7r 1               
0003C7r 1               ascii_bin_letter:    ; otherwise treat as a letter (A -> F) and the conversion is done by
0003C7r 1  18             clc                ; subtracting $37
0003C8r 1  38             sec
0003C9r 1  E9 37          sbc #$37
0003CBr 1  4C rr rr       jmp end_ascii_bin
0003CEr 1               
0003CEr 1               ascii_bin_num:
0003CEr 1  29 0F          and #%00001111
0003D0r 1               
0003D0r 1               end_ascii_bin:      ; Accumulator holds the numerical version of the ASCII character supplied
0003D0r 1  60             rts
0003D1r 1               
0003D1r 1               
0003D1r 1               
0003D1r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003D1r 1               ;;
0003D1r 1               ;;    toggle the display/update of Clock on each appropriate keypress
0003D1r 1               ;;
0003D1r 1               show_clock:
0003D1r 1               
0003D1r 1  DF rr 05       bbs5 FLAGS, reset_bit5
0003D4r 1  D7 rr          smb5 FLAGS
0003D6r 1  4C rr rr       jmp exit_show_clock
0003D9r 1               
0003D9r 1               reset_bit5:
0003D9r 1               
0003D9r 1  57 rr          rmb5 FLAGS
0003DBr 1               
0003DBr 1               exit_show_clock:
0003DBr 1               
0003DBr 1  60             rts
0003DCr 1                 ;jmp debounce
0003DCr 1               
0003DCr 1               
0003DCr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003DCr 1               ;;
0003DCr 1               ;;    toggle the automatic update view of the "8-byte memory block"
0003DCr 1               ;;
0003DCr 1               show_block:
0003DCr 1               
0003DCr 1  8F rr 05       bbs0 FLAGS, reset_bit0
0003DFr 1  87 rr          smb0 FLAGS
0003E1r 1  4C rr rr       jmp exit_show_block
0003E4r 1               
0003E4r 1               reset_bit0:
0003E4r 1               
0003E4r 1  07 rr          rmb0 FLAGS
0003E6r 1               
0003E6r 1               exit_show_block:
0003E6r 1               
0003E6r 1  60             rts
0003E7r 1                 ;jmp debounce
0003E7r 1               
0003E7r 1               ;debounce:
0003E7r 1               ;  ldx #$ff
0003E7r 1               ;  ldy #$ff
0003E7r 1               ;delay:
0003E7r 1               ;  nop
0003E7r 1               ;  dex
0003E7r 1               ;  bne delay
0003E7r 1               ;  dey
0003E7r 1               ;  bne delay
0003E7r 1               ;  rts
0003E7r 1               
0003E7r 1               
0003E7r 1               ;;;;;;;;;;;;;;;;;; INTERRUPT HANDLERS ;;;;;;;;;;;;;;;;;;;;
0003E7r 1               
0003E7r 1               
0003E7r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003E7r 1               ;;
0003E7r 1               ;;      CB1 : reset & restart timer
0003E7r 1               ;;
0003E7r 1               
0003E7r 1               cb1_handler:
0003E7r 1  9C rr rr       stz HUNDRED_HRS
0003EAr 1  9C rr rr       stz TEN_HRS
0003EDr 1  9C rr rr       stz TEN_MINUTES
0003F0r 1  9C rr rr       stz TEN_SECONDS
0003F3r 1  9C rr rr       stz HRS
0003F6r 1  9C rr rr       stz MINUTES
0003F9r 1  9C rr rr       stz SECONDS
0003FCr 1               
0003FCr 1  D7 rr          smb5 FLAGS
0003FEr 1               
0003FEr 1  60             rts
0003FFr 1               
0003FFr 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0003FFr 1               ;;
0003FFr 1               ;;     CB2 : stop timer
0003FFr 1               ;;
0003FFr 1               
0003FFr 1               cb2_handler:
0003FFr 1  20 rr rr       jsr show_clock
000402r 1  60             rts
000403r 1               
000403r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000403r 1               ;;
000403r 1               ;;                    MONITOR / KEYPAD
000403r 1               ;;
000403r 1               ;;
000403r 1               
000403r 1               keypad_handler:
000403r 1               
000403r 1  20 rr rr       jsr get_key     ; READs from PORTA which also re-sets VIA's Interrupt flag
000406r 1  8D rr rr       sta INKEY       ; put the ASCII value of input into RAM ( $00 )
000409r 1               
000409r 1  AD 00 60       lda PORTB       ; check for SHIFT/INSTRUCTION button
00040Cr 1  29 80          and #%10000000
00040Er 1  F0 03          beq check_a ; done this way to get around the limit in size of branch jumps....
000410r 1  4C rr rr       jmp handle_new_char
000413r 1               
000413r 1               ; choose action of "SHIFTed" key-press
000413r 1               check_a:
000413r 1  AD rr rr       lda INKEY
000416r 1  C9 41          cmp #'A'
000418r 1                 ; move up one memory address and display contents
000418r 1  D0 09          bne check_b
00041Ar 1  20 rr rr       jsr increment_address
00041Dr 1  20 rr rr       jsr new_address
000420r 1  4C rr rr       jmp exit_key_irq
000423r 1               
000423r 1               check_b:
000423r 1  C9 42          cmp #'B'
000425r 1                 ; move down one memory address and display contents
000425r 1  D0 09          bne check_c
000427r 1  20 rr rr       jsr decrement_address
00042Ar 1  20 rr rr       jsr new_address
00042Dr 1  4C rr rr       jmp exit_key_irq
000430r 1               
000430r 1               check_c:
000430r 1  C9 43          cmp #'C'
000432r 1                 ; return to MONITOR
000432r 1  D0 15          bne check_d
000434r 1  57 rr          rmb5 FLAGS
000436r 1  A9 01          lda #%00000001
000438r 1  20 rr rr       jsr lcd_instruction
00043Br 1  A9 rr          lda #<splash
00043Dr 1  85 rr          sta MESSAGE_POINTER
00043Fr 1  A9 rr          lda #>splash
000441r 1  85 rr          sta MESSAGE_POINTER + 1
000443r 1               
000443r 1  20 rr rr       jsr new_address
000446r 1  4C rr rr       jmp exit_key_irq
000449r 1               
000449r 1               check_d:
000449r 1  C9 44          cmp #'D'
00044Br 1                 ; move monitor to entered 4-digit memory address
00044Br 1  D0 13          bne check_e
00044Dr 1  AD rr rr       lda BYTE
000450r 1  85 rr          sta DUMP_POINTER
000452r 1  AD rr rr       lda BYTE + 1
000455r 1  85 rr          sta DUMP_POINTER + 1
000457r 1  20 rr rr       jsr new_address
00045Ar 1  20 rr rr       jsr print
00045Dr 1  4C rr rr       jmp exit_key_irq
000460r 1               
000460r 1               check_e:
000460r 1  C9 45          cmp #'E'
000462r 1                 ; insert (POKE) byte of data in to current memory address, then increment to next address
000462r 1  D0 13          bne check_f
000464r 1  AD rr rr       lda BYTE
000467r 1  A0 00          ldy #$00
000469r 1  91 rr          sta (DUMP_POINTER),y
00046Br 1  20 rr rr       jsr increment_address
00046Er 1  20 rr rr       jsr new_address
000471r 1  20 rr rr       jsr print
000474r 1  4C rr rr       jmp exit_key_irq
000477r 1               
000477r 1               check_f:
000477r 1  C9 46          cmp #'F'
000479r 1                 ; show 8-byte wide block of memory
000479r 1  D0 12          bne check_1
00047Br 1  A0 00          ldy #$00
00047Dr 1  AD rr rr       lda BYTE
000480r 1  85 rr          sta DUMP_POINTER
000482r 1  AD rr rr       lda BYTE + 1
000485r 1  85 rr          sta DUMP_POINTER + 1
000487r 1  20 rr rr       jsr block_address
00048Ar 1  4C rr rr       jmp exit_key_irq
00048Dr 1               
00048Dr 1               check_1:
00048Dr 1  C9 31          cmp #'1'
00048Fr 1                 ; show/auto-update clock
00048Fr 1  D0 15          bne check_3
000491r 1  A9 01          lda #%00000001 ; Clear display
000493r 1  20 rr rr       jsr lcd_instruction
000496r 1  A9 rr          lda #<emt
000498r 1  85 rr          sta MESSAGE_POINTER
00049Ar 1  A9 rr          lda #>emt
00049Cr 1  85 rr          sta MESSAGE_POINTER + 1
00049Er 1  20 rr rr       jsr print
0004A1r 1  D7 rr          smb5 FLAGS
0004A3r 1               
0004A3r 1                 ;jsr show_clock
0004A3r 1  4C rr rr       jmp exit_key_irq
0004A6r 1               
0004A6r 1               check_3:
0004A6r 1  C9 33          cmp #'3'
0004A8r 1  D0 0B          bne check_6
0004AAr 1  A0 00          ldy #$00
0004ACr 1  20 rr rr       jsr increment_block
0004AFr 1  20 rr rr       jsr block_address
0004B2r 1  4C rr rr       jmp exit_key_irq
0004B5r 1               
0004B5r 1               check_6:
0004B5r 1  C9 36          cmp #'6'
0004B7r 1  D0 0B          bne check_9
0004B9r 1  A0 00          ldy #$00
0004BBr 1  20 rr rr       jsr decrement_block
0004BEr 1  20 rr rr       jsr block_address
0004C1r 1  4C rr rr       jmp exit_key_irq
0004C4r 1               
0004C4r 1               check_9:
0004C4r 1  C9 39          cmp #'9'
0004C6r 1  D0 06          bne check_4
0004C8r 1  20 rr rr       jsr show_block
0004CBr 1  4C rr rr       jmp exit_key_irq
0004CEr 1               
0004CEr 1               check_4:
0004CEr 1  C9 34          cmp #'4'
0004D0r 1  D0 12          bne check_5
0004D2r 1  AD rr rr       lda BYTE
0004D5r 1  8D rr rr       sta HEXB
0004D8r 1  AD rr rr       lda BYTE + 1
0004DBr 1  8D rr rr       sta HEXB + 1
0004DEr 1  20 rr rr       jsr byte_to_hex
0004E1r 1  4C rr rr       jmp exit_key_irq
0004E4r 1               
0004E4r 1               check_5:
0004E4r 1  C9 35          cmp #'5'
0004E6r 1  D0 24          bne exit_key_irq
0004E8r 1  20 00 30       jsr $3000
0004EBr 1  4C rr rr       jmp exit_key_irq
0004EEr 1               
0004EEr 1               
0004EEr 1               handle_new_char:
0004EEr 1  AD rr rr       lda ASCII + 2
0004F1r 1  8D rr rr       sta ASCII + 3
0004F4r 1  AD rr rr       lda ASCII + 1
0004F7r 1  8D rr rr       sta ASCII + 2
0004FAr 1  AD rr rr       lda ASCII
0004FDr 1  8D rr rr       sta ASCII + 1
000500r 1  AD rr rr       lda INKEY       ; get the new ASCII keypress value and...
000503r 1  8D rr rr       sta ASCII
000506r 1  20 rr rr       jsr print_char  ; and print it on LCD
000509r 1               
000509r 1  20 rr rr       jsr ascii_byte  ; convert the rolling 4-byte ASCII character data into two binary bytes
00050Cr 1               
00050Cr 1               exit_key_irq:
00050Cr 1               
00050Cr 1               
00050Cr 1  20 rr rr       jsr scan  ; re-enable keypad
00050Fr 1               
00050Fr 1  60             rts
000510r 1               
000510r 1               
000510r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000510r 1               
000510r 1               nmi:
000510r 1  40             rti
000511r 1               
000511r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000511r 1               ;;
000511r 1               ;;    interrupt is triggered by HIGH edge on VIA CA1 pin
000511r 1               ;;     PORTA low nibble (keypad columns) inputs are diode ORed to CA1
000511r 1               ;;
000511r 1               
000511r 1               irq:
000511r 1               ; put registers on the stack while handling the IRQ
000511r 1  48             pha
000512r 1  DA             phx
000513r 1  5A             phy
000514r 1               
000514r 1               ;  find responsible hardware
000514r 1               
000514r 1               ;  Is it VIA_1?
000514r 1               
000514r 1  AD 0D 60       lda IFR_1   ; if IFR_1 has Bit7 set (ie sign=NEGATIVE) then it IS the source of the interrupt
000517r 1  10 30          bpl next_device ; if it's not set (ie sign=POSITIVE) then branch to test the next possible device
000519r 1               
000519r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000519r 1               ;;
000519r 1               ;; IFR Flags
000519r 1               ;; B7  B6  B5  B4  B3  B2  B1  B0
000519r 1               ;; IRQ TI1 TI2 CB1 CB2 SR CA1 CA2
000519r 1               ;;
000519r 1               ;; Interrupt source is found by sequentially shifting IFR bit left to put bit-of-interest into the CARRY place
000519r 1               ;; and then branching based on whether CARRY is SET or not
000519r 1               ;;
000519r 1               ;; Only add tests for IRQ sources in use, and adjust the ASLs in each test as necessary
000519r 1               ;;
000519r 1               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000519r 1               
000519r 1               test_timer1:
000519r 1  0A             asl           ; shift IFR left twice puts the TI1 bit into CARRY....
00051Ar 1  0A             asl
00051Br 1  90 09          bcc test_cb1  ; carry clear = next test
00051Dr 1  2C 04 60       bit T1CL      ; clear not clear = handle the TIMER interrupt
000520r 1  20 rr rr       jsr rtc
000523r 1  4C rr rr       jmp exit_irq
000526r 1               
000526r 1               test_cb1:
000526r 1  0A             asl
000527r 1  0A             asl
000528r 1  90 09          bcc test_cb2
00052Ar 1  2C 00 60       bit PORTB
00052Dr 1  20 rr rr       jsr cb1_handler
000530r 1  4C rr rr       jmp exit_irq
000533r 1               
000533r 1               test_cb2:
000533r 1  0A             asl
000534r 1  90 09          bcc test_ca1
000536r 1  2C 00 60       bit PORTB
000539r 1  20 rr rr       jsr cb2_handler
00053Cr 1  4C rr rr       jmp exit_irq
00053Fr 1               
00053Fr 1               test_ca1:
00053Fr 1  0A             asl           ; shift CA1 bit into the CARRY bit & test
000540r 1  0A             asl
000541r 1  90 06          bcc exit_irq        ; carry clear = leave
000543r 1  20 rr rr       jsr keypad_handler  ; carry not clear = handle the CA1 interrupt (keypad)
000546r 1  4C rr rr       jmp exit_irq
000549r 1               
000549r 1               
000549r 1               next_device:
000549r 1               
000549r 1               exit_irq:
000549r 1  7A             ply
00054Ar 1  FA             plx
00054Br 1  68             pla
00054Cr 1               
00054Cr 1               
00054Cr 1  40             rti
00054Dr 1               
00054Dr 1  68 68 68 20  emt: .asciiz "hhh mm ss  MET"
000551r 1  6D 6D 20 73  
000555r 1  73 20 20 4D  
00055Cr 1  73 68 61 63  splash: .asciiz "shack> "
000560r 1  6B 3E 20 00  
000564r 1  3F 44 43 42  keypad_array: .byte "?DCBAF9630852E741"
000568r 1  41 46 39 36  
00056Cr 1  33 30 38 35  
000575r 1  30 31 32 33  hexascii: .byte "0123456789ABCDEF"
000579r 1  34 35 36 37  
00057Dr 1  38 39 41 42  
000585r 1  30 30 30 31  binascii: .byte "00010203040506070809"
000589r 1  30 32 30 33  
00058Dr 1  30 34 30 35  
000599r 1  31 30 31 31            .byte "10111213141516171819"
00059Dr 1  31 32 31 33  
0005A1r 1  31 34 31 35  
0005ADr 1  32 30 32 31            .byte "20212223242526272829"
0005B1r 1  32 32 32 33  
0005B5r 1  32 34 32 35  
0005C1r 1  33 30 33 31            .byte "30313233343536373839"
0005C5r 1  33 32 33 33  
0005C9r 1  33 34 33 35  
0005D5r 1  34 30 34 31            .byte "40414243444546474849"
0005D9r 1  34 32 34 33  
0005DDr 1  34 34 34 35  
0005E9r 1  35 30 35 31            .byte "50515253545556575859"
0005EDr 1  35 32 35 33  
0005F1r 1  35 34 35 35  
0005FDr 1  36 30 36 31            .byte "60616263646566676869"
000601r 1  36 32 36 33  
000605r 1  36 34 36 35  
000611r 1  37 30 37 31            .byte "70717273747576777879"
000615r 1  37 32 37 33  
000619r 1  37 34 37 35  
000625r 1  38 30 38 31            .byte "80818283848586878889"
000629r 1  38 32 38 33  
00062Dr 1  38 34 38 35  
000639r 1  39 30 39 31            .byte "90919293949596979899"
00063Dr 1  39 32 39 33  
000641r 1  39 34 39 35  
00064Dr 1  20 1D 20 1F  MO_DAYS_TABLE: .byte 32,  29,  32,  31,  32,  31,  32,  32,  31,  32,  31,  32
000651r 1  20 1F 20 20  
000655r 1  1F 20 1F 20  
000659r 1               
000659r 1               
000659r 1               
000659r 1               ; Reset/IRQ vectors
000659r 1               
000659r 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr          .word nmi
000002r 1  rr rr          .word reset
000004r 1  rr rr          .word irq
000004r 1               
